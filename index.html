<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taiko Task Manager</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom CSS for animations and theming -->
    <style>
        body {
            font-family: sans-serif;
            background-color: #0f172a; /* Fallback background */
        }
        .pulse-border-high { animation: pulse-border-high 1.2s infinite; }
        @keyframes pulse-border-high { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0.9); } 
            50% { box-shadow: 0 0 0 6px rgba(248, 113, 113, 0); } 
        }
        .pulse-border-medium { animation: pulse-border-medium 1.8s infinite; }
        @keyframes pulse-border-medium { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.8); } 
            50% { box-shadow: 0 0 0 5px rgba(251, 191, 36, 0); } 
        }
        .pulse-border-low { animation: pulse-border-low 2.5s infinite; }
        @keyframes pulse-border-low { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.7); } 
            50% { box-shadow: 0 0 0 4px rgba(56, 189, 248, 0); } 
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <footer class="fixed bottom-0 left-0 right-0 bg-slate-900/80 backdrop-blur-sm p-3 text-center text-sm text-slate-400 shadow-t-lg z-40">
        <span>Courtesy of @</span><a href="https://github.com/closedloopchaos" target="_blank" rel="noopener noreferrer" class="text-sky-400 hover:text-sky-300 font-semibold hover:underline">closedloopchaos</a>
    </footer>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel Standalone for JSX Transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Main Application Logic -->
    <script type="text/babel">

    const { useState, useEffect, useRef, useCallback, createContext, useContext, useMemo } = React;

    // --- Context for State Management ---
    const AppContext = createContext(null);

    // --- Provider Component ---
    const AppProvider = ({ children }) => {
        // --- Core State ---
        const [tasks, setTasks] = useState([]);
        const [settings, setSettings] = useState({ 
            confirmOnDelete: true, 
            autoCollapse: true, // Default to true
            verticalLayout: false
        });

        // --- Modal-related State ---
        const [taskToClose, setTaskToClose] = useState(null);
        const [taskToUnarchive, setTaskToUnarchive] = useState(null);
        const [taskToDelete, setTaskToDelete] = useState(null);
        // No new state needed here for clear archive modal, will be in App.js
        
        const appId = 'taiko-app-local';

        // --- Local Storage Persistence ---
        useEffect(() => {
            const savedTasks = localStorage.getItem(`${appId}-tasks`);
            if (savedTasks) try { setTasks(JSON.parse(savedTasks)); } catch { console.error("Could not parse saved tasks."); }
            
            const defaultSettings = {
                confirmOnDelete: true,
                autoCollapse: true,
                verticalLayout: false
            };

            const savedSettings = localStorage.getItem(`${appId}-settings`);
            if (savedSettings) {
                try { 
                    const parsed = JSON.parse(savedSettings);
                    setSettings({...defaultSettings, ...parsed}); // Merge saved over defaults
                } catch { 
                    console.error("Could not parse saved settings. Using defaults.");
                    setSettings(defaultSettings); // Fallback to defaults on parse error
                }
            } else {
                setSettings(defaultSettings); // No saved settings, use defaults
            }
        }, [appId]); // Added appId to dependencies as it's used, though it's constant here.

        useEffect(() => {
            localStorage.setItem(`${appId}-tasks`, JSON.stringify(tasks));
        }, [tasks]);

        useEffect(() => {
            localStorage.setItem(`${appId}-settings`, JSON.stringify(settings));
        }, [settings]);

        // --- Notification Permission ---
        useEffect(() => {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }, []);

        // --- Core Data Actions ---
        const updateTask = useCallback((id, updatedFields) => {
            setTasks(prevTasks => prevTasks.map(task => 
                task.id === id ? { ...task, ...updatedFields, timestamp: new Date().toISOString() } : task
            ));
        }, []);
        
        const addTask = useCallback((priority) => {
            const newTask = {
                id: crypto.randomUUID(),
                title: 'New Task', 
                checklist: [{ id: crypto.randomUUID(), text: 'First item', completed: false }],
                priority, 
                status: 'To Do', 
                archived: false, 
                rank: tasks.filter(t => t.priority === priority && !t.archived).length,
                timestamp: new Date().toISOString(), 
                startedAt: null, 
                totalElapsedTimeInSeconds: 0,
                reminderAt: null, 
                reminderFired: false, 
                tags: []
            };
            setTasks(prevTasks => [...prevTasks, newTask]);
        }, [tasks]);

        const deleteTask = useCallback((id) => {
            setTasks(prevTasks => prevTasks.filter(task => task.id !== id));
        }, []);

        const archiveTask = useCallback((id, isArchived) => {
            setTasks(prevTasks => prevTasks.map(task => {
                if (task.id === id) {
                    const updates = { archived: isArchived };
                    if (isArchived && task.status === 'In Progress' && task.startedAt) {
                        updates.totalElapsedTimeInSeconds = (task.totalElapsedTimeInSeconds || 0) + ((new Date().getTime() - new Date(task.startedAt).getTime()) / 1000);
                        updates.startedAt = null;
                    }
                    return { ...task, ...updates };
                }
                return task;
            }));
        }, []);
        
        const clearArchive = useCallback(() => {
            // This will remove all tasks that are marked as archived
            setTasks(prevTasks => prevTasks.filter(task => !task.archived));
        }, []);

        const allTags = useMemo(() => {
            const tags = new Set();
            // Only consider tags from non-archived tasks
            tasks.filter(task => !task.archived).forEach(task => {
                (task.tags || []).forEach(tag => tags.add(tag));
            });
            return Array.from(tags).sort();
        }, [tasks]);

        const contextValue = useMemo(() => ({
            tasks, updateTask, addTask, deleteTask, archiveTask, clearArchive,
            settings, setSettings, allTags,
            taskToClose, setTaskToClose,
            taskToUnarchive, setTaskToUnarchive,
            taskToDelete, setTaskToDelete,
        }), [tasks, settings, allTags, taskToClose, taskToUnarchive, taskToDelete, clearArchive]);
        
        return <AppContext.Provider value={contextValue}>{children}</AppContext.Provider>;
    };

    // --- Custom Hook to consume context ---
    const useAppContext = () => {
        const context = useContext(AppContext);
        if (context === null) throw new Error("useAppContext must be used within an AppProvider");
        return context;
    }

    // --- Helper Hooks ---
    const usePrevious = (value) => { const ref = useRef(); useEffect(() => { ref.current = value; }); return ref.current; };
    const useNow = (updateInterval = 1000) => { const [now, setNow] = useState(new Date()); useEffect(() => { const timerId = setInterval(() => setNow(new Date()), updateInterval); return () => clearInterval(timerId); }, [updateInterval]); return now; };

    // --- Helper Function for Time Parsing (MM:SS or SS duration) ---
    const parseHHMMSSDuration = (inputStr) => {
        if (!inputStr || typeof inputStr !== 'string') return null;

        const parts = inputStr.split(':').map(p => p.trim());
        
        let h = 0, m = 0, s = 0;
        let parsedSuccessfully = false;

        if (parts.length === 1) {
            const val = parseInt(parts[0], 10);
            if (!isNaN(val) && String(val) === parts[0]) { // Ensure clean integer parse
                s = val;
                parsedSuccessfully = true;
            }
        } else if (parts.length === 2) {
            const valM = parseInt(parts[0], 10);
            const valS = parseInt(parts[1], 10);
            if (!isNaN(valM) && String(valM) === parts[0] &&
                !isNaN(valS) && String(valS) === parts[1]) {
                m = valM;
                s = valS;
                parsedSuccessfully = true;
            }
        }

        if (!parsedSuccessfully) return null;

        // Normalize seconds to minutes, and minutes to hours (though hours are not directly input)
        if (s >= 60) { m += Math.floor(s / 60); s %= 60; }
        // h will remain 0 if not explicitly set, which is fine for MM:SS or SS input.
        if (m >= 60) { h += Math.floor(m / 60); m %= 60; }

        const totalSeconds = h * 3600 + m * 60 + s;
        return totalSeconds > 0 ? totalSeconds : null;
    };

    // --- Global Constants & Configurations ---
    const PRIORITIES = {
        LOW: 'low',
        MEDIUM: 'medium',
        HIGH: 'high'
    };
    const PRIORITY_ORDER = [PRIORITIES.LOW, PRIORITIES.MEDIUM, PRIORITIES.HIGH]; // For internal logic if specific order needed
    const DISPLAY_PRIORITY_ORDER = [PRIORITIES.HIGH, PRIORITIES.MEDIUM, PRIORITIES.LOW]; // For UI column display

    const TASK_STATUS = {
        TO_DO: 'To Do',
        IN_PROGRESS: 'In Progress',
        ON_HOLD: 'On Hold',
        DONE: 'Done'
    };

    const TIMEZONE_MAP = {
        EST: 'America/New_York',
        PST: 'America/Los_Angeles',
        UTC: 'UTC'
    };
    const TIMEZONE_ORDER = ['EST', 'PST', 'UTC'];

    const PRIORITY_CONFIG = {
        [PRIORITIES.LOW]: { title: "Low", color: "text-sky-400", icon: '▲', label: 'Low', pulseClass: 'pulse-border-low' },
        [PRIORITIES.MEDIUM]: { title: "Medium", color: "text-yellow-400", icon: '▲▲', label: 'Medium', pulseClass: 'pulse-border-medium' },
        [PRIORITIES.HIGH]: { title: "High", color: "text-red-400", icon: '▲▲▲', label: 'High', pulseClass: 'pulse-border-high' }
    };

    const TASK_STATUS_CONFIG = {
        [TASK_STATUS.TO_DO]: { color: 'bg-sky-500', label: 'To Do' },
        [TASK_STATUS.IN_PROGRESS]: { color: 'bg-yellow-500', label: 'In Progress' },
        [TASK_STATUS.ON_HOLD]: { color: 'bg-slate-500', label: 'On Hold' },
        [TASK_STATUS.DONE]: { color: 'bg-green-500', label: 'Done' }
    };

    // --- Icon Components (Memoized) ---
    const ArchiveIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" /></svg>);
    const RestoreIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h18M7 15l4 4 4-4M4 4h16v4H4z" /></svg>);
    const DeleteIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>);
    const BellIcon = React.memo(({ className }) => <svg xmlns="http://www.w3.org/2000/svg" className={`h-4 w-4 ${className || ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6 6 0 10-12 0v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" /></svg>);
    const ChevronDownIcon = React.memo(({ className }) => (
        <svg 
            xmlns="http://www.w3.org/2000/svg" 
            className={`h-5 w-5 ${className || ''}`} 
            viewBox="0 0 20 20" 
            fill="currentColor"
        >
            <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
        </svg>
    ));
    const SettingsIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.096 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>);
    const BugIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" strokeWidth="2" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" d="M15.362 5.214A8.252 8.252 0 0112 21 8.25 8.25 0 016.038 7.048 8.287 8.287 0 009 9.6a8.983 8.983 0 013.361-6.867 8.21 8.21 0 003 2.48z" />
            <path strokeLinecap="round" strokeLinejoin="round" d="M12 18a3.75 3.75 0 00.495-7.467 5.99 5.99 0 00-1.925 3.546 5.974 5.974 0 01-2.133-1A3.75 3.75 0 0012 18z" />
        </svg>
    ));
    const TaikoLogo = React.memo(() => <svg width="52" height="52" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" className="text-white"><g stroke="currentColor" strokeWidth="4" fill="none" strokeLinecap="round" strokeLinejoin="round"><path d="M 25,30 C 25,10 75,10 75,30 V 70 C 75,90 25,90 25,70 Z" fill="rgba(255,255,255,0.1)"/><path d="M 75,30 C 90,30 90,70 75,70" /><path d="M 25,30 C 10,30 10,70 25,70" /><circle cx="50" cy="50" r="28" strokeWidth="3"/><circle cx="50" cy="50" r="8" fill="currentColor"/></g></svg>);

    // --- Time & Countdown Components (Memoized) ---
    const LiveClock = React.memo(({ timezone, onTimezoneChange }) => {
        const time = useNow();
        const dateOptions = useMemo(() => ({ weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' }), []);
        const timeZone = useMemo(() => TIMEZONE_MAP[timezone], [timezone]);
        
        const formattedTime = time.toLocaleTimeString('en-US', { timeZone, hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const formattedDate = time.toLocaleDateString('en-US', { ...dateOptions, timeZone });

        return (
            // This container will center its direct children: time, date, and button
            <div className="flex flex-col items-center text-slate-300">
                {/* Time, now clickable and with a hover tooltip for the timezone */}
                <div 
                    onClick={onTimezoneChange} 
                    className="text-4xl font-mono tracking-wider cursor-pointer relative group"
                    title="Click to change timezone" // Added title attribute for accessibility
                >
                    {formattedTime}
                    <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1.5 opacity-0 group-hover:opacity-100 transition-opacity duration-200 whitespace-nowrap bg-slate-700 text-xs font-mono text-white px-2 py-1 rounded-md shadow-lg pointer-events-none">
                        Timezone: {timezone}
                    </div>
                </div>
                {/* Date, now a direct child, will be centered below the time */}
                <div className="text-base font-sans uppercase tracking-widest text-slate-400 mt-1">{formattedDate}</div>
            </div>
        );
    });

    const TimeElapsed = React.memo(({ startTime, totalElapsedSeconds }) => {
        const [elapsed, setElapsed] = useState('00:00:00');
        const animationFrameRef = useRef();
        const formatTime = useCallback((s) => new Date(s * 1000).toISOString().substr(11, 8), []);

        useEffect(() => {
            let isMounted = true;
            const animate = () => {
                if (!startTime || !isMounted) return;
                const currentSessionSeconds = (new Date().getTime() - new Date(startTime).getTime()) / 1000;
                setElapsed(formatTime((totalElapsedSeconds || 0) + currentSessionSeconds));
                animationFrameRef.current = requestAnimationFrame(animate);
            };
            if (startTime) animate();
            else setElapsed(formatTime(totalElapsedSeconds || 0));
            return () => { isMounted = false; cancelAnimationFrame(animationFrameRef.current); };
        }, [startTime, totalElapsedSeconds, formatTime]);
        
        return <span className="text-xs font-mono bg-slate-700/50 text-amber-300 px-2 py-1 rounded">{elapsed}</span>;
    });

    // --- Reminder Countdown Component (Re-added) ---
    const ReminderCountdown = React.memo(({ reminderAt }) => {
        const [countdown, setCountdown] = useState('');
        const now = useNow(); // Use the existing useNow hook

        const formatCountdown = useCallback((ms) => {
            if (ms <= 0) return 'Due!';
            const totalSeconds = Math.max(0, Math.floor(ms / 1000));
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }, []);

        useEffect(() => {
            if (!reminderAt) { setCountdown(''); return; }
            const remainingMs = new Date(reminderAt).getTime() - now.getTime();
            setCountdown(formatCountdown(remainingMs));
        }, [reminderAt, now, formatCountdown]);

        if (!reminderAt || countdown === '') return null;
        return <div className="text-xs text-cyan-300 font-mono">Countdown: {countdown}</div>;
    });

    // --- UI Components ---
    const ChecklistItem = React.memo(({ item, onUpdate, onDelete }) => (
        <li className="flex items-center space-x-2 group">
            <input type="checkbox" checked={item.completed} onChange={e => onUpdate(item.id, { completed: e.target.checked })} className="form-checkbox h-4 w-4 rounded bg-slate-700 border-slate-500 text-sky-500 focus:ring-sky-500 cursor-pointer" />
            <input type="text" value={item.text} onChange={e => onUpdate(item.id, { text: e.target.value })} className={`flex-grow min-w-0 bg-transparent text-sm p-1 rounded-md transition-colors ${item.completed ? 'text-slate-500 line-through' : 'text-slate-300'} focus:bg-slate-700`} />
            <Tooltip text="Delete item">
                <button onClick={() => onDelete(item.id)} className="text-slate-500 hover:text-red-400 opacity-0 group-hover:opacity-100 transition-opacity">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </Tooltip>
        </li>
    ));

    const PriorityIndicator = React.memo(({ priority, onClick }) => {
        const current = PRIORITY_CONFIG[priority] || PRIORITY_CONFIG[PRIORITIES.LOW];
        return (
            <Tooltip text={`Priority: ${current.title}. Click to change.`}>
                <button onClick={onClick} className={`flex items-center space-x-1 text-xs font-semibold ${current.color} hover:opacity-75 transition-opacity`}><span>{current.icon}</span></button>
            </Tooltip>
        );
    });

    const Tooltip = ({ text, children }) => (
        <div className="relative group flex items-center">
            {children}
            <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1.5 whitespace-nowrap bg-slate-700 text-white text-xs font-mono rounded-md py-1 px-2 shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-30">{text}</div>
        </div>
    );

    // --- Task Card Component ---
    const TaskCard = ({ task, clockTimezone }) => { // Added clockTimezone prop
        const { updateTask, archiveTask, deleteTask, allTags, settings, setTaskToDelete } = useAppContext();
        const now = useNow();

        const [isEditingTitle, setIsEditingTitle] = useState(false); // To be wrapped
        const [title, setTitle] = useState(task.title);
        const [isSettingReminder, setIsSettingReminder] = useState(false);
        const [reminderInput, setReminderInput] = useState('');
        const [checklist, setChecklist] = useState(task.checklist || []);
        const [newTag, setNewTag] = useState('');
        
        useEffect(() => { setChecklist(task.checklist || []); }, [task.checklist]);
        useEffect(() => { setTitle(task.title); }, [task.title]);
        
        const handleDeleteRequest = useCallback(() => {
            if (settings.confirmOnDelete) {
                setTaskToDelete(task.id); // Corrected: Should set the task ID
            } else {
                deleteTask(task.id);
            }
        }, [task.id, settings.confirmOnDelete, deleteTask, setTaskToDelete]);

        const handleUpdateChecklist = useCallback((updatedList) => {
            const completedItems = updatedList.filter(item => item.completed).length;
            let newStatus = task.status;

            if (updatedList.length > 0 && completedItems === updatedList.length) newStatus = TASK_STATUS.DONE;
            else if (task.status === TASK_STATUS.TO_DO && completedItems > 0) newStatus = TASK_STATUS.IN_PROGRESS;
            else if (completedItems < updatedList.length && task.status === TASK_STATUS.DONE) newStatus = TASK_STATUS.IN_PROGRESS;
            else if (completedItems === 0 && updatedList.length > 0 && task.status === TASK_STATUS.IN_PROGRESS) newStatus = TASK_STATUS.TO_DO;
            
            let updates = { checklist: updatedList };
            
            if (newStatus !== task.status) {
                updates.status = newStatus;
                if (newStatus === TASK_STATUS.IN_PROGRESS && [TASK_STATUS.TO_DO, TASK_STATUS.ON_HOLD, TASK_STATUS.DONE].includes(task.status)) {
                    updates.startedAt = new Date().toISOString();
                }
                if (task.status === TASK_STATUS.IN_PROGRESS && [TASK_STATUS.DONE, TASK_STATUS.ON_HOLD, TASK_STATUS.TO_DO].includes(newStatus) && task.startedAt) {
                    updates.totalElapsedTimeInSeconds = (task.totalElapsedTimeInSeconds || 0) + ((new Date().getTime() - new Date(task.startedAt).getTime()) / 1000);
                    updates.startedAt = null;
                }
                if (newStatus === TASK_STATUS.TO_DO && task.totalElapsedTimeInSeconds > 0) updates.totalElapsedTimeInSeconds = 0;
            }
            updateTask(task.id, updates);
        }, [task, updateTask]);
        
        const handleItemUpdate = (id, values) => handleUpdateChecklist(checklist.map(i => i.id === id ? { ...i, ...values } : i));
        const handleItemDelete = (id) => handleUpdateChecklist(checklist.filter(i => i.id !== id));
        const handleAddItem = () => handleUpdateChecklist([...checklist, { id: crypto.randomUUID(), text: 'New item', completed: false }]);
        const handleTitleBlur = () => { setIsEditingTitle(false); if (title !== task.title) updateTask(task.id, { title }); };
        
        const handleAddTag = () => {
            const currentTags = task.tags || [];
            if (newTag && !currentTags.includes(newTag)) {
                const newTags = [...currentTags, newTag.trim()];
                updateTask(task.id, { tags: newTags });
                setNewTag('');
            }
        };

        const handleRemoveTag = (tagToRemove) => {
            const newTags = (task.tags || []).filter(tag => tag !== tagToRemove);
            updateTask(task.id, { tags: newTags });
        };

        const handleSetReminder = useCallback(() => {
            if (!reminderInput) return;

            const durationInSeconds = parseHHMMSSDuration(reminderInput);

            if (durationInSeconds === null || durationInSeconds <= 0) {
                console.warn("Invalid duration input for reminder:", reminderInput);
                // Optionally, you could set an error state here to show a message to the user
                return;
            }

            const reminderDate = new Date(Date.now() + durationInSeconds * 1000);
            updateTask(task.id, { reminderAt: reminderDate.toISOString(), reminderFired: false });
            setIsSettingReminder(false);
            setReminderInput(''); // Clear input after setting
        }, [reminderInput, task.id, updateTask, setIsSettingReminder, setReminderInput]);

        const handlePriorityChange = () => {
            updateTask(task.id, { priority: PRIORITY_ORDER[(PRIORITY_ORDER.indexOf(task.priority) + 1) % PRIORITY_ORDER.length] });
        };
        
        const handlePauseTask = () => {
            if (!task.startedAt) return;
            const elapsed = (new Date().getTime() - new Date(task.startedAt).getTime()) / 1000;
            updateTask(task.id, { status: TASK_STATUS.ON_HOLD, totalElapsedTimeInSeconds: (task.totalElapsedTimeInSeconds || 0) + elapsed, startedAt: null });
        };

        const statusActions = {
            [TASK_STATUS.TO_DO]: () => updateTask(task.id, { status: TASK_STATUS.IN_PROGRESS, startedAt: new Date().toISOString() }),
            [TASK_STATUS.IN_PROGRESS]: handlePauseTask,
            [TASK_STATUS.ON_HOLD]: () => updateTask(task.id, { status: TASK_STATUS.IN_PROGRESS, startedAt: new Date().toISOString() }),
        };

        const reminderIsDue = task.reminderAt && !task.reminderFired && now > new Date(task.reminderAt);
        const pulseClass = reminderIsDue ? (PRIORITY_CONFIG[task.priority]?.pulseClass || PRIORITY_CONFIG[PRIORITIES.LOW].pulseClass) : '';

        return (
            <div className={`w-full min-w-0 bg-slate-800/80 backdrop-blur-lg border border-slate-700 rounded-lg shadow-lg mb-4 ${pulseClass}`}>
                <div className={`w-full py-1 rounded-t-lg ${TASK_STATUS_CONFIG[task.status]?.color || 'bg-gray-500'} flex items-center justify-center text-xs font-bold text-white`}>{task.status}</div>
                <div className="p-2">
                    <div className="flex justify-between items-start mb-2">
                        {isEditingTitle ? (
                            <input type="text" value={title} onChange={e => setTitle(e.target.value)} onBlur={handleTitleBlur} autoFocus className="flex-1 min-w-0 bg-slate-900/50 rounded-md p-1 text-slate-100 font-bold border border-slate-600 focus:ring-2 focus:ring-sky-500" />
                        ) : (
                            <Tooltip text="Double-click to edit title">
                                <h3 onDoubleClick={() => setIsEditingTitle(true)} className="font-bold text-slate-100 flex-grow cursor-pointer min-w-0 break-words">{task.title}</h3>
                            </Tooltip>
                        )}
                        {!task.archived && (
                            <PriorityIndicator priority={task.priority} onClick={handlePriorityChange} />
                        )}
                    </div>

                    <ul className="space-y-1 my-2">{checklist.map(item => <ChecklistItem key={item.id} item={item} onUpdate={handleItemUpdate} onDelete={handleItemDelete} />)}</ul>
                    <Tooltip text="Add a new checklist item">
                        <button onClick={handleAddItem} className="w-full text-left text-sm text-sky-400 hover:text-sky-300 p-1 rounded-md hover:bg-slate-700/50">+ Add item</button>
                    </Tooltip>

                    {/* --- Tagging UI --- */}
                    <div className="mt-3 pt-2 border-t border-slate-700/50">
                        <div className="flex flex-wrap gap-2">
                            {(task.tags || []).map(tag => (
                                <span key={tag} className="bg-slate-700 text-xs text-slate-200 px-2 py-1 rounded-full flex items-center">
                                    {tag}
                                    <Tooltip text={`Remove tag: ${tag}`}>
                                        <button onClick={() => handleRemoveTag(tag)} className="ml-2 text-slate-400 hover:text-white leading-none">&times;</button>
                                    </Tooltip>
                                </span>
                            ))}
                        </div>
                        <div className="flex mt-2">
                            <input
                                list="tag-suggestions"
                                type="text"
                                value={newTag}
                                onChange={(e) => setNewTag(e.target.value)}
                                onKeyDown={(e) => {if (e.key === 'Enter') handleAddTag()}}
                                placeholder="Add a tag..."                                className="bg-slate-900/50 text-slate-200 text-xs p-1 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500 flex-grow min-w-0"
                            />
                            <datalist id="tag-suggestions">
                                {allTags.map(tag => <option key={tag} value={tag} />)}
                            </datalist>
                            <Tooltip text="Add this tag to the task">
                                <button onClick={handleAddTag} className="ml-2 text-xs bg-sky-600 text-white px-3 rounded-md hover:bg-sky-500">Add</button>
                            </Tooltip>
                        </div>
                    </div>

                    {isSettingReminder && !task.archived && (
                        <div className="mt-3 flex items-center space-x-2">
                            <input 
                                type="text" 
                                value={reminderInput}
                                onChange={e => setReminderInput(e.target.value)} 
                                autoFocus 
                                placeholder="Set in: MM:SS / SS"                                className="bg-slate-900/70 border border-slate-600 text-slate-200 text-sm rounded-md p-1 flex-1 min-w-0"/>
                            <Tooltip text="Set reminder from input">
                                <button onClick={handleSetReminder} className="px-3 py-1 bg-sky-600 text-white text-sm rounded-md hover:bg-sky-500">Set</button>
                            </Tooltip>
                        </div>
                    )}
                    {task.reminderAt && !isSettingReminder && (
                        <div className="mt-2 text-xs">
                            <div className="text-sky-300 flex justify-between items-center mb-0.5">
                                <span>
                                    Set for: {new Date(task.reminderAt).toLocaleTimeString([], {
                                        timeZone: TIMEZONE_MAP[clockTimezone] || 'UTC', // Fallback to UTC if map fails
                                        hour: '2-digit', minute:'2-digit', second: '2-digit'
                                    })} {clockTimezone}
                                </span>
                                <Tooltip text="Clear reminder">
                                    <button onClick={() => updateTask(task.id, { reminderAt: null, reminderFired: false })} className="text-red-400 hover:text-red-300 text-xs">(clear)</button>
                                </Tooltip>
                            </div>
                            <ReminderCountdown reminderAt={task.reminderAt} />
                        </div>
                    )}
                    <div className="mt-3 pt-2 border-t border-slate-700 flex justify-between items-center">
                        <div className="flex items-center space-x-2">
                            {!task.archived && task.status === TASK_STATUS.TO_DO && !task.totalElapsedTimeInSeconds && (
                                <Tooltip text="Start working on this task">
                                    <button onClick={statusActions[TASK_STATUS.TO_DO]} className="px-3 py-1 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-500 text-sm">Start Task</button>
                                </Tooltip>
                            )}
                            {(task.status !== TASK_STATUS.TO_DO || task.totalElapsedTimeInSeconds > 0) && <TimeElapsed startTime={task.startedAt} totalElapsedSeconds={task.totalElapsedTimeInSeconds || 0} />}
                            {!task.archived && task.status === TASK_STATUS.IN_PROGRESS && task.startedAt && (
                                <Tooltip text="Pause task timer">
                                    <button onClick={statusActions[TASK_STATUS.IN_PROGRESS]} className="px-2 py-1 bg-amber-600 text-white text-xs rounded-md hover:bg-amber-500">Pause</button>
                                </Tooltip>
                            )}
                            {!task.archived && (task.status === TASK_STATUS.ON_HOLD || (task.status === TASK_STATUS.TO_DO && task.totalElapsedTimeInSeconds > 0)) && (
                                <Tooltip text="Resume working on this task">
                                    <button onClick={statusActions[TASK_STATUS.ON_HOLD]} className="px-2 py-1 bg-green-600 text-white text-xs rounded-md hover:bg-green-500">Resume</button>
                                </Tooltip>
                            )}
                        </div>
                        <div className="flex items-center space-x-2">
                            <Tooltip text={isSettingReminder ? "Cancel reminder setup" : "Set Reminder"}>
                                <button onClick={() => setIsSettingReminder(!isSettingReminder)} disabled={task.archived} className="text-slate-400 hover:text-white transition-colors p-1 rounded-full hover:bg-slate-700 disabled:opacity-50"><BellIcon /></button>
                            </Tooltip>
                            <Tooltip text={task.archived ? "Restore" : "Archive"}><button onClick={() => archiveTask(task.id, !task.archived)} className="text-slate-400 hover:text-white transition-colors p-1 rounded-full hover:bg-slate-700">{task.archived ? <RestoreIcon /> : <ArchiveIcon />}</button></Tooltip>
                            <Tooltip text="Delete Permanently"><button onClick={handleDeleteRequest} className="text-red-400 hover:text-white transition-colors p-1 rounded-full hover:bg-red-500"><DeleteIcon /></button></Tooltip>
                        </div>
                    </div>
                </div>
            </div>
        );
    };
    const MemoizedTaskCard = React.memo(TaskCard);


    // --- Main Presentation Component ---
    const App = () => {
        const { tasks, addTask, archiveTask, settings, setSettings, taskToClose, setTaskToClose, taskToUnarchive, setTaskToUnarchive, taskToDelete, setTaskToDelete, allTags, deleteTask, updateTask, clearArchive } = useAppContext();
        const now = useNow(); // Get current time, updates every second

        const [showArchived, setShowArchived] = useState(false);
        const [collapsedColumns, setCollapsedColumns] = useState(() => 
            DISPLAY_PRIORITY_ORDER.reduce((acc, priority) => {
                acc[priority] = false;
                return acc;
            }, {})
        );
        const [showSettings, setShowSettings] = useState(false);
        const [collapsedTagSwimlanes, setCollapsedTagSwimlanes] = useState({});
        const [clockTimezone, setClockTimezone] = useState('EST');
        const [activeTags, setActiveTags] = useState([]);
        const [tagSwimlanes, setTagSwimlanes] = useState([]);
        const [showSwimlaneModal, setShowSwimlaneModal] = useState(false);
        const [showClearArchiveConfirm, setShowClearArchiveConfirm] = useState(false);

        const currentTasks = useMemo(() => showArchived ? tasks.filter(t => t.archived) : tasks.filter(t => !t.archived), [tasks, showArchived]);
        
        const prevTasks = usePrevious(currentTasks);

        useEffect(() => {
            if (!prevTasks || !currentTasks) return;
            currentTasks.forEach(task => {
                const prevTask = prevTasks.find(pt => pt.id === task.id);
                if (prevTask && prevTask.status !== TASK_STATUS.DONE && task.status === TASK_STATUS.DONE && !task.archived) {
                    setTaskToClose(task);
                }
            });
        }, [currentTasks, prevTasks, setTaskToClose]);

        // --- Effect for Reminder Notifications ---
        useEffect(() => {
            if (!('Notification' in window) || Notification.permission !== 'granted') {
                return; // Notifications not supported or permission not granted
            }

            tasks.forEach(task => {
                if (task.reminderAt && !task.reminderFired && !task.archived && new Date(task.reminderAt) <= now) {
                    // console.log(`Firing reminder for task: ${task.title}`); // For debugging
                    new Notification('Taiko Task Reminder', {
                        body: `Reminder for: ${task.title}`,
                        // icon: 'your_icon.png' // Optional: Add an icon URL here
                    });
                    updateTask(task.id, { reminderFired: true });
                }
            });
        }, [tasks, now, updateTask]);


        const handleConfirmDelete = useCallback(() => {
            if (!taskToDelete) return;
            deleteTask(taskToDelete);
            setTaskToDelete(null);
        }, [taskToDelete, deleteTask]);

        const handleConfirmClearArchive = useCallback(() => {
            clearArchive();
            setShowClearArchiveConfirm(false);
            // Optionally, could switch back to viewing active tasks: setShowArchived(false);
        }, [clearArchive]);
        
        const handleToggleTagCollapse = useCallback((tag) => {
            setCollapsedTagSwimlanes(prev => ({
                ...prev,
                [tag]: !prev[tag] // Toggle the specific tag's collapsed state
            }));
        }, []); // setCollapsedTagSwimlanes is stable

        const handleAddTask = (priority) => { addTask(priority); setCollapsedColumns(p => ({ ...p, [priority]: false })); };
        const handleConfirmCloseout = (id) => { archiveTask(id, true); setTaskToClose(null); };
        const handleConfirmUnarchive = (id) => { archiveTask(id, false); setTaskToUnarchive(null); };
        const handleTimezoneChange = () => setClockTimezone(p => TIMEZONE_ORDER[(TIMEZONE_ORDER.indexOf(p) + 1) % TIMEZONE_ORDER.length]);
        
        const handleArchiveClick = () => {
            const newArchiveState = !showArchived;
            setShowArchived(newArchiveState);
        };

        // Effect to remove swimlanes if their tags are no longer in allTags (e.g., all tasks with that tag were archived)
        useEffect(() => {
            setTagSwimlanes(currentSwimlanes =>
                currentSwimlanes.filter(swimlaneTag => allTags.includes(swimlaneTag))
            );
        }, [allTags]); // Intentionally not including setTagSwimlanes as it's stable
        
        const handleTagFilterClick = (tag) => {
            setActiveTags(prev => {
                if (prev.includes(tag)) {
                    return prev.filter(t => t !== tag);
                } else {
                    return [...prev, tag];
                }
            });
        };

        const clearTagFilter = () => setActiveTags([]);

        const filteredTasks = useMemo(() => {
            if (activeTags.length === 0) {
                return currentTasks;
            }
            return currentTasks.filter(task => {
                if (!task.tags || task.tags.length === 0) return false;
                return activeTags.every(activeTag => task.tags.includes(activeTag));
            });
        }, [currentTasks, activeTags]);
        
        const { swimlaneTasks, priorityTasks } = useMemo(() => {
            const st = {};
            const pt = [];

            for (const task of filteredTasks) {
                let inSwimlane = false;
                if(task.tags) {
                    for (const tag of task.tags) {
                        if (tagSwimlanes.includes(tag)) {
                            if (!st[tag]) st[tag] = [];
                            st[tag].push(task);
                            inSwimlane = true;
                        }
                    }
                }
                if (!inSwimlane) {
                    pt.push(task);
                }
            }
            return { swimlaneTasks: st, priorityTasks: pt };
        }, [filteredTasks, tagSwimlanes]);

        const sortFn = useMemo(() => showArchived ? (a, b) => new Date(b.timestamp) - new Date(a.timestamp) : (a, b) => (a.rank || 0) - (b.rank || 0), [showArchived]);
        
        const priorityColumns = useMemo(() => ({
            [PRIORITIES.HIGH]: priorityTasks.filter(t => t.priority === PRIORITIES.HIGH).sort(sortFn),
            [PRIORITIES.MEDIUM]: priorityTasks.filter(t => t.priority === PRIORITIES.MEDIUM).sort(sortFn),
            [PRIORITIES.LOW]: priorityTasks.filter(t => t.priority === PRIORITIES.LOW).sort(sortFn),
        }), [priorityTasks, sortFn]);

        const mainLayoutClasses = settings.verticalLayout ? 'flex-col space-y-4' : 'flex-row space-x-4';
        const backgroundOverlayClass = showArchived ? 'bg-red-900/10' : '';
        
        return (
            <div className="h-screen w-screen font-sans flex flex-col overflow-x-hidden" style={{ background: `radial-gradient(circle, rgba(15, 23, 42, 0.9), rgba(10, 15, 30, 1)), linear-gradient(135deg, #0f172a 0%, #1e293b 100%)` }}>
                
                {taskToClose && <CloseoutModal task={taskToClose} onConfirm={handleConfirmCloseout} onCancel={() => setTaskToClose(null)} />}
                {taskToUnarchive && <UnarchiveModal task={taskToUnarchive} onConfirm={handleConfirmUnarchive} onCancel={() => setTaskToUnarchive(null)} />}
                {taskToDelete && <DeleteConfirmationModal onConfirm={handleConfirmDelete} onCancel={() => setTaskToDelete(null)} />}
                {showSettings && <SettingsModal settings={settings} onSettingsChange={setSettings} onClose={() => setShowSettings(false)} />}
                {showClearArchiveConfirm && <ClearArchiveConfirmationModal onConfirm={handleConfirmClearArchive} onCancel={() => setShowClearArchiveConfirm(false)} />}
                {showSwimlaneModal && <ManageSwimlanesModal allTags={allTags} activeSwimlanes={tagSwimlanes} setSwimlanes={setTagSwimlanes} onClose={() => setShowSwimlaneModal(false)} />}

                <header className="sticky top-0 z-10 p-4 bg-slate-900/70 backdrop-blur-md shadow-lg flex justify-between items-center flex-shrink-0 flex-wrap">
                    <div className="flex items-center space-x-4">
                        <TaikoLogo />
                        <div>
                            <h1 className="text-3xl font-bold" style={{ color: '#E0E7FF', textTransform: 'uppercase', letterSpacing: '0.2em' }}>Taiko</h1> {/* Removed paddingLeft for alignment */}
                            <p className="text-slate-400 text-sm">Operations Task Manager</p>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center min-w-[300px] my-2 md:my-0"><LiveClock timezone={clockTimezone} onTimezoneChange={handleTimezoneChange} /></div>
                    <div className="flex items-center space-x-4">
                        <Tooltip text="Settings">
                            <button onClick={() => setShowSettings(true)} className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><SettingsIcon /></button>
                        </Tooltip>
                        <Tooltip text="Report Issue">
                            <a 
                                href="https://github.com/closedloopchaos/taiko/issues/new/choose" 
                                target="_blank" 
                                rel="noopener noreferrer"
                                className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"
                            >
                                <BugIcon />
                            </a>
                        </Tooltip>
                        <Tooltip text={showArchived ? "View Active Tasks" : "View Archived Tasks"}>
                            <button onClick={handleArchiveClick} className={`px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:bg-slate-600 focus:outline-none focus:ring-2 focus:ring-slate-500 transition-all ${showArchived ? 'bg-red-600 hover:bg-red-500 focus:ring-red-400' : 'bg-slate-700'}`}>{showArchived ? 'View Active' : 'View Archived'}</button>
                        </Tooltip>
                        {showArchived && (
                            <Tooltip text="Permanently delete all archived tasks">
                                <button onClick={() => setShowClearArchiveConfirm(true)} className="px-4 py-2 bg-red-700 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 transition-all">Clear Archive</button>
                            </Tooltip>
                        )}
                        <AddTaskDropdown onAddTask={handleAddTask} />
                    </div>
                </header>
                
                <div className="px-6 py-2 flex-shrink-0 border-b border-slate-800 flex justify-between items-center flex-wrap gap-2">
                    <div className="flex items-center space-x-2 flex-wrap">
                        <Tooltip text="Show all tasks (clear tag filters)">
                            <button onClick={clearTagFilter}
                                    className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${activeTags.length === 0 ? 'bg-sky-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>
                                    All
                            </button>
                        </Tooltip>
                        {allTags.map(tag => (
                            <Tooltip key={tag} text={`Filter by tag: ${tag}`}>
                                <button onClick={() => handleTagFilterClick(tag)}
                                    className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${activeTags.includes(tag) ? 'bg-sky-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>
                                    {tag}
                                </button>
                            </Tooltip>
                        ))}
                    </div>
                    <Tooltip text="Configure tag-based swimlane columns">
                        <button onClick={() => setShowSwimlaneModal(true)} className="text-sm text-slate-400 hover:text-white bg-slate-700/50 px-3 py-1 rounded-md">Manage Swimlanes</button>
                    </Tooltip>
                </div>

                <main className={`flex-grow p-4 pt-4 flex overflow-auto transition-all duration-300 ${mainLayoutClasses} ${backgroundOverlayClass}`}>
                    {/* Tag Swimlanes */}
                    {tagSwimlanes.map(tag => {
                        const tasksForThisTag = swimlaneTasks[tag] || [];
                        const isManuallyCollapsed = collapsedTagSwimlanes[tag] || false;
                        // Determine effective collapsed state based on auto-collapse setting and task count
                        const isEffectivelyCollapsed = (settings.autoCollapse && tasksForThisTag.length === 0) ? true : isManuallyCollapsed;

                        return (
                            <TagColumn 
                                key={tag} 
                                tag={tag} 
                                tasks={tasksForThisTag} 
                                clockTimezone={clockTimezone}
                                isCollapsed={isEffectivelyCollapsed} // Use effective state
                                onToggleCollapse={() => handleToggleTagCollapse(tag)} // Manual toggle still updates manual state
                                isVerticalLayout={settings.verticalLayout} />
                        );
                    })}
                    {/* Priority Columns */}
                    {DISPLAY_PRIORITY_ORDER.map(priority => {
                        const tasksForThisPriority = priorityColumns[priority];
                        const isManuallyCollapsed = collapsedColumns[priority];
                        // Determine effective collapsed state
                        const isEffectivelyCollapsed = (settings.autoCollapse && tasksForThisPriority.length === 0) ? true : isManuallyCollapsed;

                        return (
                            <PriorityColumn 
                                key={priority}
                                priority={priority} 
                                tasks={tasksForThisPriority} 
                                isCollapsed={isEffectivelyCollapsed} // Use effective state
                                onToggleCollapse={() => setCollapsedColumns(p => ({...p, [priority]: !p[priority]}))} // Manual toggle
                                showArchived={showArchived} 
                                isVerticalLayout={settings.verticalLayout} 
                                clockTimezone={clockTimezone} />
                        );
                    })}
                </main>
            </div>
        );
    };

    // --- Column & Modal Components ---
    const PriorityColumn = React.memo(({ priority, tasks, isCollapsed, onToggleCollapse, showArchived, isVerticalLayout, clockTimezone }) => { // Added clockTimezone
        const columnLayoutClasses = isVerticalLayout ? 'w-full h-auto' : 'flex-1 min-w-0 h-full';
        const config = PRIORITY_CONFIG[priority] || PRIORITY_CONFIG[PRIORITIES.LOW];
        const headerContent = (
            <>
                <span>{config.title} Priority ({tasks.length})</span>
                {isVerticalLayout && ( // Only show chevron in vertical mode
                    <ChevronDownIcon className={`transform transition-transform duration-200 ${isCollapsed ? '-rotate-90' : 'rotate-0'}`} />
                )}
            </>
        );

        return (
            <div className={`flex flex-col bg-slate-900/30 rounded-lg ${columnLayoutClasses}`}>
                {isVerticalLayout ? ( // Clickable header for vertical layout
                    <Tooltip text={isCollapsed ? "Expand column" : "Collapse column"}>
                        <button 
                            onClick={onToggleCollapse} 
                            className={`flex justify-between items-center w-full text-left text-lg font-bold p-2 rounded-t-lg ${config.color} hover:bg-slate-700/50 flex-shrink-0 transition-colors`}
                        >
                            {headerContent}
                        </button>
                    </Tooltip>
                ) : ( // Static header for horizontal layout
                    <div className={`flex justify-between items-center w-full text-left text-lg font-bold p-2 rounded-t-lg ${config.color} bg-slate-900/60 flex-shrink-0`}>
                        {headerContent} {/* Chevron will be hidden by isVerticalLayout condition inside headerContent */}
                    </div>
                )}
                <div className={`
                    flex-grow p-2 transition-all duration-300 ease-in-out overflow-x-hidden
                    ${isVerticalLayout ? 
                        (isCollapsed ? 'max-h-0 py-0 opacity-0' : 'opacity-100') :
                        'max-h-full opacity-100 overflow-y-auto'
                    }
                `}>
                    {tasks.map((task) => (
                        <div key={task.id} className={`w-full min-w-0 transition-opacity duration-300 ${(!showArchived && task.status === TASK_STATUS.DONE) ? 'opacity-20' : 'opacity-100'}`}>
                            <MemoizedTaskCard task={task} clockTimezone={clockTimezone} />
                        </div>
                    ))}
                </div>
            </div>
        );
    });

    const TagColumn = React.memo(({ tag, tasks, clockTimezone, isCollapsed, onToggleCollapse, isVerticalLayout }) => {
        const columnLayoutClasses = isVerticalLayout ? 'w-full h-auto' : 'flex-1 min-w-0 h-full';

        const headerContent = (
            <>
                <span>{tag} ({tasks.length})</span>
                {isVerticalLayout && <ChevronDownIcon className={`transform transition-transform duration-200 ${isCollapsed ? '-rotate-90' : 'rotate-0'}`} />} {/* Chevron only in vertical layout */}
            </>
        );

        return (
            <div className={`flex flex-col bg-indigo-900/20 backdrop-blur-sm border border-indigo-800/50 rounded-lg ${columnLayoutClasses}`}>
                {isVerticalLayout ? ( // Clickable header for vertical layout
                    <Tooltip text={isCollapsed ? "Expand column" : "Collapse column"}>
                        <button
                            onClick={onToggleCollapse}
                            className="flex justify-between items-center w-full text-left text-lg font-bold p-2 rounded-t-lg text-indigo-300 bg-slate-900/60 hover:bg-slate-800/80 flex-shrink-0 transition-colors"
                        >
                            {headerContent}
                        </button>
                    </Tooltip>
                ) : (
                    <div className="flex justify-between items-center w-full text-left text-lg font-bold p-2 rounded-t-lg text-indigo-300 bg-slate-900/60 flex-shrink-0">
                        {headerContent}
                    </div>
                )}
                <div className={`
                    flex-grow p-2 overflow-x-hidden transition-all duration-300 ease-in-out
                    ${isVerticalLayout ?
                        (isCollapsed ? 'max-h-0 py-0 opacity-0' : 'opacity-100') :
                        'max-h-full opacity-100 overflow-y-auto'
                    }
                `}>
                    {tasks.map(task => ( 
                        <div key={task.id} className="w-full min-w-0">
                            <MemoizedTaskCard task={task} clockTimezone={clockTimezone} />
                        </div>
                    ))}
                </div>
            </div>
        );
    });

    const AddTaskDropdown = React.memo(({ onAddTask }) => {
        const [isOpen, setIsOpen] = useState(false);
        const dropdownRef = useRef(null);
        useEffect(() => {
            const handleClickOutside = (e) => { if (dropdownRef.current && !dropdownRef.current.contains(e.target)) setIsOpen(false); };
            document.addEventListener("mousedown", handleClickOutside);
            return () => document.removeEventListener("mousedown", handleClickOutside);
        }, []);
        const handleSelect = (p) => { onAddTask(p); setIsOpen(false); };
        return (
            <div className="relative" ref={dropdownRef}>
                <Tooltip text="Add a new task">
                    <button onClick={() => setIsOpen(!isOpen)} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg shadow-md hover:bg-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-opacity-75 transition-all">
                        + Add Task
                    </button>
                </Tooltip>
                {isOpen && (
                    <div className="absolute right-0 mt-2 w-48 bg-slate-700 rounded-md shadow-lg z-20">
                        {DISPLAY_PRIORITY_ORDER.map(priorityKey => (
                            <button key={priorityKey} onClick={() => handleSelect(priorityKey)} className={`w-full text-left px-4 py-2 text-sm ${PRIORITY_CONFIG[priorityKey].color} hover:bg-slate-600`}>{PRIORITY_CONFIG[priorityKey].title} Priority</button>
                        ))}
                    </div>
                )}
            </div>
        );
    });

    const Modal = ({ children, onClose }) => <div onClick={onClose} className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4">{children}</div>;
    const ModalContent = ({ title, children, onClose, headerActions }) => (
        <div 
            className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-md text-white flex flex-col" // Removed max-h-[85vh]
            onClick={e => e.stopPropagation()}
        >
            <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                <h3 className="text-xl font-bold">{title}</h3>
                {headerActions && <div>{headerActions}</div>}
            </div>
            <div className="px-3 py-4">{children}</div> {/* Adjusted padding: px-3 py-4. Removed overflow-y-auto and flex-grow */}
        </div>
    );
    const CloseoutModal = ({ task, onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Task Complete!</h3><p className="text-slate-300 mb-4">Would you like to archive the task "{task.title}"?</p><div className="flex justify-center space-x-4"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Keep Active</button><button onClick={() => onConfirm(task.id)} className="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-500">Archive Task</button></div></div></Modal>;
    const UnarchiveModal = ({ task, onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Unarchive Task?</h3><p className="text-slate-300 mb-4">You've made a change to an archived task. Would you like to move "{task.title}" back to the active board?</p><div className="flex justify-center space-x-4"><Tooltip text="Keep the task archived"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">No, Keep Archived</button></Tooltip><Tooltip text="Move task to active board"><button onClick={() => onConfirm(task.id)} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500">Yes, Unarchive</button></Tooltip></div></div></Modal>;
    const DeleteConfirmationModal = ({ onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Delete Task?</h3><p className="text-slate-300 mb-4">Are you sure you want to permanently delete this task?</p><div className="flex justify-center space-x-4"><Tooltip text="Cancel deletion"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button></Tooltip><Tooltip text="Confirm permanent deletion"><button onClick={onConfirm} className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-500">Delete</button></Tooltip></div></div></Modal>;
    const ClearArchiveConfirmationModal = ({ onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-md text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-red-400 mb-2">Clear Entire Archive?</h3><p className="text-slate-300 mb-1">Are you sure you want to permanently delete <strong className="text-red-300">ALL</strong> archived tasks?</p><p className="text-slate-400 text-sm mb-4">This action cannot be undone.</p><div className="flex justify-center space-x-4"><Tooltip text="Cancel operation"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button></Tooltip><Tooltip text="Confirm deletion of all archived tasks"><button onClick={onConfirm} className="px-4 py-2 bg-red-700 text-white font-semibold rounded-lg hover:bg-red-600">Yes, Delete All Archived</button></Tooltip></div></div></Modal>;
    const SettingsModal = ({ settings, onSettingsChange, onClose }) => { 
        const handleToggle = (key) => onSettingsChange(p => ({ ...p, [key]: !p[key] })); 
        return ( 
            <Modal onClose={onClose}>
                <ModalContent title="Settings" onClose={onClose}>
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Confirm on Delete</label>
                            <Tooltip text={settings.confirmOnDelete ? "Disable delete confirmation" : "Enable delete confirmation"}>
                                <button onClick={() => handleToggle('confirmOnDelete')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.confirmOnDelete ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.confirmOnDelete ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Auto-collapse Empty Columns</label>
                            <Tooltip text={settings.autoCollapse ? "Disable auto-collapse" : "Enable auto-collapse"}>
                                <button onClick={() => handleToggle('autoCollapse')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.autoCollapse ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.autoCollapse ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Stack Columns Vertically</label>
                            <Tooltip text={settings.verticalLayout ? "Switch to horizontal layout" : "Switch to vertical layout"}>
                                <button onClick={() => handleToggle('verticalLayout')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.verticalLayout ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.verticalLayout ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                    </div>
                </ModalContent>
            </Modal> 
        );
    };

    const ManageSwimlanesModal = ({ allTags, activeSwimlanes, setSwimlanes, onClose }) => {
        const handleToggle = (tag) => {
            setSwimlanes(prev => 
                prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag]
            );
        };

        const doneButton = (
            <Tooltip text="Close swimlane management">
                <button onClick={onClose} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500 text-sm">Done</button>
            </Tooltip>
        );

        return (
            <Modal onClose={onClose}>
                <ModalContent title="Manage Swimlanes" onClose={onClose} headerActions={doneButton}>
                    <p className="text-sm text-slate-400 mb-4">Select tags to create dedicated columns for them.</p>
                    <div className="space-y-2"> {/* Removed max-h-60 and overflow-y-auto */}
                        {allTags.map(tag => (
                            <div key={tag} className="flex items-center justify-between p-2 bg-slate-700/50 rounded-md">
                                <label className="text-slate-300">{tag}</label>
                                <Tooltip text={activeSwimlanes.includes(tag) ? `Disable swimlane for '${tag}'` : `Enable swimlane for '${tag}'`}>
                                    <button onClick={() => handleToggle(tag)} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${activeSwimlanes.includes(tag) ? 'bg-indigo-500' : 'bg-slate-600'}`}>
                                        <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${activeSwimlanes.includes(tag) ? 'translate-x-6' : 'translate-x-1'}`} />
                                    </button>
                                </Tooltip>
                            </div>
                        ))}
                    </div>
                    {/* "Done" button is now in the header via headerActions */}
                </ModalContent>
            </Modal>
        );
    };


    // --- App Entry Point ---
    const AppContainer = () => {
        return <App />;
    };

    const TaikoApp = () => {
        return (
            <AppProvider>
                <AppContainer />
            </AppProvider>
        );
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<TaikoApp />);

    </script>
</body>
</html>
