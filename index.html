<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taiko Task Master</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom CSS for animations and theming -->
    <style>
        body {
            font-family: sans-serif;
            background-color: #0f172a; /* Fallback background */
        }
        .pulse-border-high { animation: pulse-border-high 1.2s infinite; }
        @keyframes pulse-border-high { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0.9); } 
            50% { box-shadow: 0 0 0 6px rgba(248, 113, 113, 0); } 
        }
        .pulse-border-medium { animation: pulse-border-medium 1.8s infinite; }
        @keyframes pulse-border-medium { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.8); } 
            50% { box-shadow: 0 0 0 5px rgba(251, 191, 36, 0); } 
        }
        .pulse-border-low { animation: pulse-border-low 2.5s infinite; }
        @keyframes pulse-border-low { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.7); } 
            50% { box-shadow: 0 0 0 4px rgba(56, 189, 248, 0); } 
        }
        .pulse-border-default { animation: pulse-border-default 2s infinite; }
        @keyframes pulse-border-default { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(100, 116, 139, 0.7); } /* slate-500 like for default pulse */
            50% { box-shadow: 0 0 0 5px rgba(100, 116, 139, 0); } 
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <footer class="fixed bottom-0 left-0 right-0 bg-slate-900/80 backdrop-blur-sm p-3 text-center text-sm text-slate-400 shadow-t-lg z-40">
        <div class="flex items-center justify-center space-x-1.5">
            <span>Courtesy of</span>
            <a href="https://github.com/closedloopchaos" target="_blank" rel="noopener noreferrer" class="inline-flex items-center text-sky-400 hover:text-sky-300 font-semibold hover:underline">
                <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 16 16" aria-hidden="true">
                    <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
                </svg>
                closedloopchaos
            </a>
        </div>
    </footer>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel Standalone for JSX Transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Main Application Logic -->
    <script type="text/babel">

    const { useState, useEffect, useRef, useCallback, createContext, useContext, useMemo } = React;

    // --- Global Constants & Configurations ---
    const PRIORITIES = { // These are the internal constant values
        LOW: 'PRIORITY_LOW', // Actual tag string
        MEDIUM: 'PRIORITY_MEDIUM',
        HIGH: 'PRIORITY_HIGH'
    };

    const getPrioritySortValue = (priority) => {
        if (priority === PRIORITIES.HIGH) return 0;
        if (priority === PRIORITIES.MEDIUM) return 1;
        if (priority === PRIORITIES.LOW) return 2;
        return 3; // For null or undefined priority (Unprioritized)
    };

    // PRIORITY_CONFIG must be defined after PRIORITIES and before constants that use it.
    // We will add sound generation parameters here later if needed, or handle in the playSound function.
    const PRIORITY_CONFIG = {
        [PRIORITIES.LOW]: { title: "Low", color: "text-sky-400", bgColor: "bg-sky-500/20", borderColor: "border-sky-500", pulseClass: 'pulse-border-low' },
        [PRIORITIES.MEDIUM]: { title: "Medium", color: "text-yellow-400", bgColor: "bg-yellow-500/20", borderColor: "border-yellow-500", pulseClass: 'pulse-border-medium' },
        [PRIORITIES.HIGH]: { title: "High", color: "text-red-400", bgColor: "bg-red-500/20", borderColor: "border-red-500", pulseClass: 'pulse-border-high' },
        null: { title: "Unprioritized", color: "text-slate-400", bgColor: "bg-slate-500/10", borderColor: "border-slate-600", pulseClass: 'pulse-border-default' } // For null priority
    };

    // Now define constants that depend on PRIORITIES and PRIORITY_CONFIG
    const PRIORITY_DISPLAY_TITLES_ARRAY = Object.values(PRIORITIES) // e.g., ["Low", "Medium", "High"]
        .map(pKey => PRIORITY_CONFIG[pKey]?.title)
        .filter(Boolean); // e.g., ["Low", "Medium", "High"]
    const PRIORITY_TITLE_TO_CONSTANT_MAP = Object.fromEntries( // e.g., { "Low": "PRIORITY_LOW", ... }
      Object.values(PRIORITIES).map(pConstant => [PRIORITY_CONFIG[pConstant]?.title, pConstant]).filter(([title]) => title)
    ); // e.g., { "Low": "PRIORITY_LOW", ... }

    const TASK_STATUS = { TO_DO: 'To Do', IN_PROGRESS: 'In Progress', ON_HOLD: 'On Hold', DONE: 'Done' };
    const TIMEZONE_MAP = { EST: 'America/New_York', PST: 'America/Los_Angeles', UTC: 'UTC' };
    const TIMEZONE_ORDER = ['EST', 'PST', 'UTC'];
    const TASK_STATUS_CONFIG = { [TASK_STATUS.TO_DO]: { color: 'bg-sky-500', label: 'To Do' }, [TASK_STATUS.IN_PROGRESS]: { color: 'bg-yellow-500', label: 'In Progress' }, [TASK_STATUS.ON_HOLD]: { color: 'bg-slate-500', label: 'On Hold' }, [TASK_STATUS.DONE]: { color: 'bg-green-500', label: 'Done' } };

    // --- Web Audio API Sound Generation ---
    let audioContext = null;
    const getAudioContext = () => {
        if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioContext;
    };

    const playTone = (frequency, duration = 0.5, type = 'sine', volume = 0.3) => {
        const actx = getAudioContext();
        if (!actx) {
            console.warn("Web Audio API is not supported in this browser.");
            return;
        }

        const oscillator = actx.createOscillator();
        const gainNode = actx.createGain();

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, actx.currentTime);
        gainNode.gain.setValueAtTime(volume, actx.currentTime);
        // Simple fade out to avoid clicking
        gainNode.gain.linearRampToValueAtTime(0.0001, actx.currentTime + duration - 0.05);

        oscillator.connect(gainNode);
        gainNode.connect(actx.destination);

        oscillator.start();
        oscillator.stop(actx.currentTime + duration);
    };

    // --- Context for State Management ---
    const AppContext = createContext(null);

    // --- Provider Component ---
    const AppProvider = ({ children }) => {
        // --- Core State ---
        const [tasks, setTasks] = useState([]);
        const [settings, setSettings] = useState({ 
            confirmOnDelete: true, 
            autoCollapse: true, // Default to true
            verticalLayout: false
        });

        // --- Modal-related State ---
        const [taskToClose, setTaskToClose] = useState(null);
        const [taskToUnarchive, setTaskToUnarchive] = useState(null);
        const [taskToDelete, setTaskToDelete] = useState(null);
        // --- UI Interaction State (lifted from App) ---
        const [activeTags, setActiveTags] = useState([]);
        const [collapsedTagSwimlanes, setCollapsedTagSwimlanes] = useState({}); // Moved from App
        const [activeSwimlanes, setActiveSwimlanes] = useState([]);
        const [collapsedColumns, setCollapsedColumns] = useState({ 'unsorted': false }); // For fixed columns like "Unsorted"

        // No new state needed here for clear archive modal, will be in App.js
        
        const appId = 'taiko-app-local';

        // --- Local Storage Persistence ---
        useEffect(() => {
            const savedTasks = localStorage.getItem(`${appId}-tasks`);
            if (savedTasks) try { setTasks(JSON.parse(savedTasks)); } catch { console.error("Could not parse saved tasks."); }
            
            const defaultSettings = {
                confirmOnDelete: true,
                autoCollapse: true,
                verticalLayout: false
            };

            const savedSettings = localStorage.getItem(`${appId}-settings`);
            if (savedSettings) {
                try { 
                    const parsed = JSON.parse(savedSettings);
                    setSettings({...defaultSettings, ...parsed}); // Merge saved over defaults
                } catch { 
                    console.error("Could not parse saved settings. Using defaults.");
                    setSettings(defaultSettings); // Fallback to defaults on parse error
                }
            } else {
                setSettings(defaultSettings); // No saved settings, use defaults
            }

            const savedActiveTags = localStorage.getItem(`${appId}-activeTags`);
            if (savedActiveTags) try { setActiveTags(JSON.parse(savedActiveTags)); } catch { console.error("Could not parse saved active tags."); setActiveTags([]); }

            const savedActiveSwimlanes = localStorage.getItem(`${appId}-activeSwimlanes`);
            if (savedActiveSwimlanes) try { setActiveSwimlanes(JSON.parse(savedActiveSwimlanes)); } catch { console.error("Could not parse saved active swimlanes."); setActiveSwimlanes([]); }

            const savedCollapsedTagSwimlanes = localStorage.getItem(`${appId}-collapsedTagSwimlanes`);
            if (savedCollapsedTagSwimlanes) try { setCollapsedTagSwimlanes(JSON.parse(savedCollapsedTagSwimlanes)); } catch { console.error("Could not parse saved collapsed tag swimlanes."); setCollapsedTagSwimlanes({}); }
            
            const defaultCollapsedColumns = { 'unsorted': false }; // Updated key
            const savedCollapsedColumns = localStorage.getItem(`${appId}-collapsedColumns`);
            if (savedCollapsedColumns) {
                try {
                    setCollapsedColumns(JSON.parse(savedCollapsedColumns));
                } catch {
                    console.error("Could not parse saved collapsed columns. Using defaults.");
                    setCollapsedColumns(defaultCollapsedColumns);
                }
            } else {
                setCollapsedColumns(defaultCollapsedColumns);
            }
        }, [appId]); 

        useEffect(() => {
            localStorage.setItem(`${appId}-tasks`, JSON.stringify(tasks));
        }, [tasks]);

        useEffect(() => {
            localStorage.setItem(`${appId}-settings`, JSON.stringify(settings));
        }, [settings]);

        useEffect(() => {
            localStorage.setItem(`${appId}-activeTags`, JSON.stringify(activeTags));
        }, [activeTags, appId]);

        useEffect(() => {
            localStorage.setItem(`${appId}-activeSwimlanes`, JSON.stringify(activeSwimlanes));
        }, [activeSwimlanes, appId]);

        useEffect(() => {
            localStorage.setItem(`${appId}-collapsedTagSwimlanes`, JSON.stringify(collapsedTagSwimlanes));
        }, [collapsedTagSwimlanes, appId]);

        useEffect(() => {
            localStorage.setItem(`${appId}-collapsedColumns`, JSON.stringify(collapsedColumns));
        }, [collapsedColumns, appId]);

        // --- Notification Permission ---
        useEffect(() => {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }, []);

        // --- Core Data Actions ---
        const updateTask = useCallback((id, updatedFields) => {
            setTasks(prevTasks => prevTasks.map(task => 
                task.id === id ? { ...task, ...updatedFields, timestamp: new Date().toISOString() } : task
            ));
        }, []);
        
        const addTask = useCallback((initialTitle = 'New Task', initialPriority = null, initialTags = []) => {
            const newTask = {
                id: crypto.randomUUID(),
                title: initialTitle, 
                checklist: [{ id: crypto.randomUUID(), text: 'First item', completed: false }],
                priority: initialPriority, 
                status: 'To Do', 
                archived: false,
                rank: tasks.filter(t => t.priority === initialPriority && !t.archived).length, // Rank will be based on the current priority value
                timestamp: new Date().toISOString(), 
                startedAt: null, 
                totalElapsedTimeInSeconds: 0,
                reminderAt: null, 
                reminderFired: false, 
                tags: Array.isArray(initialTags) ? [...new Set(initialTags)] : [] // Ensure unique tags
            };
            setTasks(prevTasks => [newTask, ...prevTasks].sort((a, b) => (a.rank || 0) - (b.rank || 0) || new Date(a.timestamp) - new Date(b.timestamp))); // Add to top and re-sort
        }, [tasks]);

        const deleteTask = useCallback((id) => {
            setTasks(prevTasks => prevTasks.filter(task => task.id !== id));
        }, []);

        const archiveTask = useCallback((id, isArchived) => {
            setTasks(prevTasks => prevTasks.map(task => {
                if (task.id === id) {
                    const updates = { archived: isArchived };
                    if (isArchived && task.status === 'In Progress' && task.startedAt) {
                        updates.totalElapsedTimeInSeconds = (task.totalElapsedTimeInSeconds || 0) + ((new Date().getTime() - new Date(task.startedAt).getTime()) / 1000);
                        updates.startedAt = null;
                    }
                    return { ...task, ...updates };
                }
                return task;
            }));
        }, []);
        
        const clearArchive = useCallback(() => {
            // This will remove all tasks that are marked as archived
            setTasks(prevTasks => prevTasks.filter(task => !task.archived));
        }, []);

        const allTags = useMemo(() => {
            // allTags should only contain actual custom tags, not priority display titles.
            const customTagsSet = new Set();
            tasks.forEach(task => { // Iterate over all tasks for comprehensive tag discovery
                (task.tags || []).forEach(tag => {
                    // Check if the tag is a priority display title (case-insensitive)
                    const isPriorityTitle = PRIORITY_DISPLAY_TITLES_ARRAY.some(
                        pTitle => pTitle.toLowerCase() === tag.toLowerCase()
                    );
                    if (!isPriorityTitle) {
                        customTagsSet.add(tag);
                    }
                });
            });
            return Array.from(customTagsSet).sort();
        }, [tasks, PRIORITY_DISPLAY_TITLES_ARRAY]); // PRIORITY_DISPLAY_TITLES_ARRAY is stable

        // --- Swimlane Collapse Management ---
        const expandSwimlane = useCallback((swimlaneName) => {
            setCollapsedTagSwimlanes(prev => ({ ...prev, [swimlaneName]: false }));
        }, []); // setCollapsedTagSwimlanes is stable
        const toggleSwimlaneCollapse = useCallback((swimlaneName) => {
            setCollapsedTagSwimlanes(prev => ({ ...prev, [swimlaneName]: !prev[swimlaneName] }));
        }, []); // setCollapsedTagSwimlanes is stable


        const contextValue = useMemo(() => ({
            tasks, updateTask, addTask, deleteTask, archiveTask, clearArchive,
            settings, setSettings, allTags,
            taskToClose, setTaskToClose,
            taskToUnarchive, setTaskToUnarchive,
            taskToDelete, setTaskToDelete,
            activeTags, setActiveTags,
            activeSwimlanes, setActiveSwimlanes,
            collapsedTagSwimlanes, setCollapsedTagSwimlanes,
            collapsedColumns, setCollapsedColumns, // Added for fixed columns
            expandSwimlane,        
            toggleSwimlaneCollapse 
        }), [
            tasks, updateTask, addTask, deleteTask, archiveTask, clearArchive,
            settings, setSettings, allTags,
            taskToClose, setTaskToClose,
            taskToUnarchive, setTaskToUnarchive,
            taskToDelete, setTaskToDelete,
            activeTags, setActiveTags,
            activeSwimlanes, setActiveSwimlanes,
            collapsedTagSwimlanes, setCollapsedTagSwimlanes,
            collapsedColumns, setCollapsedColumns,
            expandSwimlane, toggleSwimlaneCollapse
        ]);
        
        return <AppContext.Provider value={contextValue}>{children}</AppContext.Provider>;
    };

    // --- Custom Hook to consume context ---
    const useAppContext = () => {
        const context = useContext(AppContext);
        if (context === null) throw new Error("useAppContext must be used within an AppProvider");
        return context;
    }

    // --- Helper Hooks ---
    const usePrevious = (value) => { const ref = useRef(); useEffect(() => { ref.current = value; }); return ref.current; };
    const useNow = (updateInterval = 1000) => { const [now, setNow] = useState(new Date()); useEffect(() => { const timerId = setInterval(() => setNow(new Date()), updateInterval); return () => clearInterval(timerId); }, [updateInterval]); return now; };

    // --- Helper Function for Time Parsing (MM:SS or SS duration) ---
    const parseHHMMSSDuration = (inputStr) => {
        if (!inputStr || typeof inputStr !== 'string') return null;

        const parts = inputStr.split(':').map(p => p.trim());
        
        let h = 0, m = 0, s = 0;
        let parsedSuccessfully = false;

        if (parts.length === 1) {
            const val = parseInt(parts[0], 10);
            if (!isNaN(val) && String(val) === parts[0]) { // Ensure clean integer parse
                s = val;
                parsedSuccessfully = true;
            }
        } else if (parts.length === 2) {
            const valM = parseInt(parts[0], 10);
            const valS = parseInt(parts[1], 10);
            if (!isNaN(valM) && String(valM) === parts[0] &&
                !isNaN(valS) && String(valS) === parts[1]) {
                m = valM;
                s = valS;
                parsedSuccessfully = true;
            }
        }

        if (!parsedSuccessfully) return null;

        // Normalize seconds to minutes, and minutes to hours (though hours are not directly input)
        if (s >= 60) { m += Math.floor(s / 60); s %= 60; }
        // h will remain 0 if not explicitly set, which is fine for MM:SS or SS input.
        if (m >= 60) { h += Math.floor(m / 60); m %= 60; }

        const totalSeconds = h * 3600 + m * 60 + s;
        return totalSeconds > 0 ? totalSeconds : null;
    };
    const PRIORITY_TAGS_LIST = [PRIORITIES.LOW, PRIORITIES.MEDIUM, PRIORITIES.HIGH]; // May be unused by new logic but kept for now.
    const DISPLAY_PRIORITY_ORDER = [PRIORITIES.LOW, PRIORITIES.MEDIUM, PRIORITIES.HIGH]; // For UI column display - CHANGED ORDER

    // --- Icon Components (Memoized) ---
    const ArchiveIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" /></svg>);
    const RestoreIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 10h18M7 15l4 4 4-4M4 4h16v4H4z" /></svg>);
    const DeleteIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>);
    const BellIcon = React.memo(({ className }) => <svg xmlns="http://www.w3.org/2000/svg" className={`h-4 w-4 ${className || ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6 6 0 10-12 0v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" /></svg>);
    const ChevronDownIcon = React.memo(({ className }) => (
        <svg 
            xmlns="http://www.w3.org/2000/svg" 
            className={`h-5 w-5 ${className || ''}`} 
            viewBox="0 0 20 20" 
            fill="currentColor"
        >
            <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
        </svg>
    ));
    const SettingsIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.096 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>);
    const BugIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" strokeWidth="2" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" d="M15.362 5.214A8.252 8.252 0 0112 21 8.25 8.25 0 016.038 7.048 8.287 8.287 0 009 9.6a8.983 8.983 0 013.361-6.867 8.21 8.21 0 003 2.48z" />
            <path strokeLinecap="round" strokeLinejoin="round" d="M12 18a3.75 3.75 0 00.495-7.467 5.99 5.99 0 00-1.925 3.546 5.974 5.974 0 01-2.133-1A3.75 3.75 0 0012 18z" />
        </svg>
    ));
    const PlusIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>);
    const TaikoLogo = React.memo(() => <svg width="52" height="52" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" className="text-white"><g stroke="currentColor" strokeWidth="4" fill="none" strokeLinecap="round" strokeLinejoin="round"><path d="M 25,30 C 25,10 75,10 75,30 V 70 C 75,90 25,90 25,70 Z" fill="rgba(255,255,255,0.1)"/><path d="M 75,30 C 90,30 90,70 75,70" /><path d="M 25,30 C 10,30 10,70 25,70" /><circle cx="50" cy="50" r="28" strokeWidth="3"/><circle cx="50" cy="50" r="8" fill="currentColor"/></g></svg>);

    // --- Time & Countdown Components (Memoized) ---
    const LiveClock = React.memo(({ timezone, onTimezoneChange }) => {
        const time = useNow();
        const dateOptions = useMemo(() => ({ weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' }), []);
        const timeZone = useMemo(() => TIMEZONE_MAP[timezone], [timezone]);
        
        const formattedTime = time.toLocaleTimeString('en-US', { timeZone, hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const formattedDate = time.toLocaleDateString('en-US', { ...dateOptions, timeZone });

        return (
            // This container will center its direct children: time, date, and button
            <div className="flex flex-col items-center text-slate-300">
                {/* Time, now clickable and with a hover tooltip for the timezone */}
                <div 
                    onClick={onTimezoneChange} 
                    className="text-4xl font-mono tracking-wider cursor-pointer relative group"
                    title="Click to change timezone" // Added title attribute for accessibility
                >
                    {formattedTime}
                    <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1.5 opacity-0 group-hover:opacity-100 transition-opacity duration-200 whitespace-nowrap bg-slate-700 text-xs font-mono text-white px-2 py-1 rounded-md shadow-lg pointer-events-none">
                        Timezone: {timezone}
                    </div>
                </div>
                {/* Date, now a direct child, will be centered below the time */}
                <div className="text-base font-sans uppercase tracking-widest text-slate-400 mt-1">{formattedDate}</div>
            </div>
        );
    });

    const TimeElapsed = React.memo(({ startTime, totalElapsedSeconds }) => {
        const [elapsed, setElapsed] = useState('00:00:00');
        const animationFrameRef = useRef();
        const formatTime = useCallback((s) => new Date(s * 1000).toISOString().substr(11, 8), []);

        useEffect(() => {
            let isMounted = true;
            const animate = () => {
                if (!startTime || !isMounted) return;
                const currentSessionSeconds = (new Date().getTime() - new Date(startTime).getTime()) / 1000;
                setElapsed(formatTime((totalElapsedSeconds || 0) + currentSessionSeconds));
                animationFrameRef.current = requestAnimationFrame(animate);
            };
            if (startTime) animate();
            else setElapsed(formatTime(totalElapsedSeconds || 0));
            return () => { isMounted = false; cancelAnimationFrame(animationFrameRef.current); };
        }, [startTime, totalElapsedSeconds, formatTime]);
        
        return <span className="text-xs font-mono bg-slate-700/50 text-amber-300 px-2 py-1 rounded">{elapsed}</span>;
    });

    // --- Reminder Countdown Component (Re-added) ---
    const ReminderCountdown = React.memo(({ reminderAt }) => {
        const [countdown, setCountdown] = useState('');
        const now = useNow(); // Use the existing useNow hook

        const formatCountdown = useCallback((ms) => {
            if (ms <= 0) return 'Due!';
            const totalSeconds = Math.max(0, Math.floor(ms / 1000));
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }, []);

        useEffect(() => {
            if (!reminderAt) { setCountdown(''); return; }
            const remainingMs = new Date(reminderAt).getTime() - now.getTime();
            setCountdown(formatCountdown(remainingMs));
        }, [reminderAt, now, formatCountdown]);

        if (!reminderAt || countdown === '') return null;
        return <div className="text-xs text-cyan-300 font-mono">Countdown: {countdown}</div>;
    });

    // --- UI Components ---
    const ChecklistItem = React.memo(({ item, onUpdate, onDelete }) => (
        <li className="flex items-center space-x-2 group">
            <input type="checkbox" checked={item.completed} onChange={e => onUpdate(item.id, { completed: e.target.checked })} className="form-checkbox h-4 w-4 rounded bg-slate-700 border-slate-500 text-sky-500 focus:ring-sky-500 cursor-pointer" />
            <input type="text" value={item.text} onChange={e => onUpdate(item.id, { text: e.target.value })} className={`flex-grow min-w-0 bg-transparent text-sm p-1 rounded-md transition-colors ${item.completed ? 'text-slate-500 line-through' : 'text-slate-300'} focus:bg-slate-700`} />
            <Tooltip text="Delete item">
                <button onClick={() => onDelete(item.id)} className="text-slate-500 hover:text-red-400 opacity-0 group-hover:opacity-100 transition-opacity">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </Tooltip>
        </li>
    ));

    const Tooltip = ({ text, children }) => (
        <div className="relative group flex items-center">
            {children}
            <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1.5 whitespace-nowrap bg-slate-700 text-white text-xs font-mono rounded-md py-1 px-2 shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-30">{text}</div>
        </div>
    );

    // --- Task Card Component ---
    const TaskCard = ({ task, clockTimezone }) => { // Added clockTimezone prop
        const { updateTask, archiveTask, deleteTask, allTags, settings, setTaskToDelete, setActiveTags, setActiveSwimlanes, expandSwimlane } = useAppContext();
        const now = useNow();

        const [isEditingTitle, setIsEditingTitle] = useState(false); // To be wrapped
        const [title, setTitle] = useState(task.title);
        const [isSettingReminder, setIsSettingReminder] = useState(false);
        const [reminderInput, setReminderInput] = useState('');
        const [checklist, setChecklist] = useState(task.checklist || []);
        const [newTag, setNewTag] = useState('');
        const [tagError, setTagError] = useState('');
        
        useEffect(() => { setChecklist(task.checklist || []); }, [task.checklist]);
        useEffect(() => { setTitle(task.title); }, [task.title]);

        useEffect(() => {
            if (tagError) {
                const timer = setTimeout(() => {
                    setTagError('');
                }, 3000); // Clear error after 3 seconds
                return () => clearTimeout(timer);
            }
        }, [tagError]);
        
        const handleDeleteRequest = useCallback(() => {
            if (settings.confirmOnDelete) {
                setTaskToDelete(task.id); // Corrected: Should set the task ID
            } else {
                deleteTask(task.id);
            }
        }, [task.id, settings.confirmOnDelete, deleteTask, setTaskToDelete]);

        const handleUpdateChecklist = useCallback((updatedList) => {
            const completedItems = updatedList.filter(item => item.completed).length;
            let newStatus = task.status; // Start with current status

            if (updatedList.length > 0 && completedItems === updatedList.length) {
                // All items checked
                newStatus = TASK_STATUS.DONE;
            } else if (completedItems > 0) {
                // At least one item is checked, but not all
                if (task.status === TASK_STATUS.TO_DO || task.status === TASK_STATUS.ON_HOLD) {
                    newStatus = TASK_STATUS.IN_PROGRESS; // Move from To Do or On Hold to In Progress
                } else if (task.status === TASK_STATUS.DONE) {
                    newStatus = TASK_STATUS.IN_PROGRESS; // Move from Done to In Progress if an item is unchecked
                }
                // If already IN_PROGRESS and some items are checked (but not all), it remains IN_PROGRESS.
            } else if (completedItems === 0 && updatedList.length > 0) {
                // All items are unchecked (and there are items)
                if (task.status === TASK_STATUS.IN_PROGRESS) {
                    newStatus = TASK_STATUS.TO_DO; // Move from In Progress to To Do
                }
                // If ON_HOLD and all items become unchecked, it remains ON_HOLD by default.
            }
            let updates = { checklist: updatedList };
            
            if (newStatus !== task.status) {
                updates.status = newStatus;
                if (newStatus === TASK_STATUS.IN_PROGRESS && [TASK_STATUS.TO_DO, TASK_STATUS.ON_HOLD, TASK_STATUS.DONE].includes(task.status)) {
                    updates.startedAt = new Date().toISOString();
                }
                if (task.status === TASK_STATUS.IN_PROGRESS && [TASK_STATUS.DONE, TASK_STATUS.ON_HOLD, TASK_STATUS.TO_DO].includes(newStatus) && task.startedAt) {
                    updates.totalElapsedTimeInSeconds = (task.totalElapsedTimeInSeconds || 0) + ((new Date().getTime() - new Date(task.startedAt).getTime()) / 1000);
                    updates.startedAt = null;
                }
                if (newStatus === TASK_STATUS.TO_DO && task.totalElapsedTimeInSeconds > 0) updates.totalElapsedTimeInSeconds = 0;
            }
            updateTask(task.id, updates);
        }, [task, updateTask]);
        
        const handleItemUpdate = (id, values) => handleUpdateChecklist(checklist.map(i => i.id === id ? { ...i, ...values } : i));
        const handleItemDelete = (id) => handleUpdateChecklist(checklist.filter(i => i.id !== id));
        const handleAddItem = () => handleUpdateChecklist([...checklist, { id: crypto.randomUUID(), text: 'New item', completed: false }]);
        const handleTitleBlur = () => { setIsEditingTitle(false); if (title !== task.title) updateTask(task.id, { title }); };
        
        const handleAddTag = () => {
            const currentTags = task.tags || [];
            const trimmedNewTag = newTag.trim();
    
            // Prohibit adding priority display titles as custom tags (case-insensitive)
            const isPriorityTitle = PRIORITY_DISPLAY_TITLES_ARRAY.some(
                pTitle => pTitle.toLowerCase() === trimmedNewTag.toLowerCase()
            );
    
            if (trimmedNewTag && !isPriorityTitle && !currentTags.includes(trimmedNewTag)) {
                // Get custom tags *before* adding the new one.
                // task.tags should only store custom tags.
                const existingCustomTagsCount = currentTags.length;
    
                const newTagsArray = [...currentTags, trimmedNewTag];
                updateTask(task.id, { tags: newTagsArray });
    
                // Only auto-activate swimlane if this is the *first* custom tag added to the task,
                // and ensure the tag itself is not a priority display title (which it shouldn't be for custom tags).
                if (existingCustomTagsCount === 0 && !PRIORITY_DISPLAY_TITLES_ARRAY.includes(trimmedNewTag)) {
                    setActiveSwimlanes(prevActiveSwimlanes => {
                        expandSwimlane(trimmedNewTag); 
                        if (!prevActiveSwimlanes.includes(trimmedNewTag)) {
                            return [...prevActiveSwimlanes, trimmedNewTag]; 
                        }
                        return prevActiveSwimlanes;
                    });
                }
            } else if (isPriorityTitle) {
                setTagError('Cannot add "Low", "Medium", or "High" as custom tags. Use priority buttons.');
                playTone(220, 0.3, 'square', 0.2); // Play a low, short error tone
            }
            setNewTag(''); // Clear input in all cases
        };

        const handleRemoveTag = (tagToRemove) => {
            const currentTags = task.tags || [];
            const newTags = (task.tags || []).filter(tag => tag !== tagToRemove);
            updateTask(task.id, { tags: newTags });

            // After removing the tag, check if the task still has tags.
            // If it does, find the first remaining tag that corresponds to a potential swimlane
            // (either a priority display title or a custom tag) and ensure that swimlane
            // is active and expanded. This helps guide the task to a relevant column.
            
            // Find the first remaining tag that is either a priority display title or a custom tag
            const firstRemainingPotentialSwimlaneTag = newTags.find(tag => 
                PRIORITY_DISPLAY_TITLES_ARRAY.includes(tag) || allTags.includes(tag) // Check if it's a known tag/priority
            );

            if (firstRemainingPotentialSwimlaneTag) {
                 // Ensure this potential swimlane is active and expanded
                 setActiveSwimlanes(prevActiveSwimlanes => {
                    expandSwimlane(firstRemainingPotentialSwimlaneTag); // Expand it
                    return prevActiveSwimlanes.includes(firstRemainingPotentialSwimlaneTag) ? prevActiveSwimlanes : [...prevActiveSwimlanes, firstRemainingPotentialSwimlaneTag]; // Add to active if not already
                 });
            }
        };

        const handleSetReminder = useCallback(() => {
            if (!reminderInput) return;

            const durationInSeconds = parseHHMMSSDuration(reminderInput);

            if (durationInSeconds === null || durationInSeconds <= 0) {
                console.warn("Invalid duration input for reminder:", reminderInput);
                // Optionally, you could set an error state here to show a message to the user
                return;
            }

            const reminderDate = new Date(Date.now() + durationInSeconds * 1000);
            updateTask(task.id, { reminderAt: reminderDate.toISOString(), reminderFired: false });
            setIsSettingReminder(false);
            setReminderInput(''); // Clear input after setting
        }, [reminderInput, task.id, updateTask, setIsSettingReminder, setReminderInput]);
        
        const handleSetPriorityTag = (priorityConstantToSet) => { // e.g., PRIORITIES.HIGH or null
            let currentTaskTags = task.tags || [];
            
            let newPriorityConstant = task.priority; // Start with current priority
            let newPriorityDisplayTitle = null;

            if (priorityConstantToSet && task.priority !== priorityConstantToSet) {
                newPriorityConstant = priorityConstantToSet;
                newPriorityDisplayTitle = PRIORITY_CONFIG[priorityConstantToSet].title;
            } else if (priorityConstantToSet && task.priority === priorityConstantToSet) {
                // Clicking the same priority again clears it
                newPriorityConstant = null;
            } else if (!priorityConstantToSet) { // Explicitly clearing (e.g. "Clear" button)
                 newPriorityConstant = null;
            }

            updateTask(task.id, { priority: newPriorityConstant });

            if (newPriorityDisplayTitle && !activeSwimlanes.includes(newPriorityDisplayTitle)) {
                 setActiveSwimlanes(prevActiveSwimlanes => {
                    return [...prevActiveSwimlanes, newPriorityDisplayTitle];
                });
            }
        };
        


        const handlePauseTask = () => {
            if (!task.startedAt) return;
            const elapsed = (new Date().getTime() - new Date(task.startedAt).getTime()) / 1000;
            updateTask(task.id, { status: TASK_STATUS.ON_HOLD, totalElapsedTimeInSeconds: (task.totalElapsedTimeInSeconds || 0) + elapsed, startedAt: null });
        };

        const statusActions = {
            [TASK_STATUS.TO_DO]: () => updateTask(task.id, { status: TASK_STATUS.IN_PROGRESS, startedAt: new Date().toISOString() }),
            [TASK_STATUS.IN_PROGRESS]: handlePauseTask,
            [TASK_STATUS.ON_HOLD]: () => updateTask(task.id, { status: TASK_STATUS.IN_PROGRESS, startedAt: new Date().toISOString() }),
        };

        // Pulse should continue as long as the reminder time has passed,
        // regardless of whether the notification itself has fired.
        const reminderIsDue = task.reminderAt && new Date(task.reminderAt) <= now;
        const pulseClass = reminderIsDue ? (PRIORITY_CONFIG[task.priority]?.pulseClass || '') : '';

        return (
            <div className={`w-full min-w-0 bg-slate-800/80 backdrop-blur-lg border border-slate-700 rounded-lg shadow-lg mb-4 ${pulseClass}`}>
                <div className={`w-full py-1 rounded-t-lg ${TASK_STATUS_CONFIG[task.status]?.color || 'bg-gray-500'} flex items-center justify-center text-xs font-bold text-white`}>{task.status}</div>
                <div className="p-2">
                    <div className="flex justify-between items-start mb-2">
                        {isEditingTitle ? (
                            <input type="text" value={title} onChange={e => setTitle(e.target.value)} onBlur={handleTitleBlur} autoFocus className="flex-1 min-w-0 bg-slate-900/50 rounded-md p-1 text-slate-100 font-bold border border-slate-600 focus:ring-2 focus:ring-sky-500" />
                        ) : ( // Priority Indicator removed from here
                            <Tooltip text="Double-click to edit title">
                                <h3 onDoubleClick={() => setIsEditingTitle(true)} className="font-bold text-slate-100 flex-grow cursor-pointer min-w-0 break-words">{task.title}</h3>
                            </Tooltip>
                        )}
                        {/* Priority Indicator removed from here */}
                    </div>

                    <ul className="space-y-1 my-2">{checklist.map(item => <ChecklistItem key={item.id} item={item} onUpdate={handleItemUpdate} onDelete={handleItemDelete} />)}</ul>
                    <Tooltip text="Add a new checklist item">
                        <button onClick={handleAddItem} className="w-full text-left text-sm text-sky-400 hover:text-sky-300 p-1 rounded-md hover:bg-slate-700/50">+ Add item</button>
                    </Tooltip>

                    {/* --- Tagging UI --- */}
                    <div className="mt-3 pt-2 border-t border-slate-700/50">
                        <div className="flex flex-wrap items-center gap-1 mb-2">
                            <span className="text-xs text-slate-400">Priority:</span> {/* Removed mr-2, gap will handle spacing */}
                            {DISPLAY_PRIORITY_ORDER.map(pTag => ( /* Use DISPLAY_PRIORITY_ORDER for consistent button order */
                                <Tooltip key={pTag} text={`Set priority to ${PRIORITY_CONFIG[pTag].title}`}>
                                    <button 
                                        onClick={() => handleSetPriorityTag(pTag)}
                                        className={`px-2 py-0.5 text-xs font-semibold rounded-md border ${task.priority === pTag ? `${PRIORITY_CONFIG[pTag].bgColor} ${PRIORITY_CONFIG[pTag].borderColor} ${PRIORITY_CONFIG[pTag].color}` : `bg-slate-600/50 border-slate-500 text-slate-300 hover:${PRIORITY_CONFIG[pTag].bgColor}`} flex-shrink-0`} /* Removed mr-1 mb-1, added flex-shrink-0 */
                                    >
                                        {PRIORITY_CONFIG[pTag].title}
                                    </button>
                                </Tooltip>
                            ))}
                            <Tooltip text="Clear priority (Unprioritized)">
                                <button onClick={() => handleSetPriorityTag(null)} className={`px-2 py-0.5 text-xs font-semibold rounded-md border ${task.priority === null ? `${PRIORITY_CONFIG[null].bgColor} ${PRIORITY_CONFIG[null].borderColor} ${PRIORITY_CONFIG[null].color}` : 'bg-slate-600/50 border-slate-500 text-slate-300 hover:bg-slate-500/30'} flex-shrink-0`}> {/* Removed mr-1 mb-1, added flex-shrink-0 */}
                                    Clear
                                </button>
                            </Tooltip>
                        </div>
                        </div>
                    <div className="mt-3 pt-2 border-t border-slate-700/50"> {/* This is the start of the custom tags section, unchanged by this request */}
                        <div className="flex flex-wrap gap-2 mb-2"> {/* Added mb-2 for spacing before input */}
                            {(task.tags || []).filter(tag => !PRIORITY_DISPLAY_TITLES_ARRAY.includes(tag)).map(tag => (
                                <span key={tag} className="bg-slate-700 text-xs text-slate-200 px-2 py-1 rounded-full flex items-center">
                                    {tag}
                                    <Tooltip text={`Remove tag: ${tag}`}>
                                        <button onClick={() => handleRemoveTag(tag)} className="ml-2 text-slate-400 hover:text-white leading-none">&times;</button>
                                    </Tooltip>
                                </span>
                            ))}
                        </div>
                        <div className="flex"> {/* Removed mt-2 as mb-2 was added above */}
                            <input
                                list="tag-suggestions"
                                type="text"
                                value={newTag}
                                onChange={(e) => setNewTag(e.target.value)}
                                onKeyDown={(e) => {if (e.key === 'Enter') handleAddTag()}}
                                placeholder="Add a tag..."                                className="bg-slate-900/50 text-slate-200 text-xs p-1 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500 flex-grow min-w-0"
                            />
                            <datalist id="tag-suggestions">
                                {allTags.map(tag => <option key={tag} value={tag} />)}
                            </datalist>
                            <Tooltip text="Add this tag to the task">
                                <button onClick={handleAddTag} className="ml-2 text-xs bg-sky-600 text-white px-3 py-1 rounded-md hover:bg-sky-500">Add</button> {/* Adjusted py-1 for consistency */}
                            </Tooltip>
                        </div>
                        {tagError && <div className="mt-1.5 text-xs text-red-400">{tagError}</div>}
                    </div>

                    {isSettingReminder && !task.archived && (
                        <div className="mt-3 flex items-center space-x-2">
                            <input 
                                type="text" 
                                value={reminderInput}
                                onChange={e => setReminderInput(e.target.value)} 
                                autoFocus 
                                placeholder="Set in: MM:SS / SS"                                className="bg-slate-900/70 border border-slate-600 text-slate-200 text-sm rounded-md p-1 flex-1 min-w-0"/>
                            <Tooltip text="Set reminder from input">
                                <button onClick={handleSetReminder} className="px-3 py-1 bg-sky-600 text-white text-sm rounded-md hover:bg-sky-500">Set</button>
                            </Tooltip>
                        </div>
                    )}
                    {task.reminderAt && !isSettingReminder && (
                        <div className="mt-2 text-xs">
                            <div className="text-sky-300 flex justify-between items-center mb-0.5">
                                <span>
                                    Set for: {new Date(task.reminderAt).toLocaleTimeString([], {
                                        timeZone: TIMEZONE_MAP[clockTimezone] || 'UTC', // Fallback to UTC if map fails
                                        hour: '2-digit', minute:'2-digit', second: '2-digit'
                                    })} {clockTimezone}
                                </span>
                                <Tooltip text="Clear reminder">
                                    <button onClick={() => updateTask(task.id, { reminderAt: null, reminderFired: false })} className="text-red-400 hover:text-red-300 text-xs">(clear)</button>
                                </Tooltip>
                            </div>
                            <ReminderCountdown reminderAt={task.reminderAt} />
                        </div>
                    )}
                    <div className="mt-3 pt-2 border-t border-slate-700 flex justify-between items-center">
                        <div className="flex items-center space-x-2">
                            {!task.archived && task.status === TASK_STATUS.TO_DO && !task.totalElapsedTimeInSeconds && (
                                <Tooltip text="Start working on this task">
                                    <button onClick={statusActions[TASK_STATUS.TO_DO]} className="px-3 py-1 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-500 text-sm">Start Task</button>
                                </Tooltip>
                            )}
                            {(task.status !== TASK_STATUS.TO_DO || task.totalElapsedTimeInSeconds > 0) && <TimeElapsed startTime={task.startedAt} totalElapsedSeconds={task.totalElapsedTimeInSeconds || 0} />}
                            {!task.archived && task.status === TASK_STATUS.IN_PROGRESS && task.startedAt && (
                                <Tooltip text="Pause task timer">
                                    <button onClick={statusActions[TASK_STATUS.IN_PROGRESS]} className="px-2 py-1 bg-amber-600 text-white text-xs rounded-md hover:bg-amber-500">Pause</button>
                                </Tooltip>
                            )}
                            {!task.archived && (task.status === TASK_STATUS.ON_HOLD || (task.status === TASK_STATUS.TO_DO && task.totalElapsedTimeInSeconds > 0)) && (
                                <Tooltip text="Resume working on this task">
                                    <button onClick={statusActions[TASK_STATUS.ON_HOLD]} className="px-2 py-1 bg-green-600 text-white text-xs rounded-md hover:bg-green-500">Resume</button>
                                </Tooltip>
                            )}
                        </div>
                        <div className="flex items-center space-x-2">
                            <Tooltip text={isSettingReminder ? "Cancel reminder setup" : "Set Reminder"}>
                                <button onClick={() => setIsSettingReminder(!isSettingReminder)} disabled={task.archived} className="text-slate-400 hover:text-white transition-colors p-1 rounded-full hover:bg-slate-700 disabled:opacity-50"><BellIcon /></button>
                            </Tooltip>
                            <Tooltip text={task.archived ? "Restore" : "Archive"}><button onClick={() => archiveTask(task.id, !task.archived)} className="text-slate-400 hover:text-white transition-colors p-1 rounded-full hover:bg-slate-700">{task.archived ? <RestoreIcon /> : <ArchiveIcon />}</button></Tooltip>
                            <Tooltip text="Delete Permanently"><button onClick={handleDeleteRequest} className="text-red-400 hover:text-white transition-colors p-1 rounded-full hover:bg-red-500"><DeleteIcon /></button></Tooltip>
                        </div>
                    </div>
                </div>
            </div>
        );
    };
    const MemoizedTaskCard = React.memo(TaskCard);


    // --- Main Presentation Component ---
    const App = () => {
        const { 
            tasks, addTask, archiveTask, 
            settings, setSettings, 
            taskToClose, setTaskToClose, 
            taskToUnarchive, setTaskToUnarchive, 
            taskToDelete, setTaskToDelete, 
            allTags, deleteTask, updateTask, clearArchive, // Core data functions
            activeTags, setActiveTags,                     // Filter state
            activeSwimlanes, setActiveSwimlanes,           // Swimlane visibility state
            collapsedTagSwimlanes, toggleSwimlaneCollapse, // Swimlane collapse state & toggle fn
            collapsedColumns, setCollapsedColumns          // Fixed column collapse state & setter
        } = useAppContext();



        const now = useNow(); // Get current time, updates every second

        const [showArchived, setShowArchived] = useState(false);
        // const [collapsedColumns, setCollapsedColumns] = useState({ 'new-tasks': false }); // MOVED to AppProvider
        const [showSettings, setShowSettings] = useState(false);
        // const [collapsedTagSwimlanes, setCollapsedTagSwimlanes] = useState({}); // Moved to AppProvider
        const [clockTimezone, setClockTimezone] = useState('EST');
        const [showSwimlaneModal, setShowSwimlaneModal] = useState(false);
        
        const [draggedSwimlane, setDraggedSwimlane] = useState(null); // For swimlane reordering

        // State for the main "Add Task" input in the header
        const [showMainAddTaskInput, setShowMainAddTaskInput] = useState(false);
        const [showClearArchiveConfirm, setShowClearArchiveConfirm] = useState(false);

        const currentTasks = useMemo(() => showArchived ? tasks.filter(t => t.archived) : tasks.filter(t => !t.archived), [tasks, showArchived]);
        
        const prevTasks = usePrevious(currentTasks);

        useEffect(() => {
            // Ensure that when the view switches between active and archived,
            // or when tasks are modified, the counts for filters are based on the currently displayed tasks.
            // The `currentTasks` variable already reflects this.
        }, [currentTasks]);

        const allTasksCount = useMemo(() => currentTasks.length, [currentTasks]);

        const priorityFilterCounts = useMemo(() => {
            const counts = {};
            DISPLAY_PRIORITY_ORDER.forEach(priorityConstant => {
                const displayTitle = PRIORITY_CONFIG[priorityConstant].title;
                counts[displayTitle] = currentTasks.filter(task => task.priority === priorityConstant).length;
            });
            return counts;
        }, [currentTasks]); // DISPLAY_PRIORITY_ORDER and PRIORITY_CONFIG are stable constants

        const customTagFilterCounts = useMemo(() => {
            const counts = {};
            const customTagsToDisplay = allTags.filter(tag => !PRIORITY_DISPLAY_TITLES_ARRAY.includes(tag));
            customTagsToDisplay.forEach(tag => {
                counts[tag] = currentTasks.filter(task => task.tags && task.tags.includes(tag)).length;
            });
            return counts;
        }, [currentTasks, allTags]); // PRIORITY_DISPLAY_TITLES_ARRAY is a stable constant

        useEffect(() => {
            if (!prevTasks || !currentTasks) return;
            currentTasks.forEach(task => {
                const prevTask = prevTasks.find(pt => pt.id === task.id);
                if (prevTask && prevTask.status !== TASK_STATUS.DONE && task.status === TASK_STATUS.DONE && !task.archived) {
                    setTaskToClose(task);
                }
            });
        }, [currentTasks, prevTasks, setTaskToClose]);

        // --- Effect for Reminder Notifications ---
        useEffect(() => {
            if (!('Notification' in window) || Notification.permission !== 'granted') {
                return; // Notifications not supported or permission not granted
            }

            tasks.forEach(task => {
                if (task.reminderAt && !task.reminderFired && !task.archived && new Date(task.reminderAt) <= now) {
                    // console.log(`Firing reminder for task: ${task.title}`); // For debugging
                    new Notification('Taiko Task Reminder', {
                        body: `Reminder for: ${task.title}`,
                        // icon: 'your_icon.png' // Optional: Add an icon URL here
                    });
                    updateTask(task.id, { reminderFired: true });

                    // Play sound based on priority
                    switch (task.priority) {
                        case PRIORITIES.HIGH:
                            playTone(880, 0.6, 'sawtooth', 0.4); // Higher pitch, slightly harsher, louder
                            setTimeout(() => playTone(880, 0.3, 'sawtooth', 0.4), 150); // Quick second beep
                            break;
                        case PRIORITIES.MEDIUM:
                            playTone(660, 0.8, 'square', 0.35); // Medium pitch
                            break;
                        case PRIORITIES.LOW:
                            playTone(440, 1.0, 'sine', 0.3); // Lower pitch, softer
                            break;
                        default: // Unprioritized or null
                            playTone(523, 0.7, 'sine', 0.25); // A general C5 note
                    }
                }
            });
        }, [tasks, now, updateTask]);

        const handleConfirmDelete = useCallback(() => {
            if (!taskToDelete) return;
            deleteTask(taskToDelete);
            setTaskToDelete(null);
        }, [taskToDelete, deleteTask]);

        const handleConfirmClearArchive = useCallback(() => { clearArchive(); setShowClearArchiveConfirm(false); }, [clearArchive]);


        const handleAddTask = () => { 
            setShowMainAddTaskInput(true); // Show the input form instead of adding directly
        };
        const handleConfirmCloseout = (id) => { archiveTask(id, true); setTaskToClose(null); };
        const handleConfirmUnarchive = (id) => { archiveTask(id, false); setTaskToUnarchive(null); };
        const handleTimezoneChange = () => setClockTimezone(p => TIMEZONE_ORDER[(TIMEZONE_ORDER.indexOf(p) + 1) % TIMEZONE_ORDER.length]);
        
        const handleArchiveClick = () => {
            const newArchiveState = !showArchived;
            setShowArchived(newArchiveState);
        };

        // Effect to remove swimlanes if their tags are no longer in allTags (e.g., all tasks with that tag were archived)
        // Or if a priority swimlane's corresponding priority tag is removed from allTags
        useEffect(() => {
            setActiveSwimlanes(currentActiveSwimlanes =>
                currentActiveSwimlanes.filter(swimlaneName => {
                    const isPrioritySwimlane = PRIORITY_TITLE_TO_CONSTANT_MAP[swimlaneName];
                    // Keep if it's a priority swimlane OR if it's a custom tag present in allTags
                    return isPrioritySwimlane || allTags.includes(swimlaneName);
                })
            );
        }, [allTags, setActiveSwimlanes, PRIORITY_TITLE_TO_CONSTANT_MAP]); // PRIORITY_TITLE_TO_CONSTANT_MAP is stable
        
        // Effect to automatically hide empty swimlanes if autoCollapse is enabled
        useEffect(() => {
            if (settings.autoCollapse) {
                // Use the functional update form of setActiveSwimlanes
                // to get the latest activeSwimlanes without adding it to dependencies,
                // and to conditionally update only if changes are needed.
                setActiveSwimlanes(currentActiveSwimlanes => {
                    const emptyActiveSwimlanesInThisRun = currentActiveSwimlanes.filter(swimlaneName => {
                        const tasksInSwimlane = swimlaneTasks[swimlaneName] || []; // swimlaneTasks is from the outer scope, captured at effect run time
                        return tasksInSwimlane.length === 0;
                    });

                    if (emptyActiveSwimlanesInThisRun.length > 0) {
                        const nextActiveSwimlanes = currentActiveSwimlanes.filter(name => !emptyActiveSwimlanesInThisRun.includes(name));
                        // Only return a new array if it's actually different to prevent unnecessary re-renders/loops
                        if (nextActiveSwimlanes.length !== currentActiveSwimlanes.length) {
                            return nextActiveSwimlanes;
                        }
                    }
                    return currentActiveSwimlanes; // No change needed
                });
            }
        }, [swimlaneTasks, settings.autoCollapse, setActiveSwimlanes]); // Dependencies: swimlaneTasks, autoCollapse setting, and the stable setter.

        const handleTagFilterClick = (tag) => {
            const isPriorityTag = PRIORITY_TITLE_TO_CONSTANT_MAP[tag]; // Will be truthy (the constant string) if 'tag' is a priority display title

            setActiveTags(prevActiveTags => {
                if (isPriorityTag) {
                    // It's a priority filter
                    if (prevActiveTags.includes(tag)) {
                        // Clicked an active priority filter: deactivate it
                        return prevActiveTags.filter(t => t !== tag);
                    } else {
                        // Clicked an inactive priority filter:
                        // 1. Remove all other active priority filters
                        const nonPriorityFilters = prevActiveTags.filter(t => !PRIORITY_TITLE_TO_CONSTANT_MAP[t]);
                        // 2. Add the newly clicked priority filter
                        return [...nonPriorityFilters, tag];
                    }
                } else {
                    // It's a custom tag filter: toggle normally
                    if (prevActiveTags.includes(tag)) {
                        return prevActiveTags.filter(t => t !== tag);
                    } else {
                        return [...prevActiveTags, tag];
                    }
                }
            });
        };

        const clearTagFilter = () => setActiveTags([]);

        // --- Swimlane Drag and Drop Handlers ---
        const handleDragStartSwimlane = (e, swimlaneName) => {
            setDraggedSwimlane(swimlaneName);
            e.dataTransfer.effectAllowed = 'move';
            // Optional: Add a class to the body or a specific element for global drag styling
        };

        const handleDragOverSwimlane = (e) => {
            e.preventDefault(); // Necessary to allow dropping
        };

        const handleDropSwimlane = (targetSwimlaneName) => {
            if (!draggedSwimlane || draggedSwimlane === targetSwimlaneName) {
                setDraggedSwimlane(null);
                return;
            }
            const newActiveSwimlanes = [...activeSwimlanes];
            const draggedIndex = newActiveSwimlanes.indexOf(draggedSwimlane);
            const targetIndex = newActiveSwimlanes.indexOf(targetSwimlaneName);

            newActiveSwimlanes.splice(draggedIndex, 1); // Remove dragged item
            newActiveSwimlanes.splice(targetIndex, 0, draggedSwimlane); // Insert at new position
            setActiveSwimlanes(newActiveSwimlanes);
            setDraggedSwimlane(null);
        };

        const filteredTasksByTagsAndPriority = useMemo(() => {
            if (activeTags.length === 0) return currentTasks;
            return currentTasks.filter(task =>
                activeTags.every(activeTag => {
                    const priorityConstant = PRIORITY_TITLE_TO_CONSTANT_MAP[activeTag];
                    return priorityConstant ? task.priority === priorityConstant : (task.tags && task.tags.includes(activeTag));
                }) // Closes 'every'
            ); // Closes 'filter'
        }, [currentTasks, activeTags]); // Added closing brace for useMemo callback and dependency array

        const { swimlaneTasks, unclassifiedTasks } = useMemo(() => { // Renamed priorityTasks to unclassifiedTasks
            const st = {};
            const ut = []; // unclassifiedTasks

            const taskSorter = (a, b) => {
                const priorityA = getPrioritySortValue(a.priority);
                const priorityB = getPrioritySortValue(b.priority);
                if (priorityA !== priorityB) {
                    return priorityA - priorityB;
                }
                // Secondary sort: rank for active, timestamp for archived
                if (showArchived) {
                    return new Date(b.timestamp) - new Date(a.timestamp); // Newest archived first
                } else {
                    // Lower rank first. Tasks with null/undefined rank go to the bottom of their priority group.
                    return (a.rank ?? Infinity) - (b.rank ?? Infinity); 
                }
            };

            for (const task of filteredTasksByTagsAndPriority) {
                let inSwimlane = false;
                
                for (const swimlaneName of activeSwimlanes) { 
                    const isPrioritySwimlane = PRIORITY_TITLE_TO_CONSTANT_MAP[swimlaneName];
                    let matchesSwimlane = false;

                    if (isPrioritySwimlane) {
                        matchesSwimlane = task.priority === PRIORITY_TITLE_TO_CONSTANT_MAP[swimlaneName];
                    } else {
                        matchesSwimlane = task.tags && task.tags.includes(swimlaneName);
                    }

                    if (matchesSwimlane) {
                        if (!st[swimlaneName]) st[swimlaneName] = [];
                        st[swimlaneName].push(task);
                        inSwimlane = true;
                        break; // Task assigned, move to the next task
                    }
                }

                if (!inSwimlane) {
                    ut.push(task);
                }
            }

            // Sort unclassified tasks
            ut.sort(taskSorter);

            // Sort tasks within each swimlane
            for (const swimlaneName in st) {
                st[swimlaneName].sort(taskSorter);
            }
            return { swimlaneTasks: st, unclassifiedTasks: ut }; 
        }, [filteredTasksByTagsAndPriority, activeSwimlanes, showArchived, PRIORITY_TITLE_TO_CONSTANT_MAP]); // Added showArchived and PRIORITY_TITLE_TO_CONSTANT_MAP

        const mainLayoutClasses = settings.verticalLayout ? 'flex-col space-y-4' : 'flex-row space-x-4';
        const backgroundOverlayClass = showArchived ? 'bg-red-900/10' : '';
        
        return (
            <div className="h-screen w-screen font-sans flex flex-col overflow-x-hidden" style={{ background: `radial-gradient(circle, rgba(15, 23, 42, 0.9), rgba(10, 15, 30, 1)), linear-gradient(135deg, #0f172a 0%, #1e293b 100%)` }}>
                
                {taskToClose && <CloseoutModal task={taskToClose} onConfirm={handleConfirmCloseout} onCancel={() => setTaskToClose(null)} />}
                {taskToUnarchive && <UnarchiveModal task={taskToUnarchive} onConfirm={handleConfirmUnarchive} onCancel={() => setTaskToUnarchive(null)} />}
                {taskToDelete && <DeleteConfirmationModal onConfirm={handleConfirmDelete} onCancel={() => setTaskToDelete(null)} />}
                {showSettings && <SettingsModal settings={settings} onSettingsChange={setSettings} onClose={() => setShowSettings(false)} />}                {showClearArchiveConfirm && <ClearArchiveConfirmationModal onConfirm={handleConfirmClearArchive} onCancel={() => setShowClearArchiveConfirm(false)} />}
                {showSwimlaneModal && <ManageSwimlanesModal allTags={allTags} activeSwimlanes={activeSwimlanes} setSwimlanes={setActiveSwimlanes} onClose={() => setShowSwimlaneModal(false)} />}

                <header className="sticky top-0 z-10 p-4 bg-slate-900/70 backdrop-blur-md shadow-lg flex justify-between items-center flex-shrink-0 flex-wrap">
                    <div className="flex items-center space-x-4">
                        <TaikoLogo />
                        <div>
                            <h1 className="text-3xl font-bold" style={{ color: '#E0E7FF', textTransform: 'uppercase', letterSpacing: '0.2em' }}>Taiko</h1> {/* Removed paddingLeft for alignment */}
                            <p className="text-slate-400 text-sm">Operations Task Master</p>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center min-w-[300px] my-2 md:my-0"><LiveClock timezone={clockTimezone} onTimezoneChange={handleTimezoneChange} /></div>
                    <div className="flex items-center space-x-4">
                        <Tooltip text="Settings">
                            <button onClick={() => setShowSettings(true)} className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><SettingsIcon /></button>
                        </Tooltip>
                        <Tooltip text="Report Issue or Submit Feedback">
                            <a 
                                href="https://github.com/closedloopchaos/taiko/issues/new/choose" 
                                target="_blank" 
                                rel="noopener noreferrer"
                                className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"
                            >
                                <BugIcon />
                            </a>
                        </Tooltip>
                        <Tooltip text={showArchived ? "View Active Tasks" : "View Archived Tasks (A)"}>
                            <button onClick={handleArchiveClick} className={`px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:bg-slate-600 focus:outline-none focus:ring-2 focus:ring-slate-500 transition-all ${showArchived ? 'bg-red-600 hover:bg-red-500 focus:ring-red-400' : 'bg-slate-700'}`}>{showArchived ? 'View Active' : 'View Archived'}</button>
                        </Tooltip>
                        {showArchived && (
                            <Tooltip text="Permanently delete all archived tasks">
                                <button onClick={() => setShowClearArchiveConfirm(true)} className="px-4 py-2 bg-red-700 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 transition-all">Clear Archive</button>
                            </Tooltip>
                        )}
                        {/* Conditionally render the button or the quick add input */}
                        {showMainAddTaskInput ? (
                             <QuickAddInputForm 
                                onAdd={(title) => { addTask(title); setShowMainAddTaskInput(false); }} 
                                onCancel={() => setShowMainAddTaskInput(false)}
                            />
                        ) : (
                            <AddTaskButton onAddTask={handleAddTask} />
                        )}
                    </div>
                </header>
                
                <div className="px-6 py-2 flex-shrink-0 border-b border-slate-800 flex justify-between items-center flex-wrap gap-2">
                    <div className="flex items-center space-x-2 flex-wrap">
                        <Tooltip text="Show all tasks (clear tag filters)">
                            <button onClick={clearTagFilter} // This button clears all activeTags, including priority titles
                                    className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${activeTags.length === 0 ? 'bg-sky-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>
                                    All
                                    <span className="opacity-80"> ({allTasksCount})</span>                            </button>
                        </Tooltip>
                        {/* Render Priority Filter Buttons First in Specific Order */}
                        {DISPLAY_PRIORITY_ORDER.map(priorityConstant => {
                            const displayTitle = PRIORITY_CONFIG[priorityConstant].title;
                            return (
                                <Tooltip key={displayTitle} text={`Filter by priority: ${displayTitle}`}>
                                    <button 
                                        onClick={() => handleTagFilterClick(displayTitle)}
                                        className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${activeTags.includes(displayTitle) ? `${PRIORITY_CONFIG[priorityConstant].bgColor} text-white` : 'text-slate-400 hover:bg-slate-700/50'}`}
                                    >
                                        {displayTitle} <span className="opacity-80">({priorityFilterCounts[displayTitle] || 0})</span>
                                    </button>
                                </Tooltip>
                            );
                        })}
                        {/* Render Other Tag Filters (excluding priority display titles) */}
                        {allTags.map(tag => ( // allTags is now already filtered to be custom tags only
                            <Tooltip key={tag} text={`Filter by custom tag: ${tag}`}>
                                <button onClick={() => handleTagFilterClick(tag)}
                                    className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${activeTags.includes(tag) ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>
                                    {tag}
                                    <span className="opacity-80"> ({customTagFilterCounts[tag] || 0})</span>                                </button>
                            </Tooltip>
                        ))}
                    </div>
                    <Tooltip text="Configure custom tag-based swimlane columns">
                        <button onClick={() => setShowSwimlaneModal(true)} className="text-sm text-slate-400 hover:text-white bg-slate-700/50 px-3 py-1 rounded-md">Manage Swimlanes</button>
                    </Tooltip>
                </div>

                <main className={`flex-grow p-4 pt-4 flex overflow-auto transition-all duration-300 ${mainLayoutClasses} ${backgroundOverlayClass}`}>
                    {/* --- "New Tasks" Column (replaces Triage) --- */}
                    {(() => { // This column displays unclassifiedTasks
                        const unsortedTasksToDisplay = unclassifiedTasks;
                        const isEffectivelyCollapsedUnsorted = (settings.autoCollapse && unsortedTasksToDisplay.length === 0) ? true : (collapsedColumns['unsorted'] || false);
                        
                        // Render if tasks exist, OR if no filters are active and it's not effectively collapsed
                        const shouldRenderUnsortedColumn = unsortedTasksToDisplay.length > 0 || (activeTags.length === 0 && !isEffectivelyCollapsedUnsorted);

                        if (shouldRenderUnsortedColumn) {
                            return (
                                <PriorityColumn
                                    key="unsorted-column"
                                    titleOverride="Unsorted" // Updated title
                                    priority={null} // Base styling on unprioritized, but title is overridden
                                    tasks={unsortedTasksToDisplay}
                                    isCollapsed={isEffectivelyCollapsedUnsorted}
                                    onToggleCollapse={() => setCollapsedColumns(p => ({ ...p, 'unsorted': !p['unsorted'] }))}
                                    showArchived={showArchived}
                                    isVerticalLayout={settings.verticalLayout}
                                    clockTimezone={clockTimezone}
                                    isSwimlane={false} // Indicate this is a primary column
                                /> );
                        } return null;
                    })()}
                    {activeSwimlanes.map(item => { // Iterate over all active swimlanes (tags or priority display titles)
                        const tasksForThisSwimlane = swimlaneTasks[item] || [];
                        const isManuallyCollapsed = collapsedTagSwimlanes[item] || false;
                        const isEffectivelyCollapsedTag = (settings.autoCollapse && tasksForThisSwimlane.length === 0) ? true : isManuallyCollapsed;

                        // Render if tasks exist, OR if no filters are active and it's not effectively collapsed
                        const shouldRenderTagColumn = tasksForThisSwimlane.length > 0 || (activeTags.length === 0 && !isEffectivelyCollapsedTag);

                        if (!shouldRenderTagColumn) {
                            return null; // Hide the column if filters make it empty, or if no filters and it's effectively collapsed
                        }

                        // All active swimlanes (including those named "High", "Medium", "Low")
                        // will now be rendered by TagColumn.
                        // The "Unsorted" column is handled separately above.
                        return (
                            <div
                                key={item}
                                draggable={!settings.verticalLayout} // Only allow drag in horizontal mode for now
                                onDragStart={(e) => !settings.verticalLayout && handleDragStartSwimlane(e, item)}
                                onDragOver={!settings.verticalLayout ? handleDragOverSwimlane : undefined}
                                onDrop={() => !settings.verticalLayout && handleDropSwimlane(item)}
                                className={`transition-opacity duration-200 ${draggedSwimlane === item ? 'opacity-30' : 'opacity-100'} ${settings.verticalLayout ? 'w-full' : 'flex-1 min-w-0'}`}
                            >
                                <TagColumn 
                                    tag={item} // 'item' is the swimlane name, e.g., "ProjectX" or "High"
                                    tasks={tasksForThisSwimlane} 
                                    clockTimezone={clockTimezone}
                                    isCollapsed={isEffectivelyCollapsedTag}
                                    onToggleCollapse={() => toggleSwimlaneCollapse(item)}
                                    isVerticalLayout={settings.verticalLayout}
                                    isBeingDragged={draggedSwimlane === item}
                                />
                            </div>
                        );
                    })}                    
                    {/* Default Priority Columns are removed. They are now handled as selectable swimlanes if their tags exist. */}
                </main>
            </div>
        );
    };

    // --- Column & Modal Components ---
    const PriorityColumn = React.memo(({ priority, tasks, isCollapsed, onToggleCollapse, showArchived, isVerticalLayout, clockTimezone, isSwimlane = false, titleOverride = null }) => {
        const { addTask } = useAppContext();
        const [showQuickAdd, setShowQuickAdd] = useState(false); // State to show/hide quick add input

        const columnLayoutClasses = isVerticalLayout ? 'w-full h-auto' : 'flex-1 min-w-0 h-full';
        const config = PRIORITY_CONFIG[priority] || PRIORITY_CONFIG.null; // 'priority' can be PRIORITIES.LOW or null

        let displayTitleText = titleOverride || config.title;
        if (isSwimlane && !titleOverride && config.title !== PRIORITY_CONFIG.null.title) {
            displayTitleText = `${config.title} Priority`;
        } // "Unsorted" will use titleOverride

        const headerColorClass = titleOverride ? (isSwimlane ? 'text-slate-300' : 'text-slate-200') : config.color; // Generic color for "New Tasks", specific for priorities


        const headerContent = (
            <>
                <span className="truncate">{displayTitleText} ({tasks.length})</span>
                {isVerticalLayout && ( // Only show chevron in vertical mode
                    <ChevronDownIcon className={`transform transition-transform duration-200 ${isCollapsed ? '-rotate-90' : 'rotate-0'}`} />
                )}
            </>
        );
        
        const handleQuickAddTask = (titleFromInput) => {
            if (!titleFromInput.trim()) { setShowQuickAdd(false); return; }

            let taskPriorityToAdd = null;
            let taskTagsToAdd = []; // Default for "Unsorted" or priority columns

            if (titleOverride) { // "New Tasks" column
                taskPriorityToAdd = null;
                taskTagsToAdd = [];
            } else if (priority) { // Priority swimlane
                taskPriorityToAdd = priority; // The actual priority constant like PRIORITIES.LOW
                taskTagsToAdd = []; // DO NOT add the priority display title to tags array
            }
            
            addTask(titleFromInput.trim(), taskPriorityToAdd, taskTagsToAdd);
            setShowQuickAdd(false);
        };


        return (
            <div className={`flex flex-col rounded-lg ${columnLayoutClasses} ${isSwimlane ? 'bg-slate-900/40 border border-slate-700/60' : (titleOverride ? 'bg-slate-800/50 border border-slate-700/50' : 'bg-slate-900/30')}`}>
                {isVerticalLayout ? ( // Clickable header for vertical layout
                    <Tooltip text={isCollapsed ? "Expand column" : "Collapse column"}>
                        <button 
                            onClick={onToggleCollapse} 
                            className={`flex items-center w-full text-left text-lg font-bold p-2 rounded-t-lg ${headerColorClass} ${isSwimlane ? 'bg-slate-800/70 hover:bg-slate-700/70' : (titleOverride ? 'bg-slate-700/60 hover:bg-slate-600/60' : 'hover:bg-slate-700/50')} flex-shrink-0 transition-colors`}
                        >
                            <div className="flex-grow min-w-0">{headerContent}</div>
                            {!isCollapsed && !showQuickAdd && (
                                <Tooltip text={`Quick add to ${displayTitleText}`}>
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); setShowQuickAdd(true); }} 
                                        className="ml-2 p-1 rounded-full hover:bg-slate-600/50 flex-shrink-0"
                                    >
                                        <PlusIcon />
                                    </button>
                                </Tooltip>
                            )}
                        </button>
                    </Tooltip>
                ) : ( // Static header for horizontal layout
                    <div className={`flex items-center w-full text-left text-lg font-bold p-2 rounded-t-lg ${headerColorClass} ${isSwimlane ? 'bg-slate-800/70' : (titleOverride ? 'bg-slate-700/60' : 'bg-slate-900/60')} flex-shrink-0`}>
                        <div className="flex-grow min-w-0">{headerContent}</div>
                        {!showQuickAdd && (
                             <Tooltip text={`Quick add to ${displayTitleText}`}>
                                <button 
                                    onClick={() => setShowQuickAdd(true)} 
                                    className="ml-2 p-1 rounded-full hover:bg-slate-600/50 flex-shrink-0"
                                >
                                    <PlusIcon />
                                </button>
                            </Tooltip>
                        )}
                    </div>
                )}
                {showQuickAdd && !isCollapsed && (
                    <QuickAddInputForm onAdd={handleQuickAddTask} onCancel={() => setShowQuickAdd(false)} />
                )}
                <div className={`
                    flex-grow p-2 transition-all duration-300 ease-in-out overflow-x-hidden
                    ${isVerticalLayout ? 
                        (isCollapsed ? 'max-h-0 py-0 opacity-0' : 'opacity-100') :
                        'max-h-full opacity-100 overflow-y-auto'
                    }
                `}>
                    {tasks.map((task) => (
                        <div key={task.id} className={`w-full min-w-0 transition-opacity duration-300 ${(!showArchived && task.status === TASK_STATUS.DONE) ? 'opacity-20' : 'opacity-100'}`}>
                            <MemoizedTaskCard task={task} clockTimezone={clockTimezone} />
                        </div>
                    ))}
                </div>
            </div>
        );
    });

    const TagColumn = React.memo(({ tag, tasks, clockTimezone, isCollapsed, onToggleCollapse, isVerticalLayout, isBeingDragged }) => {
        const { addTask } = useAppContext();
        const [showQuickAdd, setShowQuickAdd] = useState(false); // State to show/hide quick add input

        const columnLayoutClasses = isVerticalLayout ? 'w-full h-auto' : 'flex-1 min-w-0 h-full';
        const dragStyle = isBeingDragged ? 'border-dashed border-sky-500' : 'border-indigo-800/50';

        const headerContent = (
            <>
                <span className="truncate">{tag} ({tasks.length})</span>
                {isVerticalLayout && <ChevronDownIcon className={`transform transition-transform duration-200 ${isCollapsed ? '-rotate-90' : 'rotate-0'}`} />} {/* Chevron only in vertical layout */}
            </>
        );

        const handleQuickAddTask = (titleFromInput) => {
            if (!titleFromInput.trim()) { setShowQuickAdd(false); return; }

            const priorityConstant = PRIORITY_TITLE_TO_CONSTANT_MAP[tag];

            if (priorityConstant) {
                addTask(titleFromInput.trim(), priorityConstant, []); // Set priority, no tags
            } else {
                addTask(titleFromInput.trim(), null, [tag]); // Null priority, add custom tag
            }
            setShowQuickAdd(false);
        };

        return (
            <div className={`flex flex-col bg-indigo-900/20 backdrop-blur-sm border rounded-lg ${columnLayoutClasses} ${dragStyle} transition-all`}>
                {isVerticalLayout ? ( // Clickable header for vertical layout
                    <Tooltip text={isCollapsed ? "Expand column" : "Collapse column"}>
                        <button
                            onClick={onToggleCollapse}
                            className={`flex items-center w-full text-left text-lg font-bold p-2 rounded-t-lg text-indigo-300 bg-slate-900/60 hover:bg-slate-800/80 flex-shrink-0 transition-colors ${isBeingDragged ? 'cursor-grabbing' : 'cursor-pointer'}`}
                        >
                            <div className="flex-grow min-w-0">{headerContent}</div>
                            {!isCollapsed && !showQuickAdd && (
                                <Tooltip text={`Quick add to ${tag}`}>
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); setShowQuickAdd(true); }} 
                                        className="ml-2 p-1 rounded-full hover:bg-slate-800/50 flex-shrink-0"
                                    >
                                        <PlusIcon />
                                    </button>
                                </Tooltip>
                            )}
                        </button>
                    </Tooltip>
                ) : (
                    <div className={`flex justify-between items-center w-full text-left text-lg font-bold p-2 rounded-t-lg text-indigo-300 bg-slate-900/60 flex-shrink-0 ${isBeingDragged ? 'cursor-grabbing' : 'cursor-grab'}`}>
                        <div className="flex-grow min-w-0">{headerContent}</div>
                         {!showQuickAdd && (
                            <Tooltip text={`Quick add to ${tag}`}>
                                <button 
                                    onClick={() => setShowQuickAdd(true)} 
                                    className="ml-2 p-1 rounded-full hover:bg-slate-800/50 flex-shrink-0"
                                >
                                    <PlusIcon />
                                </button>
                            </Tooltip>
                        )}
                    </div>
                )}
                {showQuickAdd && !isCollapsed && (
                    <QuickAddInputForm onAdd={handleQuickAddTask} onCancel={() => setShowQuickAdd(false)} />
                )}
                <div className={`
                    flex-grow p-2 overflow-x-hidden transition-all duration-300 ease-in-out
                    ${isVerticalLayout ?
                        (isCollapsed ? 'max-h-0 py-0 opacity-0' : 'opacity-100') :
                        'max-h-full opacity-100 overflow-y-auto'
                    }
                `}>
                    {tasks.map(task => ( 
                        <div key={task.id} className="w-full min-w-0">
                            <MemoizedTaskCard task={task} clockTimezone={clockTimezone} />
                        </div>
                    ))}
                </div>
            </div>
        );
    });

    const QuickAddInputForm = React.memo(({ onAdd, onCancel, placeholder = "New task title..." }) => {
        const [internalValue, setInternalValue] = useState('');
        const inputRef = useRef(null);

        useEffect(() => {
            if (inputRef.current) inputRef.current.focus();
        }, []);

        const handleSubmit = () => {
            const trimmedValue = internalValue.trim();
            if (trimmedValue) {
                onAdd(trimmedValue);
                setInternalValue(''); // Reset for next potential use if not hidden immediately
            } else {
                // If input is empty and Enter/Add is pressed, effectively cancel.
                onCancel();
            }
        };

        return (
            <div className="p-2 border-b border-slate-700/50 bg-slate-800/30">
                <input
                    ref={inputRef}
                    type="text"
                    value={internalValue}
                    onChange={e => setInternalValue(e.target.value)}
                    onKeyDown={e => { if (e.key === 'Enter') handleSubmit(); if (e.key === 'Escape') onCancel(); }}
                    placeholder={placeholder}
                    className="w-full bg-slate-900/80 text-slate-200 text-sm p-2 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500"
                />
                <div className="mt-2 flex justify-end space-x-2">
                    <button onClick={onCancel} className="px-3 py-1 text-xs bg-slate-600 hover:bg-slate-500 rounded-md">Cancel</button>
                    <button onClick={handleSubmit} className="px-3 py-1 text-xs bg-sky-600 hover:bg-sky-500 rounded-md">Add Task</button>
                </div>
            </div>
        );
    });

    const AddTaskButton = React.memo(({ onAddTask }) => {
        return (
            <div className="relative">
                <Tooltip text="Add a new task">
                    <button 
                        onClick={onAddTask} 
                        className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg shadow-md hover:bg-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-opacity-75 transition-all"
                    >
                        + Add Task
                    </button>
                </Tooltip>
            </div>
        );
    });

    const Modal = ({ children, onClose }) => <div onClick={onClose} className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4">{children}</div>;
    const ModalContent = ({ title, children, onClose, headerActions }) => (
        <div 
            className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-md text-white flex flex-col" // Removed max-h-[85vh]
            onClick={e => e.stopPropagation()}
        >
            <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                <h3 className="text-xl font-bold">{title}</h3>
                {headerActions && <div>{headerActions}</div>}
            </div>
            <div className="px-3 py-4">{children}</div> {/* Adjusted padding: px-3 py-4. Removed overflow-y-auto and flex-grow */}
        </div>
    );
    const CloseoutModal = ({ task, onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Task Complete!</h3><p className="text-slate-300 mb-4">Would you like to archive the task "{task.title}"?</p><div className="flex justify-center space-x-4"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Keep Active</button><button onClick={() => onConfirm(task.id)} className="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-500">Archive Task</button></div></div></Modal>;
    const UnarchiveModal = ({ task, onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Unarchive Task?</h3><p className="text-slate-300 mb-4">You've made a change to an archived task. Would you like to move "{task.title}" back to the active board?</p><div className="flex justify-center space-x-4"><Tooltip text="Keep the task archived"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">No, Keep Archived</button></Tooltip><Tooltip text="Move task to active board"><button onClick={() => onConfirm(task.id)} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500">Yes, Unarchive</button></Tooltip></div></div></Modal>;
    const DeleteConfirmationModal = ({ onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Delete Task?</h3><p className="text-slate-300 mb-4">Are you sure you want to permanently delete this task?</p><div className="flex justify-center space-x-4"><Tooltip text="Cancel deletion"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button></Tooltip><Tooltip text="Confirm permanent deletion"><button onClick={onConfirm} className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-500">Delete</button></Tooltip></div></div></Modal>;
    const ClearArchiveConfirmationModal = ({ onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-md text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-red-400 mb-2">Clear Entire Archive?</h3><p className="text-slate-300 mb-1">Are you sure you want to permanently delete <strong className="text-red-300">ALL</strong> archived tasks?</p><p className="text-slate-400 text-sm mb-4">This action cannot be undone.</p><div className="flex justify-center space-x-4"><Tooltip text="Cancel operation"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button></Tooltip><Tooltip text="Confirm deletion of all archived tasks"><button onClick={onConfirm} className="px-4 py-2 bg-red-700 text-white font-semibold rounded-lg hover:bg-red-600">Yes, Delete All Archived</button></Tooltip></div></div></Modal>;
    const SettingsModal = ({ settings, onSettingsChange, onClose }) => { 
        const handleToggle = (key) => onSettingsChange(p => ({ ...p, [key]: !p[key] })); 
        return ( 
            <Modal onClose={onClose}>
                <ModalContent title="Settings" onClose={onClose}>
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Confirm on Delete</label>
                            <Tooltip text={settings.confirmOnDelete ? "Disable delete confirmation" : "Enable delete confirmation"}>
                                <button onClick={() => handleToggle('confirmOnDelete')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.confirmOnDelete ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.confirmOnDelete ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Auto-collapse Empty Columns</label>
                            <Tooltip text={settings.autoCollapse ? "Disable auto-collapse" : "Enable auto-collapse"}>
                                <button onClick={() => handleToggle('autoCollapse')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.autoCollapse ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.autoCollapse ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Stack Columns Vertically</label>
                            <Tooltip text={settings.verticalLayout ? "Switch to horizontal layout" : "Switch to vertical layout"}>
                                <button onClick={() => handleToggle('verticalLayout')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.verticalLayout ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.verticalLayout ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                    </div>
                </ModalContent>
            </Modal> 
        );
    };

    const ManageSwimlanesModal = ({ allTags, activeSwimlanes, setSwimlanes, onClose }) => {
        const handleToggle = (tag) => {
            setSwimlanes(prev =>
                prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag]
            );
        };
        // allTags from context is now already just custom tags, sorted.
        const manageableTags = allTags; 

        const doneButton = (
            <Tooltip text="Close swimlane management">
                <button onClick={onClose} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500 text-sm">Done</button>
            </Tooltip>
        );

        return (
            <Modal onClose={onClose}>
                <ModalContent title="Manage Swimlanes" onClose={onClose} headerActions={doneButton}>
                    <p className="text-sm text-slate-400 mb-4">Select custom tags to create dedicated swimlane columns. Priority-based columns are managed by task priority settings, not here.</p>
                    <div className="space-y-2">
                        {manageableTags.map(tag => (
                            <div key={tag} className="flex items-center justify-between p-2 bg-slate-700/50 rounded-md">
                                <label className="text-slate-300">{tag}</label>
                                <Tooltip text={activeSwimlanes.includes(tag) ? `Disable swimlane for '${tag}'` : `Enable swimlane for '${tag}'`}>
                                    <button onClick={() => handleToggle(tag)} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${activeSwimlanes.includes(tag) ? 'bg-indigo-500' : 'bg-slate-600'}`}>
                                        <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${activeSwimlanes.includes(tag) ? 'translate-x-6' : 'translate-x-1'}`} />
                                    </button>
                                </Tooltip>
                            </div>
                        ))}
                        {manageableTags.length === 0 && (
                            <p className="text-sm text-slate-500 italic">No custom tags found to create swimlanes from. Add custom tags to your tasks first.</p>
                        )}
                    </div>
                    {/* "Done" button is now in the header via headerActions */}
                </ModalContent>
            </Modal>
        );
    };


    // --- App Entry Point ---
    const AppContainer = () => {
        return <App />;
    };

    const TaikoApp = () => {
        return (
            <AppProvider>
                <AppContainer />
            </AppProvider>
        );
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<TaikoApp />);

    </script>
</body>
</html>
