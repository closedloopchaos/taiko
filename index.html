<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taiko Task Master</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom CSS for animations and theming -->
    <style>
        body {
            font-family: sans-serif;
            background-color: #0f172a; /* Fallback background */
        }
        .pulse-border-high { animation: pulse-border-high 1.2s infinite; }
        @keyframes pulse-border-high { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0.9); } 
            50% { box-shadow: 0 0 0 6px rgba(248, 113, 113, 0); } 
        }
        .pulse-border-medium { animation: pulse-border-medium 1.8s infinite; }
        @keyframes pulse-border-medium { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.8); } 
            50% { box-shadow: 0 0 0 5px rgba(251, 191, 36, 0); } 
        }
        .pulse-border-low { animation: pulse-border-low 2.5s infinite; }
        @keyframes pulse-border-low { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.7); } 
            50% { box-shadow: 0 0 0 4px rgba(56, 189, 248, 0); } 
        }
        .pulse-border-default { animation: pulse-border-default 2s infinite; }
        @keyframes pulse-border-default { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(100, 116, 139, 0.7); } /* slate-500 like for default pulse */
            50% { box-shadow: 0 0 0 5px rgba(100, 116, 139, 0); } 
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel Standalone for JSX Transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Main Application Logic -->
    <script type="text/babel">

    const { useState, useEffect, useRef, useCallback, createContext, useContext, useMemo } = React;


    // -----------------------------------------------------------------------------------------------------------------------------  THIS IS WHERE THE RELEASE NOTES ARE -----------------------------------------------------------------------------------------------------------------------------
    // --- Global Constants & Configurations ---
    const CURRENT_APP_VERSION = '1.2.0';

    const RELEASE_NOTES = {
        '1.2.0': {
            title: "What's New in Version 1.2.0",
            notes: [
                {
                    title: "ðŸŽ¨ Major UI Redesign: Task Cards",
                    description: "Task cards have been completely redesigned for better clarity and functionality, featuring a cleaner layout and a new way to manage status."
                },
                {
                    title: "ðŸ“ Feature: Detailed Task Notes",
                    description: "You can now add, edit, and view multi-line notes directly within each task card. The notes section is expandable and auto-saves your content."
                },
                {
                    title: "ðŸš€ Feature: Completed Task Summary",
                    description: "Generate a detailed, timezone-aware summary of all completed tasks, including their notes and subtasks. Find the new document icon in the header!"
                }
            ]
        }
        // Future versions can be added here
    };


    const PRIORITIES = { // These are the internal constant values
        LOW: 'PRIORITY_LOW', // Actual tag string
        MEDIUM: 'PRIORITY_MEDIUM',
        HIGH: 'PRIORITY_HIGH'
    };

    const getPrioritySortValue = (priority) => {
        if (priority === PRIORITIES.HIGH) return 0;
        if (priority === PRIORITIES.MEDIUM) return 1;
        if (priority === PRIORITIES.LOW) return 2;
        return 3; // For null or undefined priority (Unprioritized)
    };

    // PRIORITY_CONFIG must be defined after PRIORITIES and before constants that use it.
    // We will add sound generation parameters here later if needed, or handle in the playSound function.
    const PRIORITY_CONFIG = {
        [PRIORITIES.LOW]: { title: "Low", color: "text-sky-400", bgColor: "bg-sky-500/20", borderColor: "border-sky-500", pulseClass: 'pulse-border-low' },
        [PRIORITIES.MEDIUM]: { title: "Medium", color: "text-yellow-400", bgColor: "bg-yellow-500/20", borderColor: "border-yellow-500", pulseClass: 'pulse-border-medium' },
        [PRIORITIES.HIGH]: { title: "High", color: "text-red-400", bgColor: "bg-red-500/20", borderColor: "border-red-500", pulseClass: 'pulse-border-high' },
        null: { title: "Unprioritized", color: "text-slate-400", bgColor: "bg-slate-500/10", borderColor: "border-slate-600", pulseClass: 'pulse-border-default' } // For null priority
    };

    // Now define constants that depend on PRIORITIES and PRIORITY_CONFIG
    const PRIORITY_DISPLAY_TITLES_ARRAY = Object.values(PRIORITIES) // e.g., ["Low", "Medium", "High"]
        .map(pKey => PRIORITY_CONFIG[pKey]?.title)
        .filter(Boolean); // e.g., ["Low", "Medium", "High"]
    const PRIORITY_TITLE_TO_CONSTANT_MAP = Object.fromEntries( // e.g., { "Low": "PRIORITY_LOW", ... }
      Object.values(PRIORITIES).map(pConstant => [PRIORITY_CONFIG[pConstant]?.title, pConstant]).filter(([title]) => title)
    ); // e.g., { "Low": "PRIORITY_LOW", ... }

    const TASK_STATUS = { TO_DO: 'To Do', IN_PROGRESS: 'In Progress', ON_HOLD: 'On Hold', DONE: 'Done' };
    const TIMEZONE_MAP = { EST: 'America/New_York', PST: 'America/Los_Angeles', UTC: 'UTC' };
    const TIMEZONE_ORDER = ['EST', 'PST', 'UTC'];
    const TASK_STATUS_CONFIG = {
        [TASK_STATUS.TO_DO]: { 
            label: 'To Do', 
            selectBgColor: 'bg-sky-900/50', 
            accentClass: 'bg-sky-400',
            glowClass: 'shadow-[0_0_15px_-4px_rgba(56,189,248,0.5)] hover:shadow-[0_0_18px_-3px_rgba(56,189,248,0.7)]'
        },
        [TASK_STATUS.IN_PROGRESS]: { 
            label: 'In Progress', 
            selectBgColor: 'bg-yellow-900/50', 
            accentClass: 'bg-amber-400',
            glowClass: 'shadow-[0_0_15px_-4px_rgba(251,191,36,0.5)] hover:shadow-[0_0_18px_-3px_rgba(251,191,36,0.7)]'
        },
        [TASK_STATUS.ON_HOLD]: { 
            label: 'On Hold', 
            selectBgColor: 'bg-slate-700/50', 
            accentClass: 'bg-slate-500',
            glowClass: 'shadow-[0_0_15px_-4px_rgba(100,116,139,0.4)] hover:shadow-[0_0_18px_-3px_rgba(100,116,139,0.6)]'
        },
        [TASK_STATUS.DONE]: { 
            label: 'Done', 
            selectBgColor: 'bg-green-900/50', 
            accentClass: 'bg-green-500',
            glowClass: 'shadow-[0_0_12px_-5px_rgba(34,197,94,0.5)]' // More subtle glow for "Done"
        }
    };

    // --- Web Audio API Sound Generation ---
    let audioContext = null;
    const getAudioContext = () => {
        if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioContext;
    };

    const playTone = (frequency, duration = 0.5, type = 'sine', volume = 0.3) => {
        const actx = getAudioContext();
        if (!actx) {
            console.warn("Web Audio API is not supported in this browser.");
            return;
        }

        const oscillator = actx.createOscillator();
        const gainNode = actx.createGain();

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, actx.currentTime);
        gainNode.gain.setValueAtTime(volume, actx.currentTime);
        // Simple fade out to avoid clicking
        gainNode.gain.linearRampToValueAtTime(0.0001, actx.currentTime + duration - 0.05);

        oscillator.connect(gainNode);
        gainNode.connect(actx.destination);

        oscillator.start();
        oscillator.stop(actx.currentTime + duration);
    };

    // --- Context for State Management ---
    const AppContext = createContext(null);

    // --- Provider Component ---
    const AppProvider = ({ children }) => {
        // --- Core State ---
        const [tasks, setTasks] = useState([]);
        const [settings, setSettings] = useState({ 
            confirmOnDelete: true, 
            autoCollapse: true, // Default to true
            verticalLayout: false
        });

        // --- Modal-related State ---
        const [taskToComplete, setTaskToComplete] = useState(null);
        const [taskToDelete, setTaskToDelete] = useState(null);
        // --- UI Interaction State (lifted from App) ---
        const [showCompleted, setShowCompleted] = useState(false);
        const [activeTags, setActiveTags] = useState([]);
        const [collapsedTagSwimlanes, setCollapsedTagSwimlanes] = useState({}); // Moved from App
        const [activeSwimlanes, setActiveSwimlanes] = useState([]);
        const [collapsedColumns, setCollapsedColumns] = useState({ 'unsorted': false }); // For fixed columns like "Unsorted"

        const appId = 'taiko-app-local';

        // --- Local Storage Persistence ---
        useEffect(() => {
            const savedTasks = localStorage.getItem(`${appId}-tasks`);
            if (savedTasks) try { setTasks(JSON.parse(savedTasks)); } catch { console.error("Could not parse saved tasks."); }
            
            const defaultSettings = {
                confirmOnDelete: true,
                showTooltips: true,
                autoCollapse: true,
                verticalLayout: false
            };

            const savedSettings = localStorage.getItem(`${appId}-settings`);
            if (savedSettings) {
                try { 
                    const parsed = JSON.parse(savedSettings);
                    setSettings({...defaultSettings, ...parsed}); // Merge saved over defaults
                } catch { 
                    console.error("Could not parse saved settings. Using defaults.");
                    setSettings(defaultSettings); // Fallback to defaults on parse error
                }
            } else {
                setSettings(defaultSettings); // No saved settings, use defaults
            }

            const savedShowCompleted = localStorage.getItem(`${appId}-showCompleted`);
            if (savedShowCompleted) try { setShowCompleted(JSON.parse(savedShowCompleted)); } catch { console.error("Could not parse saved showCompleted state."); setShowCompleted(false); }

            const savedActiveTags = localStorage.getItem(`${appId}-activeTags`);
            if (savedActiveTags) try { setActiveTags(JSON.parse(savedActiveTags)); } catch { console.error("Could not parse saved active tags."); setActiveTags([]); }

            const savedActiveSwimlanes = localStorage.getItem(`${appId}-activeSwimlanes`);
            if (savedActiveSwimlanes) try { setActiveSwimlanes(JSON.parse(savedActiveSwimlanes)); } catch { console.error("Could not parse saved active swimlanes."); setActiveSwimlanes([]); }

            const savedCollapsedTagSwimlanes = localStorage.getItem(`${appId}-collapsedTagSwimlanes`);
            if (savedCollapsedTagSwimlanes) try { setCollapsedTagSwimlanes(JSON.parse(savedCollapsedTagSwimlanes)); } catch { console.error("Could not parse saved collapsed tag swimlanes."); setCollapsedTagSwimlanes({}); }
            
            const defaultCollapsedColumns = { 'unsorted': false }; // Updated key
            const savedCollapsedColumns = localStorage.getItem(`${appId}-collapsedColumns`);
            if (savedCollapsedColumns) {
                try {
                    setCollapsedColumns(JSON.parse(savedCollapsedColumns));
                } catch {
                    console.error("Could not parse saved collapsed columns. Using defaults.");
                    setCollapsedColumns(defaultCollapsedColumns);
                }
            } else {
                setCollapsedColumns(defaultCollapsedColumns);
            }
        }, [appId]); 

        useEffect(() => {
            localStorage.setItem(`${appId}-tasks`, JSON.stringify(tasks));
        }, [tasks]);

        useEffect(() => {
            localStorage.setItem(`${appId}-settings`, JSON.stringify(settings));
        }, [settings]);

        useEffect(() => {
            localStorage.setItem(`${appId}-showCompleted`, JSON.stringify(showCompleted));
        }, [showCompleted, appId]);

        useEffect(() => {
            localStorage.setItem(`${appId}-activeTags`, JSON.stringify(activeTags));
        }, [activeTags, appId]);

        useEffect(() => {
            localStorage.setItem(`${appId}-activeSwimlanes`, JSON.stringify(activeSwimlanes));
        }, [activeSwimlanes, appId]);

        useEffect(() => {
            localStorage.setItem(`${appId}-collapsedTagSwimlanes`, JSON.stringify(collapsedTagSwimlanes));
        }, [collapsedTagSwimlanes, appId]);

        useEffect(() => {
            localStorage.setItem(`${appId}-collapsedColumns`, JSON.stringify(collapsedColumns));
        }, [collapsedColumns, appId]);

        // --- Notification Permission ---
        useEffect(() => {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }, []);

        // --- Derived State ---
        const currentTasks = useMemo(() => showCompleted ? tasks.filter(t => t.status === TASK_STATUS.DONE) : tasks.filter(t => t.status !== TASK_STATUS.DONE), [tasks, showCompleted]);

        // --- Core Data Actions ---
        const updateTask = useCallback((id, updatedFields) => {
            setTasks(prevTasks => prevTasks.map(task => 
                task.id === id ? { ...task, ...updatedFields, timestamp: new Date().toISOString() } : task
            ));
        }, []);
        
        const addTask = useCallback((initialTitle = 'New Task', initialPriority = null, initialTags = []) => {
            const newTask = {
                id: crypto.randomUUID(),
                title: initialTitle, 
                checklist: [],
                priority: initialPriority, 
                status: 'To Do',
                rank: tasks.filter(t => t.priority === initialPriority && !t.archived).length, // Rank will be based on the current priority value
                timestamp: new Date().toISOString(), 
                startedAt: null,
                notes: '', // Add a notes field
                totalElapsedTimeInSeconds: 0,
                reminderAt: null, 
                reminderFired: false, 
                tags: Array.isArray(initialTags) ? [...new Set(initialTags)] : [] // Ensure unique tags
            };
            setTasks(prevTasks => [newTask, ...prevTasks].sort((a, b) => (a.rank || 0) - (b.rank || 0) || new Date(a.timestamp) - new Date(b.timestamp))); // Add to top and re-sort
        }, [tasks]);

        const deleteTask = useCallback((id) => {
            setTasks(prevTasks => prevTasks.filter(task => task.id !== id));
        }, []);

        const deleteAllCompletedTasks = useCallback(() => {
            setTasks(prevTasks => prevTasks.filter(task => task.status !== TASK_STATUS.DONE));
        }, []);

        const allTags = useMemo(() => {
            // allTags should contain all custom tags from ALL tasks to ensure swimlane management is always complete.
            const customTagsSet = new Set();
            tasks.forEach(task => { // Iterate over all tasks
                (task.tags || []).forEach(tag => {
                    // Check if the tag is a priority display title (case-insensitive)
                    const isPriorityTitle = PRIORITY_DISPLAY_TITLES_ARRAY.some(
                        pTitle => pTitle.toLowerCase() === tag.toLowerCase()
                    );
                    if (!isPriorityTitle) {
                        customTagsSet.add(tag);
                    }
                });
            });
            return Array.from(customTagsSet).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        }, [tasks, PRIORITY_DISPLAY_TITLES_ARRAY]); // Depends on all tasks now

        // --- Swimlane Collapse Management ---
        const expandSwimlane = useCallback((swimlaneName) => {
            setCollapsedTagSwimlanes(prev => ({ ...prev, [swimlaneName]: false }));
        }, []); // setCollapsedTagSwimlanes is stable
        const toggleSwimlaneCollapse = useCallback((swimlaneName) => {
            setCollapsedTagSwimlanes(prev => ({ ...prev, [swimlaneName]: !prev[swimlaneName] }));
        }, []); // setCollapsedTagSwimlanes is stable


        const contextValue = useMemo(() => ({
            tasks, updateTask, addTask, deleteTask, deleteAllCompletedTasks,
            settings, setSettings, allTags, 
            taskToComplete, setTaskToComplete,
            taskToDelete, setTaskToDelete,
            activeTags, setActiveTags,
            activeSwimlanes, setActiveSwimlanes,
            collapsedTagSwimlanes, setCollapsedTagSwimlanes,
            collapsedColumns, setCollapsedColumns, // Added for fixed columns
            expandSwimlane,        
            toggleSwimlaneCollapse,
            showCompleted, setShowCompleted, currentTasks
        }), [
            tasks, updateTask, addTask, deleteTask, deleteAllCompletedTasks,
            settings, setSettings, allTags, 
            taskToComplete, setTaskToComplete,
            taskToDelete, setTaskToDelete,
            activeTags, setActiveTags,
            activeSwimlanes, setActiveSwimlanes,
            collapsedTagSwimlanes, setCollapsedTagSwimlanes,
            collapsedColumns, setCollapsedColumns,
            expandSwimlane, toggleSwimlaneCollapse,
            showCompleted, currentTasks
        ]);
        
        return <AppContext.Provider value={contextValue}>{children}</AppContext.Provider>;
    };

    // --- Custom Hook to consume context ---
    const useAppContext = () => {
        const context = useContext(AppContext);
        if (context === null) throw new Error("useAppContext must be used within an AppProvider");
        return context;
    }

    // --- Helper Hooks ---
    const usePrevious = (value) => { const ref = useRef(); useEffect(() => { ref.current = value; }); return ref.current; };
    const useNow = (updateInterval = 1000) => { const [now, setNow] = useState(new Date()); useEffect(() => { const timerId = setInterval(() => setNow(new Date()), updateInterval); return () => clearInterval(timerId); }, [updateInterval]); return now; };

    // --- Helper Function for Time Parsing (MM:SS or SS duration) ---
    const parseHHMMSSDuration = (inputStr) => {
        if (!inputStr || typeof inputStr !== 'string') return null;

        const parts = inputStr.split(':').map(p => p.trim());
        
        let h = 0, m = 0, s = 0;
        let parsedSuccessfully = false;

        if (parts.length === 1) {
            const val = parseInt(parts[0], 10);
            if (!isNaN(val) && String(val) === parts[0]) { // Ensure clean integer parse
                s = val;
                parsedSuccessfully = true;
            }
        } else if (parts.length === 2) {
            const valM = parseInt(parts[0], 10);
            const valS = parseInt(parts[1], 10);
            if (!isNaN(valM) && String(valM) === parts[0] &&
                !isNaN(valS) && String(valS) === parts[1]) {
                m = valM;
                s = valS;
                parsedSuccessfully = true;
            }
        }

        if (!parsedSuccessfully) return null;

        // Normalize seconds to minutes, and minutes to hours (though hours are not directly input)
        if (s >= 60) { m += Math.floor(s / 60); s %= 60; }
        // h will remain 0 if not explicitly set, which is fine for MM:SS or SS input.
        if (m >= 60) { h += Math.floor(m / 60); m %= 60; }

        const totalSeconds = h * 3600 + m * 60 + s;
        return totalSeconds > 0 ? totalSeconds : null;
    };
    const PRIORITY_TAGS_LIST = [PRIORITIES.LOW, PRIORITIES.MEDIUM, PRIORITIES.HIGH]; // May be unused by new logic but kept for now.
    const DISPLAY_PRIORITY_ORDER = [PRIORITIES.LOW, PRIORITIES.MEDIUM, PRIORITIES.HIGH]; // For UI column display - CHANGED ORDER

    // --- Icon Components (Memoized) ---
    const DeleteIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>);
    const BellIcon = React.memo(({ className }) => <svg xmlns="http://www.w3.org/2000/svg" className={`h-4 w-4 ${className || ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6 6 0 10-12 0v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" /></svg>);
    const ChevronDownIcon = React.memo(({ className }) => (
        <svg 
            xmlns="http://www.w3.org/2000/svg" 
            className={`h-5 w-5 ${className || ''}`} 
            viewBox="0 0 20 20" 
            fill="currentColor"
        >
            <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
        </svg>
    ));
    const SettingsIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.096 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>);
    const BugIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" strokeWidth="2" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" d="M15.362 5.214A8.252 8.252 0 0112 21 8.25 8.25 0 016.038 7.048 8.287 8.287 0 009 9.6a8.983 8.983 0 013.361-6.867 8.21 8.21 0 003 2.48z" />
            <path strokeLinecap="round" strokeLinejoin="round" d="M12 18a3.75 3.75 0 00.495-7.467 5.99 5.99 0 00-1.925 3.546 5.974 5.974 0 01-2.133-1A3.75 3.75 0 0012 18z" />
        </svg>
    ));
    const DocumentTextIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
        </svg>
    ));
    const PlusIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>);
    const TaikoLogo = React.memo(() => <svg width="52" height="52" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" className="text-white"><g stroke="currentColor" strokeWidth="4" fill="none" strokeLinecap="round" strokeLinejoin="round"><path d="M 25,30 C 25,10 75,10 75,30 V 70 C 75,90 25,90 25,70 Z" fill="rgba(255,255,255,0.1)"/><path d="M 75,30 C 90,30 90,70 75,70" /><path d="M 25,30 C 10,30 10,70 25,70" /><circle cx="50" cy="50" r="28" strokeWidth="3"/><circle cx="50" cy="50" r="8" fill="currentColor"/></g></svg>);

    // --- Time & Countdown Components (Memoized) ---
    const LiveClock = React.memo(({ timezone, onTimezoneChange }) => {
        const time = useNow();
        const dateOptions = useMemo(() => ({ weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' }), []);
        const timeZone = useMemo(() => TIMEZONE_MAP[timezone], [timezone]);
        
        const formattedTime = time.toLocaleTimeString('en-US', { timeZone, hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const formattedDate = time.toLocaleDateString('en-US', { ...dateOptions, timeZone });

        return (
            // This container will center its direct children: time, date, and button
            <div className="flex flex-col items-end text-slate-300">
                {/* Time, now clickable and with a hover tooltip for the timezone */}
                <div 
                    onClick={onTimezoneChange} 
                    className="text-4xl font-mono tracking-wider cursor-pointer relative group"
                    title="Click to change timezone" // Added title attribute for accessibility
                >
                    {formattedTime}
                    <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1.5 opacity-0 group-hover:opacity-100 transition-opacity duration-200 whitespace-nowrap bg-slate-700 text-xs font-mono text-white px-2 py-1 rounded-md shadow-lg pointer-events-none">
                        Timezone: {timezone}
                    </div>
                </div>
                {/* Date, now a direct child, will be centered below the time */}
                <div className="text-base font-sans uppercase tracking-widest text-slate-400 mt-1">{formattedDate}</div>
            </div>
        );
    });

    const TimeElapsed = React.memo(({ startTime, totalElapsedSeconds }) => {
        const [elapsed, setElapsed] = useState('00:00:00');
        const animationFrameRef = useRef();
        const formatTime = useCallback((s) => new Date(s * 1000).toISOString().substr(11, 8), []);

        useEffect(() => {
            let isMounted = true;
            const animate = () => {
                if (!startTime || !isMounted) return;
                const currentSessionSeconds = (new Date().getTime() - new Date(startTime).getTime()) / 1000;
                setElapsed(formatTime((totalElapsedSeconds || 0) + currentSessionSeconds));
                animationFrameRef.current = requestAnimationFrame(animate);
            };
            if (startTime) animate();
            else setElapsed(formatTime(totalElapsedSeconds || 0));
            return () => { isMounted = false; cancelAnimationFrame(animationFrameRef.current); };
        }, [startTime, totalElapsedSeconds, formatTime]);
        
        return <span className="text-xs font-mono bg-slate-700/50 text-amber-300 px-2 py-1 rounded">{elapsed}</span>;
    });

    // --- Reminder Countdown Component ---
    const ReminderCountdown = React.memo(({ reminderAt }) => {
        const [countdown, setCountdown] = useState('');
        const now = useNow(); // Use the existing useNow hook

        const formatCountdown = useCallback((ms) => {
            if (ms <= 0) return 'Due!'; // Or '00:00:00' if you prefer
            const totalSeconds = Math.max(0, Math.floor(ms / 1000));
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }, []);

        useEffect(() => {
            if (!reminderAt) { setCountdown(''); return; }
            const remainingMs = new Date(reminderAt).getTime() - now.getTime();
            setCountdown(formatCountdown(remainingMs));
        }, [reminderAt, now, formatCountdown]);

        if (!reminderAt || countdown === '') return null;
        return <div className="text-xs text-cyan-300 font-mono">Countdown: {countdown}</div>;
    });

    // --- UI Components ---
    const ChecklistItem = React.memo(({ item, onUpdate, onDelete, onAddNewItemAfter, isFocused, onFocusHandled, isLocked }) => {
        const inputRef = useRef(null);

        useEffect(() => {
            if (isFocused && inputRef.current) {
                inputRef.current.focus();
                onFocusHandled(); // Important to prevent re-focusing on every render
            }
        }, [isFocused, onFocusHandled]);

        const handleKeyDown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                onAddNewItemAfter(item.id);
            }
        };

        return (
            <li className="flex items-center space-x-2 group">
                <input type="checkbox" checked={item.completed} onChange={e => onUpdate(item.id, { completed: e.target.checked })} disabled={isLocked} className="form-checkbox h-4 w-4 rounded bg-slate-700 border-slate-500 text-sky-500 focus:ring-sky-500 cursor-pointer disabled:cursor-not-allowed disabled:opacity-50" />
                <input 
                    ref={inputRef}
                    type="text" 
                    value={item.text} 
                    onChange={e => onUpdate(item.id, { text: e.target.value })} 
                    onKeyDown={handleKeyDown}
                    readOnly={isLocked}
                    className={`flex-grow min-w-0 bg-transparent text-sm p-1 rounded-md transition-colors ${item.completed ? 'text-slate-500 line-through' : 'text-slate-300'} focus:bg-slate-700 read-only:cursor-default`} 
                />
                <Tooltip text="Delete item">
                    <button onClick={() => onDelete(item.id)} disabled={isLocked} className="text-slate-500 hover:text-red-400 opacity-0 group-hover:opacity-100 transition-opacity disabled:hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                    </button>
                </Tooltip>
            </li>
        );
    });

    const Tooltip = ({ text, children }) => {
        const { settings } = useAppContext();
        
        if (!settings.showTooltips) {
            return <div className="relative group flex items-center">{children}</div>;
        }
        
        return (
            <div className="relative group flex items-center">
                {children}
                <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1.5 whitespace-nowrap bg-slate-700 text-white text-xs font-mono rounded-md py-1 px-2 shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-30">{text}</div>
            </div>
        );
    };

    // --- Task Card Component ---
    const TaskCard = ({ task, clockTimezone }) => { // Added clockTimezone prop
        const { updateTask, deleteTask, allTags, settings, setTaskToDelete, setTaskToComplete, setActiveTags, setActiveSwimlanes, expandSwimlane, activeTags } = useAppContext();
        const now = useNow();
        const isLocked = task.status === TASK_STATUS.DONE;

        const [isEditingTitle, setIsEditingTitle] = useState(false); // To be wrapped
        const [title, setTitle] = useState(task.title);
        const [isSettingReminder, setIsSettingReminder] = useState(false);
        const [reminderInput, setReminderInput] = useState('');
        const [checklist, setChecklist] = useState(task.checklist || []);
        const [newTag, setNewTag] = useState('');
        const [tagError, setTagError] = useState('');
        // State for task notes
        const [notes, setNotes] = useState(task.notes || '');
        // State for notes visibility
        const [isNotesExpanded, setIsNotesExpanded] = useState(false);
        // State to manage which checklist item should be focused
        const [focusedItemId, setFocusedItemId] = useState(null);
        const notesTextareaRef = useRef(null); // Ref for the notes textarea
        
        useEffect(() => { setChecklist(task.checklist || []); }, [task.checklist]);
        useEffect(() => { setTitle(task.title); }, [task.title]);

        useEffect(() => {
            if (tagError) {
                const timer = setTimeout(() => {
                    setTagError('');
                }, 3000); // Clear error after 3 seconds
                return () => clearTimeout(timer);
            }
        }, [tagError]);
        useEffect(() => { setNotes(task.notes || ''); }, [task.notes]); // Sync notes state with prop
        
        // Effect to auto-resize the notes textarea
        useEffect(() => {
            if (isNotesExpanded && notesTextareaRef.current) {
                const textarea = notesTextareaRef.current;
                textarea.style.height = 'auto'; // Reset height to allow shrinking
                textarea.style.height = `${textarea.scrollHeight}px`; // Set to content height
            }
        }, [notes, isNotesExpanded]); // Rerun on content change or when expanded

        const handleDeleteRequest = useCallback(() => {
            if (settings.confirmOnDelete) {
                setTaskToDelete(task.id); // Corrected: Should set the task ID
            } else {
                deleteTask(task.id);
            }
        }, [task.id, settings.confirmOnDelete, deleteTask, setTaskToDelete]);

        const handleUpdateChecklist = useCallback((updatedList) => {
            // Checklist updates no longer automatically change task status.
            // Status is now manually set via the dropdown.
            updateTask(task.id, { checklist: updatedList });
        }, [task.id, updateTask]);
        
        const handleItemUpdate = (id, values) => handleUpdateChecklist(checklist.map(i => i.id === id ? { ...i, ...values } : i));
        const handleItemDelete = (id) => handleUpdateChecklist(checklist.filter(i => i.id !== id));
        const handleAddItem = () => {
            const newId = crypto.randomUUID();
            setFocusedItemId(newId); // Set the new item to be focused
            handleUpdateChecklist([...checklist, { id: newId, text: '', completed: false }]);
        };
        const handleAddNewItemAfter = useCallback((currentItemId) => {
            const newId = crypto.randomUUID();
            setFocusedItemId(newId); // Set the ID of the new item to be focused
            const currentIndex = checklist.findIndex(i => i.id === currentItemId);
            const newChecklist = [...checklist];
            // Insert the new item right after the current one
            newChecklist.splice(currentIndex + 1, 0, { id: newId, text: '', completed: false });
            handleUpdateChecklist(newChecklist);
        }, [checklist, handleUpdateChecklist]);
        const handleTitleBlur = () => { setIsEditingTitle(false); if (title !== task.title) updateTask(task.id, { title }); };
        const handleTitleKeyDown = (e) => { if (e.key === 'Enter') { e.preventDefault(); handleTitleBlur(); } };
        
        const handleAddTag = () => {
            const currentTags = task.tags || [];
            const trimmedNewTag = newTag.trim();
    
            // Prohibit adding priority display titles as custom tags (case-insensitive)
            const isPriorityTitle = PRIORITY_DISPLAY_TITLES_ARRAY.some(
                pTitle => pTitle.toLowerCase() === trimmedNewTag.toLowerCase()
            );
    
            if (trimmedNewTag && !isPriorityTitle && !currentTags.includes(trimmedNewTag)) {
                // Get custom tags *before* adding the new one.
                // task.tags should only store custom tags.
                const existingCustomTagsCount = currentTags.length;
    
                const newTagsArray = [...currentTags, trimmedNewTag];
                updateTask(task.id, { tags: newTagsArray });
    
                // Only auto-activate swimlane if this is the *first* custom tag added to the task,
                // and ensure the tag itself is not a priority display title (which it shouldn't be for custom tags).
                if (existingCustomTagsCount === 0 && !PRIORITY_DISPLAY_TITLES_ARRAY.includes(trimmedNewTag)) {
                    setActiveSwimlanes(prevActiveSwimlanes => {
                        expandSwimlane(trimmedNewTag); 
                        if (!prevActiveSwimlanes.includes(trimmedNewTag)) {
                            return [...prevActiveSwimlanes, trimmedNewTag]; 
                        }
                        return prevActiveSwimlanes;
                    });
                }
            } else if (isPriorityTitle) {
                setTagError('Cannot add "Low", "Medium", or "High" as custom tags. Use priority buttons.');
                playTone(220, 0.3, 'square', 0.2); // Play a low, short error tone
            }
            setNewTag(''); // Clear input in all cases
        };

        const handleRemoveTag = (tagToRemove) => {
            const currentTags = task.tags || [];
            const newTags = (task.tags || []).filter(tag => tag !== tagToRemove);
            updateTask(task.id, { tags: newTags });

            // After removing the tag, check if the task still has tags.
            // If it does, find the first remaining tag that corresponds to a potential swimlane
            // (either a priority display title or a custom tag) and ensure that swimlane
            // is active and expanded. This helps guide the task to a relevant column.
            
            // Find the first remaining tag that is either a priority display title or a custom tag
            const firstRemainingPotentialSwimlaneTag = newTags.find(tag => 
                PRIORITY_DISPLAY_TITLES_ARRAY.includes(tag) || allTags.includes(tag) // Check if it's a known tag/priority
            );

            if (firstRemainingPotentialSwimlaneTag) {
                 // Ensure this potential swimlane is active and expanded
                 setActiveSwimlanes(prevActiveSwimlanes => {
                    expandSwimlane(firstRemainingPotentialSwimlaneTag); // Expand it
                    return prevActiveSwimlanes.includes(firstRemainingPotentialSwimlaneTag) ? prevActiveSwimlanes : [...prevActiveSwimlanes, firstRemainingPotentialSwimlaneTag]; // Add to active if not already
                 });
            }
        };

        const handleSetReminder = useCallback(() => {
            if (!reminderInput) return;

            const durationInSeconds = parseHHMMSSDuration(reminderInput);

            if (durationInSeconds === null || durationInSeconds <= 0) {
                console.warn("Invalid duration input for reminder:", reminderInput);
                // Optionally, you could set an error state here to show a message to the user
                return;
            }

            const reminderDate = new Date(Date.now() + durationInSeconds * 1000);
            updateTask(task.id, { reminderAt: reminderDate.toISOString(), reminderFired: false });
            setIsSettingReminder(false);
            setReminderInput(''); // Clear input after setting
        }, [reminderInput, task.id, updateTask, setIsSettingReminder, setReminderInput]);

        const handleReminderKeyDown = (e) => {
            if (e.key === 'Enter') { e.preventDefault(); handleSetReminder(); }
        };

        const handleNotesKeyDown = (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                updateTask(task.id, { notes }); // Save notes
                setIsNotesExpanded(false); // Collapse view
            }
        };
        
        const handleSetPriorityTag = (priorityConstantToSet) => {
            const oldPriorityDisplayTitle = task.priority ? PRIORITY_CONFIG[task.priority].title : null;
        
            let newPriorityConstant = task.priority;
            let newPriorityDisplayTitle = null;
        
            if (priorityConstantToSet && task.priority !== priorityConstantToSet) {
                newPriorityConstant = priorityConstantToSet;
                newPriorityDisplayTitle = PRIORITY_CONFIG[priorityConstantToSet].title;
            } else if (priorityConstantToSet && task.priority === priorityConstantToSet) {
                newPriorityConstant = null;
            } else if (!priorityConstantToSet) {
                newPriorityConstant = null;
            }
        
            // This logic ensures that if you change a task's priority while filtering by that
            // same priority, the filter updates to follow the task, preventing it from disappearing.
            // We update the filters *before* the task data to prevent a re-render with inconsistent state.
            setActiveTags(prevTags => {
                if (oldPriorityDisplayTitle && prevTags.includes(oldPriorityDisplayTitle)) {
                    // Remove all existing priority filters to ensure a clean state.
                    const nonPriorityFilters = prevTags.filter(t => !PRIORITY_TITLE_TO_CONSTANT_MAP[t]);
                    // Add the new priority filter if one was set.
                    return newPriorityDisplayTitle ? [...nonPriorityFilters, newPriorityDisplayTitle] : nonPriorityFilters;
                }
                // If the old priority wasn't an active filter, don't change the filters.
                return prevTags;
            });
        
            // Now, update the task's data. React will batch this with the filter update.
            updateTask(task.id, { priority: newPriorityConstant });
        
            // Finally, manage swimlane visibility as a UI enhancement.
            if (newPriorityDisplayTitle) {
                if (!activeSwimlanes.includes(newPriorityDisplayTitle)) {
                    setActiveSwimlanes(prev => [...prev, newPriorityDisplayTitle]);
                }
                expandSwimlane(newPriorityDisplayTitle);
            }
        };

        const handleStatusChange = (e) => {
            const newStatus = e.target.value;
            if (newStatus === TASK_STATUS.DONE) {
                setTaskToComplete(task); // Show confirmation modal
            } else {
                updateTask(task.id, { status: newStatus }); // Update directly for other statuses
            }
        };
        

        // Pulse should continue as long as the reminder time has passed,
        // regardless of whether the notification itself has fired.
        const reminderIsDue = task.reminderAt && new Date(task.reminderAt) <= now;
        const pulseClass = reminderIsDue ? (PRIORITY_CONFIG[task.priority]?.pulseClass || '') : '';

        return (
            <div className={`w-full min-w-0 bg-slate-800/90 backdrop-blur-xl border border-slate-700/50 rounded-lg shadow-lg mb-4 transition-shadow duration-300 ${pulseClass} ${TASK_STATUS_CONFIG[task.status]?.glowClass || ''}`}>
                <div className={`h-1.5 rounded-t-lg ${TASK_STATUS_CONFIG[task.status]?.accentClass}`}></div>
                <div className="p-3">
                    <div className="flex justify-between items-start mb-2">
                        {isEditingTitle ? (
                            <input type="text" value={title} onChange={e => setTitle(e.target.value)} onBlur={handleTitleBlur} onKeyDown={handleTitleKeyDown} autoFocus className="flex-1 min-w-0 bg-slate-900/50 rounded-md p-1 text-slate-100 font-bold border border-slate-600 focus:ring-2 focus:ring-sky-500" />
                        ) : (
                            <Tooltip text={isLocked ? "Task is completed" : "Double-click to edit title"}>
                                <h3 onDoubleClick={isLocked ? undefined : () => setIsEditingTitle(true)} className={`font-bold text-slate-100 flex-grow min-w-0 break-words ${isLocked ? 'cursor-default' : 'cursor-pointer'}`}>{task.title}</h3>
                            </Tooltip>
                        )}
                    </div>

                    <ul className="space-y-1 my-2">{checklist.map(item => 
                        <ChecklistItem 
                            key={item.id} 
                            item={item} 
                            onUpdate={handleItemUpdate} 
                            onDelete={handleItemDelete} 
                            onAddNewItemAfter={handleAddNewItemAfter}
                            isFocused={focusedItemId === item.id}
                            onFocusHandled={() => setFocusedItemId(null)}
                            isLocked={isLocked}
                        />
                    )}</ul>
                    <Tooltip text="Add a new checklist item">
                        <button onClick={handleAddItem} disabled={isLocked} className="w-full text-left text-sm text-sky-400 hover:text-sky-300 p-1 rounded-md hover:bg-slate-700/50 disabled:text-slate-500 disabled:cursor-not-allowed disabled:hover:bg-transparent">+ Add item</button>
                    </Tooltip>

                    {/* --- Notes Section --- */}
                    <div className="mt-3 pt-2 border-t border-slate-700/50">
                        {isNotesExpanded ? (
                            <>
                                <div className="flex justify-between items-center mb-1">
                                    <label htmlFor={`notes-${task.id}`} className="block text-xs text-slate-400">Notes:</label>
                                    <Tooltip text="Collapse notes section">
                                        <button onClick={() => setIsNotesExpanded(false)} className="text-xs text-sky-400 hover:text-sky-300">Collapse</button>
                                    </Tooltip>
                                </div>
                                <textarea
                                    ref={notesTextareaRef}
                                    id={`notes-${task.id}`}
                                    value={notes}
                                    onChange={e => setNotes(e.target.value)}
                                    onBlur={() => updateTask(task.id, { notes })}
                                    onKeyDown={handleNotesKeyDown}
                                    placeholder="Add detailed notes here..."
                                    className="w-full bg-slate-900/50 text-slate-200 text-sm p-2 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500 resize-none min-h-[60px] overflow-hidden"
                                    autoFocus
                                ></textarea>
                            </>
                        ) : (
                            <div className="flex justify-between items-center min-h-[24px]"> {/* Set min-height to prevent layout shift */}
                                {notes ? (
                                    <p className="text-sm text-slate-400 truncate flex-1 pr-2"><span className="font-semibold text-slate-300">Note:</span> {notes.split('\n')[0]}</p>
                                ) : (
                                    <p className="text-sm text-slate-500 italic">No notes for this task.</p>
                                )}
                                <Tooltip text={notes ? 'View or edit notes' : 'Add notes'}><button onClick={() => setIsNotesExpanded(true)} disabled={isLocked} className="text-xs text-sky-400 hover:text-sky-300 flex-shrink-0 disabled:text-slate-500 disabled:cursor-not-allowed">{notes ? 'View/Edit' : 'Add Note'}</button></Tooltip>
                            </div>
                        )}
                    </div>
                    {/* --- Tagging UI --- */}
                    <div className="mt-3 pt-2 border-t border-slate-700/50">
                        <div className="flex flex-wrap items-center gap-1 mb-2">
                            <span className="text-xs text-slate-400">Priority:</span> {/* Removed mr-2, gap will handle spacing */}
                            {DISPLAY_PRIORITY_ORDER.map(pTag => ( /* Use DISPLAY_PRIORITY_ORDER for consistent button order */
                                <Tooltip key={pTag} text={`Set priority to ${PRIORITY_CONFIG[pTag].title}`}>
                                    <button 
                                        onClick={() => handleSetPriorityTag(pTag)}
                                        disabled={isLocked} className={`px-2 py-0.5 text-xs font-semibold rounded-md border ${task.priority === pTag ? `${PRIORITY_CONFIG[pTag].bgColor} ${PRIORITY_CONFIG[pTag].borderColor} ${PRIORITY_CONFIG[pTag].color}` : `bg-slate-600/50 border-slate-500 text-slate-300 hover:${PRIORITY_CONFIG[pTag].bgColor}`} flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed`} /* Removed mr-1 mb-1, added flex-shrink-0 */
                                    >
                                        {PRIORITY_CONFIG[pTag].title}
                                    </button>
                                </Tooltip>
                            ))}
                            <Tooltip text="Clear priority (Unprioritized)">
                                <button onClick={() => handleSetPriorityTag(null)} disabled={isLocked} className={`px-2 py-0.5 text-xs font-semibold rounded-md border ${task.priority === null ? `${PRIORITY_CONFIG[null].bgColor} ${PRIORITY_CONFIG[null].borderColor} ${PRIORITY_CONFIG[null].color}` : 'bg-slate-600/50 border-slate-500 text-slate-300 hover:bg-slate-500/30'} flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed`}> {/* Removed mr-1 mb-1, added flex-shrink-0 */}
                                    Clear
                                </button>
                            </Tooltip>
                        </div>
                        </div>
                    <div className="mt-3 pt-2 border-t border-slate-700/50"> {/* This is the start of the custom tags section, unchanged by this request */}
                        <div className="flex flex-wrap gap-2 mb-2"> {/* Added mb-2 for spacing before input */}
                            {(task.tags || []).filter(tag => !PRIORITY_DISPLAY_TITLES_ARRAY.includes(tag)).map(tag => (
                                <span key={tag} className="bg-slate-700 text-xs text-slate-200 px-2 py-1 rounded-full flex items-center">
                                    {tag}
                                    <Tooltip text={`Remove tag: ${tag}`}>
                                        <button onClick={() => handleRemoveTag(tag)} disabled={isLocked} className="ml-2 text-slate-400 hover:text-white leading-none disabled:hidden">&times;</button>
                                    </Tooltip>
                                </span>
                            ))}
                        </div>
                        <div className="flex"> {/* Removed mt-2 as mb-2 was added above */}
                            <input
                                list="tag-suggestions"
                                type="text"
                                value={newTag}
                                onChange={(e) => setNewTag(e.target.value)}
                                onKeyDown={(e) => {if (e.key === 'Enter') handleAddTag()}}
                                placeholder="Add a tag..."                                disabled={isLocked} className="bg-slate-900/50 text-slate-200 text-xs p-1 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500 flex-grow min-w-0 disabled:cursor-not-allowed disabled:bg-slate-800"
                            />
                            <datalist id="tag-suggestions">
                                {allTags.map(tag => <option key={tag} value={tag} />)}
                            </datalist>
                            <Tooltip text="Add this tag to the task">
                                <button onClick={handleAddTag} disabled={isLocked} className="ml-2 text-xs bg-sky-600 text-white px-3 py-1 rounded-md hover:bg-sky-500 disabled:bg-slate-600 disabled:cursor-not-allowed">Add</button> {/* Adjusted py-1 for consistency */}
                            </Tooltip>
                        </div>
                        {tagError && <div className="mt-1.5 text-xs text-red-400">{tagError}</div>}
                    </div>

                    {isSettingReminder && !task.archived && (
                        <div className="mt-3 flex items-center space-x-2">
                            <input 
                                type="text" 
                                value={reminderInput}
                                onChange={e => setReminderInput(e.target.value)}
                                onKeyDown={handleReminderKeyDown}
                                autoFocus 
                                placeholder="Set in: MM:SS / SS"                                className="bg-slate-900/70 border border-slate-600 text-slate-200 text-sm rounded-md p-1 flex-1 min-w-0"/>
                            <Tooltip text="Set reminder from input">
                                <button onClick={handleSetReminder} className="px-3 py-1 bg-sky-600 text-white text-sm rounded-md hover:bg-sky-500">Set</button>
                            </Tooltip>
                        </div>
                    )}
                    {task.reminderAt && !isSettingReminder && (
                        <div className="mt-2 text-xs">
                            <div className="text-sky-300 flex justify-between items-center mb-0.5">
                                <span>
                                    Set for: {new Date(task.reminderAt).toLocaleTimeString([], {
                                        timeZone: TIMEZONE_MAP[clockTimezone] || 'UTC', // Fallback to UTC if map fails
                                        hour: '2-digit', minute:'2-digit', second: '2-digit'
                                    })} {clockTimezone}
                                </span>
                                <Tooltip text="Clear reminder">
                                    <button onClick={() => updateTask(task.id, { reminderAt: null, reminderFired: false })} className="text-red-400 hover:text-red-300 text-xs">(clear)</button>
                                </Tooltip>
                            </div>
                            <ReminderCountdown reminderAt={task.reminderAt} />
                        </div>
                    )}
                    <div className="mt-3 pt-2 border-t border-slate-700 flex justify-between items-center">
                        {/* Manual Status Selector */}
                        <div className="flex items-center space-x-2">
                            <label htmlFor={`status-select-${task.id}`} className="text-sm text-slate-400">Status:</label>
                            <select
                                id={`status-select-${task.id}`}
                                value={task.status}
                                onChange={handleStatusChange}
                                className={`${TASK_STATUS_CONFIG[task.status]?.selectBgColor || 'bg-slate-900/50'} text-slate-200 text-sm p-1 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500 transition-colors`}
                            >
                                {Object.values(TASK_STATUS).map(status => (
                                    <option key={status} value={status}>{status}</option>
                                ))}
                            </select>
                        </div>
                        <div className="flex items-center space-x-2">
                            <Tooltip text={isSettingReminder ? "Cancel reminder setup" : "Set Reminder"}>
                                <button onClick={() => setIsSettingReminder(!isSettingReminder)} disabled={task.status === TASK_STATUS.DONE} className="text-slate-400 hover:text-white transition-colors p-1 rounded-full hover:bg-slate-700 disabled:opacity-50"><BellIcon /></button>
                            </Tooltip>
                            <Tooltip text="Delete Permanently"><button onClick={handleDeleteRequest} className="text-red-400 hover:text-white transition-colors p-1 rounded-full hover:bg-red-500"><DeleteIcon /></button></Tooltip>
                        </div>
                    </div>
                </div>
            </div>
        );
    };
    const MemoizedTaskCard = React.memo(TaskCard);


    // --- Main Presentation Component ---
    const App = () => {
        const { 
            tasks, addTask, 
            settings, setSettings,
            taskToComplete, setTaskToComplete, taskToDelete, setTaskToDelete, deleteAllCompletedTasks,
            allTags, deleteTask, updateTask, // Core data functions
            activeTags, setActiveTags,                     // Filter state
            activeSwimlanes, setActiveSwimlanes,           // Swimlane visibility state
            collapsedTagSwimlanes, toggleSwimlaneCollapse, // Swimlane collapse state & toggle fn
            collapsedColumns, setCollapsedColumns,          // Fixed column collapse state & setter
            showCompleted, setShowCompleted, currentTasks   // View state and derived tasks from provider
        } = useAppContext();



        const now = useNow(); // Get current time, updates every second

        // const [collapsedColumns, setCollapsedColumns] = useState({ 'new-tasks': false }); // MOVED to AppProvider
        const [showSettings, setShowSettings] = useState(false);
        // const [collapsedTagSwimlanes, setCollapsedTagSwimlanes] = useState({}); // Moved to AppProvider
        const [clockTimezone, setClockTimezone] = useState('EST');
        const [showSwimlaneModal, setShowSwimlaneModal] = useState(false);
        const [draggedSwimlane, setDraggedSwimlane] = useState(null); // For swimlane reordering

        // State for the summary modal
        const [showSummaryModal, setShowSummaryModal] = useState(false);
        const [summaryText, setSummaryText] = useState('');
        const [showDeleteAllCompletedModal, setShowDeleteAllCompletedModal] = useState(false);
        const [showReleaseNotesModal, setShowReleaseNotesModal] = useState(false);


        // State for the main "Add Task" input in the header
        const [showMainAddTaskInput, setShowMainAddTaskInput] = useState(false);

        const prevTasks = usePrevious(currentTasks);

        // --- Effect for showing release notes once per version ---
        useEffect(() => {
            const lastSeenVersion = localStorage.getItem('taiko-app-local-lastSeenVersion');
            if (lastSeenVersion !== CURRENT_APP_VERSION) {
                setShowReleaseNotesModal(true);
            }
        }, []); // Run only once on mount

        const handleCloseReleaseNotes = () => {
            setShowReleaseNotesModal(false);
            localStorage.setItem('taiko-app-local-lastSeenVersion', CURRENT_APP_VERSION);
        };


        useEffect(() => {
            // Ensure that when the view switches between active and archived,
            // or when tasks are modified, the counts for filters are based on the currently displayed tasks.
            // The `currentTasks` variable already reflects this.
        }, [currentTasks]);

        const allTasksCount = useMemo(() => currentTasks.length, [currentTasks]);

        const completedTasksCount = useMemo(() => tasks.filter(t => t.status === TASK_STATUS.DONE).length, [tasks]);

        const priorityFilterCounts = useMemo(() => {
            const counts = {};
            DISPLAY_PRIORITY_ORDER.forEach(priorityConstant => {
                const displayTitle = PRIORITY_CONFIG[priorityConstant].title;
                counts[displayTitle] = currentTasks.filter(task => task.priority === priorityConstant).length;
            });
            return counts;
        }, [currentTasks]); // DISPLAY_PRIORITY_ORDER and PRIORITY_CONFIG are stable constants

        const customTagFilterCounts = useMemo(() => {
            const counts = {};
            const customTagsToDisplay = allTags.filter(tag => !PRIORITY_DISPLAY_TITLES_ARRAY.includes(tag));
            customTagsToDisplay.forEach(tag => {
                counts[tag] = currentTasks.filter(task => task.tags && task.tags.includes(tag)).length;
            });
            return counts;
        }, [currentTasks, allTags]); // PRIORITY_DISPLAY_TITLES_ARRAY is a stable constant

        // --- Effect for Reminder Notifications & Sounds ---
        useEffect(() => {
            if (!('Notification' in window) || Notification.permission !== 'granted') {
                return; // Notifications not supported or permission not granted
            }

            tasks.forEach(task => {
                if (task.reminderAt && !task.reminderFired && task.status !== TASK_STATUS.DONE && new Date(task.reminderAt) <= now) {
                    // console.log(`Firing reminder for task: ${task.title}`); // For debugging
                    new Notification('Taiko Task Reminder', {
                        body: `Reminder for: ${task.title}`,
                        // icon: 'your_icon.png' // Optional: Add an icon URL here
                    });
                    updateTask(task.id, { reminderFired: true });

                    // Play sound based on priority
                    switch (task.priority) {
                        case PRIORITIES.HIGH:
                            playTone(880, 0.6, 'sawtooth', 0.4); // Higher pitch, slightly harsher, louder
                            setTimeout(() => playTone(880, 0.3, 'sawtooth', 0.4), 150); // Quick second beep
                            break;
                        case PRIORITIES.MEDIUM:
                            playTone(660, 0.8, 'square', 0.35); // Medium pitch
                            break;
                        case PRIORITIES.LOW:
                            playTone(440, 1.0, 'sine', 0.3); // Lower pitch, softer
                            break;
                        default: // Unprioritized or null
                            playTone(523, 0.7, 'sine', 0.25); // A general C5 note
                    }
                }
            });
        }, [tasks, now, updateTask]);

        const handleConfirmDelete = useCallback(() => {
            if (!taskToDelete) return;
            deleteTask(taskToDelete);
            setTaskToDelete(null);
        }, [taskToDelete, deleteTask]);

        const handleConfirmComplete = useCallback(() => {
            if (!taskToComplete) return;
            updateTask(taskToComplete.id, { status: TASK_STATUS.DONE });
            setTaskToComplete(null);
        }, [taskToComplete, updateTask]);

        const handleConfirmDeleteAllCompleted = useCallback(() => {
            deleteAllCompletedTasks();
            setShowDeleteAllCompletedModal(false);
        }, [deleteAllCompletedTasks]);


        const handleAddTask = () => { 
            setShowMainAddTaskInput(true); // Show the input form instead of adding directly
        };
        const handleTimezoneChange = () => setClockTimezone(p => TIMEZONE_ORDER[(TIMEZONE_ORDER.indexOf(p) + 1) % TIMEZONE_ORDER.length]);
        
        const handleCompletedClick = () => {
            const newCompletedState = !showCompleted;
            setShowCompleted(newCompletedState);
        };
        // Effect to automatically hide empty swimlanes if autoCollapse is enabled (and they are empty after filtering)

        const generateCompletedTasksSummary = useCallback(() => {
            const completedTasks = tasks.filter(t => t.status === TASK_STATUS.DONE)
                                        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); // Sort by completion time
            
            const timeZone = TIMEZONE_MAP[clockTimezone] || 'UTC';
            const localeOptions = {
                year: 'numeric', month: 'numeric', day: 'numeric',
                hour: 'numeric', minute: 'numeric', second: 'numeric',
                hour12: true,
                timeZone: timeZone
            };

            
            let summary;
            if (completedTasks.length === 0) {
                summary = "No tasks have been completed yet.";
            } else {
                summary = `--- Completed Tasks Summary ---\n`;
                summary += `Total Completed: ${completedTasks.length}\n`;
                summary += `Generated on: ${new Date().toLocaleString('en-US', localeOptions)} ${clockTimezone}\n\n`;
                summary += "========================================\n\n";

                completedTasks.forEach(task => {
                    summary += `TASK: ${task.title}\n`;
                    
                    const priorityTitle = PRIORITY_CONFIG[task.priority]?.title || PRIORITY_CONFIG.null.title;
                    summary += `Priority: ${priorityTitle}\n`;
                    
                    summary += `Completed On: ${new Date(task.timestamp).toLocaleString('en-US', localeOptions)} ${clockTimezone}\n`;

                    if (task.notes && task.notes.trim()) {
                        summary += `\n  Notes:\n`;
                        summary += `    ${task.notes.trim().replace(/\n/g, '\n    ')}\n`; // Indent notes
                    } else {
                        summary += `\n  Notes:\n    No notes.\n`;
                    }

                    const validSubtasks = (task.checklist || []).filter(item => item.text && item.text.trim() !== '');

                    if (validSubtasks.length > 0) {
                        summary += `\n  Subtasks:\n`;
                        validSubtasks.forEach(item => {
                            summary += `    [${item.completed ? 'x' : ' '}] ${item.text}\n`;
                        });
                    } else {
                        summary += `\n  Subtasks:\n    No subtasks.\n`;
                    }

                    summary += "\n========================================\n\n";
                });
            }
            setSummaryText(summary);
            setShowSummaryModal(true);
        }, [tasks, clockTimezone]); // Dependency on `tasks` and `clockTimezone` state

        useEffect(() => {
            if (settings.autoCollapse) {
                // Use the functional update form of setActiveSwimlanes
                // to get the latest activeSwimlanes without adding it to dependencies,
                // and to conditionally update only if changes are needed.
                setActiveSwimlanes(currentActiveSwimlanes => {
                    const emptyActiveSwimlanesInThisRun = currentActiveSwimlanes.filter(swimlaneName => {
                        const tasksInSwimlane = swimlaneTasks[swimlaneName] || []; // swimlaneTasks is from the outer scope, captured at effect run time
                        return tasksInSwimlane.length === 0;
                    });

                    if (emptyActiveSwimlanesInThisRun.length > 0) {
                        const nextActiveSwimlanes = currentActiveSwimlanes.filter(name => !emptyActiveSwimlanesInThisRun.includes(name));
                        // Only return a new array if it's actually different to prevent unnecessary re-renders/loops
                        if (nextActiveSwimlanes.length !== currentActiveSwimlanes.length) {
                            return nextActiveSwimlanes;
                        }
                    }
                    return currentActiveSwimlanes; // No change needed
                });
            }
        }, [swimlaneTasks, settings.autoCollapse, setActiveSwimlanes]); // Dependencies: swimlaneTasks, autoCollapse setting, and the stable setter.

        const handleTagFilterClick = (tag) => {
            const isPriorityTag = PRIORITY_TITLE_TO_CONSTANT_MAP[tag]; // Will be truthy (the constant string) if 'tag' is a priority display title

            setActiveTags(prevActiveTags => {
                if (isPriorityTag) {
                    // It's a priority filter
                    if (prevActiveTags.includes(tag)) {
                        // Clicked an active priority filter: deactivate it
                        return prevActiveTags.filter(t => t !== tag);
                    } else {
                        // Clicked an inactive priority filter:
                        // 1. Remove all other active priority filters
                        const nonPriorityFilters = prevActiveTags.filter(t => !PRIORITY_TITLE_TO_CONSTANT_MAP[t]);
                        // 2. Add the newly clicked priority filter
                        return [...nonPriorityFilters, tag];
                    }
                } else {
                    // It's a custom tag filter: toggle normally
                    if (prevActiveTags.includes(tag)) {
                        return prevActiveTags.filter(t => t !== tag);
                    } else {
                        return [...prevActiveTags, tag];
                    }
                }
            });
        };

        const clearTagFilter = () => setActiveTags([]);

        // `tasksMatchingActiveFilters` is the set of tasks that pass the currently active filters.
        // This is the base for calculating the counts shown on the filter buttons.
        const tasksMatchingActiveFilters = useMemo(() => {
            if (activeTags.length === 0) return currentTasks;
            return currentTasks.filter(task =>
                activeTags.every(activeTag => {
                    const priorityConstant = PRIORITY_TITLE_TO_CONSTANT_MAP[activeTag];
                    return priorityConstant ? task.priority === priorityConstant : (task.tags && task.tags.includes(activeTag));
                })
            );
        }, [currentTasks, activeTags]);
        const handleDropSwimlane = (targetSwimlaneName) => {
            if (!draggedSwimlane || draggedSwimlane === targetSwimlaneName) {
                setDraggedSwimlane(null);
                return;
            }
            const newActiveSwimlanes = [...activeSwimlanes];
            const draggedIndex = newActiveSwimlanes.indexOf(draggedSwimlane);
            const targetIndex = newActiveSwimlanes.indexOf(targetSwimlaneName);

            newActiveSwimlanes.splice(draggedIndex, 1); // Remove dragged item
            newActiveSwimlanes.splice(targetIndex, 0, draggedSwimlane); // Insert at new position
            setActiveSwimlanes(newActiveSwimlanes);
            setDraggedSwimlane(null);
        };
        // --- Swimlane Drag and Drop Handlers ---
        const handleDragStartSwimlane = (e, swimlaneName) => {
            setDraggedSwimlane(swimlaneName);
            e.dataTransfer.effectAllowed = 'move';
            // Optional: Add a class to the body or a specific element for global drag styling
        };

        const handleDragOverSwimlane = (e) => {
            e.preventDefault(); // Necessary to allow dropping
        };

        // This count is for the "All" button, reflecting the total number of tasks currently visible after all filters.
        const allTasksCountForFilterDisplay = useMemo(() => tasksMatchingActiveFilters.length, [tasksMatchingActiveFilters]);

        // These counts are for the priority filter buttons.
        // They should reflect how many tasks *within the currently filtered set* belong to each priority.
        const priorityFilterCountsForDisplay = useMemo(() => {
            const counts = {};
            DISPLAY_PRIORITY_ORDER.forEach(priorityConstant => {
                const displayTitle = PRIORITY_CONFIG[priorityConstant].title;
                counts[displayTitle] = tasksMatchingActiveFilters.filter(task => task.priority === priorityConstant).length;
            });
            return counts;
        }, [tasksMatchingActiveFilters]);

        // These counts are for the custom tag filter buttons.
        // They should reflect how many tasks *within the currently filtered set* have each custom tag.
        const customTagFilterCountsForDisplay = useMemo(() => {
            const counts = {};
            const customTagsToDisplay = allTags.filter(tag => !PRIORITY_DISPLAY_TITLES_ARRAY.includes(tag));
            customTagsToDisplay.forEach(tag => {
                counts[tag] = tasksMatchingActiveFilters.filter(task => task.tags && task.tags.includes(tag)).length;
            });
            return counts;
        }, [tasksMatchingActiveFilters, allTags]);

        const { swimlaneTasks, unclassifiedTasks } = useMemo(() => { // Renamed priorityTasks to unclassifiedTasks
            const st = {};
            const ut = []; // unclassifiedTasks

            const taskSorter = (a, b) => {
                if (showCompleted) {
                    return new Date(b.timestamp) - new Date(a.timestamp); // Newest completed first
                } else {
                    return (a.rank ?? Infinity) - (b.rank ?? Infinity); 
                }
            };

            for (const task of tasksMatchingActiveFilters) {
                let inSwimlane = false;
                
                for (const swimlaneName of activeSwimlanes) { 
                    const isPrioritySwimlane = PRIORITY_TITLE_TO_CONSTANT_MAP[swimlaneName];
                    let matchesSwimlane = false;

                    if (isPrioritySwimlane) {
                        matchesSwimlane = task.priority === PRIORITY_TITLE_TO_CONSTANT_MAP[swimlaneName];
                    } else {
                        matchesSwimlane = task.tags && task.tags.includes(swimlaneName);
                    }

                    if (matchesSwimlane) {
                        if (!st[swimlaneName]) st[swimlaneName] = [];
                        st[swimlaneName].push(task);
                        inSwimlane = true;
                        break; // Task assigned, move to the next task
                    }
                }

                if (!inSwimlane) {
                    ut.push(task);
                }
            }

            // Sort unclassified tasks
            ut.sort(taskSorter);

            // Sort tasks within each swimlane
            for (const swimlaneName in st) {
                st[swimlaneName].sort(taskSorter);
            }
            return { swimlaneTasks: st, unclassifiedTasks: ut };
        }, [tasksMatchingActiveFilters, activeSwimlanes, showCompleted, PRIORITY_TITLE_TO_CONSTANT_MAP]);

        const mainLayoutClasses = settings.verticalLayout ? 'flex-col space-y-4' : 'flex-row space-x-4';
        const backgroundOverlayClass = showCompleted ? 'bg-green-900/10' : '';
        
        return (
            <div className="h-screen w-screen font-sans flex flex-col overflow-x-hidden" style={{ background: `radial-gradient(circle, rgba(15, 23, 42, 0.9), rgba(10, 15, 30, 1)), linear-gradient(135deg, #0f172a 0%, #1e293b 100%)` }}>
                
                {taskToComplete && <CompleteConfirmationModal task={taskToComplete} onConfirm={handleConfirmComplete} onCancel={() => setTaskToComplete(null)} />}
                {taskToDelete && <DeleteConfirmationModal onConfirm={handleConfirmDelete} onCancel={() => setTaskToDelete(null)} />}
                {showSettings && <SettingsModal settings={settings} onSettingsChange={setSettings} onClose={() => setShowSettings(false)} />}
                {showSwimlaneModal && <ManageSwimlanesModal allTags={allTags} activeSwimlanes={activeSwimlanes} setSwimlanes={setActiveSwimlanes} onClose={() => setShowSwimlaneModal(false)} />}
                {showDeleteAllCompletedModal && <DeleteAllCompletedModal onConfirm={handleConfirmDeleteAllCompleted} onCancel={() => setShowDeleteAllCompletedModal(false)} count={completedTasksCount} />}
                {showSummaryModal && <SummaryModal summary={summaryText} onClose={() => setShowSummaryModal(false)} />}
                {showReleaseNotesModal && <ReleaseNotesModal version={CURRENT_APP_VERSION} releaseInfo={RELEASE_NOTES[CURRENT_APP_VERSION]} onClose={handleCloseReleaseNotes} />}
                
                <header className="sticky top-0 z-10 p-4 bg-slate-900/70 backdrop-blur-md shadow-lg flex flex-col space-y-3">
                    {/* --- Top Row: Title & Clock --- */}
                    <div className="flex justify-between items-center w-full">
                        <div className="flex items-center space-x-4">
                            <TaikoLogo />
                            <div>
                                <h1 className="text-3xl font-bold" style={{ color: '#E0E7FF', textTransform: 'uppercase', letterSpacing: '0.2em' }}>Taiko</h1>
                                <p className="text-slate-400 text-sm">Operations Task Master</p>
                            </div>
                        </div>
                        <div className="flex-shrink-0">
                            <LiveClock timezone={clockTimezone} onTimezoneChange={handleTimezoneChange} />
                        </div>
                    </div>

                    {/* --- Bottom Row: Toolbar --- */}
                    <div className="flex items-center w-full flex-wrap gap-2">
                        <div className="flex items-center flex-wrap gap-2">
                            <Tooltip text="Settings"><button onClick={() => setShowSettings(true)} className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><SettingsIcon /></button></Tooltip>
                            <Tooltip text="Report Issue or Submit Feedback"><a href="https://github.com/closedloopchaos/taiko/issues/new/choose" target="_blank" rel="noopener noreferrer" className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><BugIcon /></a></Tooltip>
                            <Tooltip text="Generate Summary of Completed Tasks"><button onClick={generateCompletedTasksSummary} className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><DocumentTextIcon /></button></Tooltip>
                            <Tooltip text="Delete All Completed Tasks">
                                {showCompleted && completedTasksCount > 0 && (
                                    <button onClick={() => setShowDeleteAllCompletedModal(true)} className="p-2 text-red-400 hover:text-white rounded-full hover:bg-red-500 transition-colors"><DeleteIcon /></button>
                                )}
                            </Tooltip>
                        </div>
                        
                        <div className="flex-grow"></div>

                        <div className="flex items-center flex-wrap gap-2">
                            <Tooltip text={showCompleted ? "View Active Tasks" : "View Completed Tasks"}>
                                <button onClick={handleCompletedClick} className={`px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:bg-slate-600 focus:outline-none focus:ring-2 focus:ring-slate-500 transition-all ${showCompleted ? 'bg-green-600 hover:bg-green-500 focus:ring-green-400' : 'bg-slate-700'}`}>{showCompleted ? 'View Active' : 'View Completed'}</button>
                            </Tooltip>
                            {showMainAddTaskInput ? (
                                <QuickAddInputForm onAdd={(title) => { addTask(title); setShowMainAddTaskInput(false); }} onCancel={() => setShowMainAddTaskInput(false)} />
                            ) : (
                                <AddTaskButton onAddTask={handleAddTask} />
                            )}
                        </div>
                    </div>
                </header>
                
                <div className="px-6 py-2 flex-shrink-0 border-b border-slate-800 flex justify-between items-center flex-wrap gap-2">
                    <div className="flex items-center space-x-2 flex-wrap">
                        <Tooltip text="Show all tasks (clear tag filters)">
                            <button onClick={clearTagFilter} // This button clears all activeTags, including priority titles
                                    className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${activeTags.length === 0 ? 'bg-sky-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>
                                    All <span className="opacity-80"> ({allTasksCountForFilterDisplay})</span>
                                </button>
                        </Tooltip>
                        {/* Render Priority Filter Buttons First in Specific Order */}
                        {DISPLAY_PRIORITY_ORDER.map(priorityConstant => {
                            const displayTitle = PRIORITY_CONFIG[priorityConstant].title;
                            return (
                                <Tooltip key={displayTitle} text={`Filter by priority: ${displayTitle}`}>
                                    <button 
                                        onClick={() => handleTagFilterClick(displayTitle)}
                                        className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${activeTags.includes(displayTitle) ? `${PRIORITY_CONFIG[priorityConstant].bgColor} text-white` : 'text-slate-400 hover:bg-slate-700/50'}`}
                                    >
                                        {displayTitle} <span className="opacity-80">({priorityFilterCountsForDisplay[displayTitle] || 0})</span>
                                    </button>
                                </Tooltip>
                            );
                        })}
                        {allTags.length > 0 && (
                            <div className="border-l border-slate-700 h-5"></div>
                        )}
                        {/* Render Other Tag Filters (excluding priority display titles) */}
                        {allTags.map(tag => ( // allTags is now already filtered to be custom tags only
                            <Tooltip key={tag} text={`Filter by custom tag: ${tag}`}>
                                <button onClick={() => handleTagFilterClick(tag)}
                                    className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${activeTags.includes(tag) ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>
                                    {tag} <span className="opacity-80"> ({customTagFilterCountsForDisplay[tag] || 0})</span>
                                </button>
                            </Tooltip>
                        ))}
                    </div>
                    <Tooltip text="Configure custom tag-based swimlane columns">
                        <button onClick={() => setShowSwimlaneModal(true)} className="text-sm text-slate-400 hover:text-white bg-slate-700/50 px-3 py-1 rounded-md">Manage Swimlanes</button>
                    </Tooltip>
                </div>

                <main className={`flex-grow p-4 pt-4 flex overflow-auto transition-all duration-300 ${mainLayoutClasses} ${backgroundOverlayClass}`}>
                    {showCompleted ? (
                        <PriorityColumn
                            key="completed-column"
                            titleOverride="Completed Tasks"
                            priority={null}
                            tasks={tasksMatchingActiveFilters}
                            isCollapsed={false}
                            onToggleCollapse={() => {}}
                            showCompleted={showCompleted}
                            isVerticalLayout={settings.verticalLayout}
                            clockTimezone={clockTimezone}
                            isSwimlane={false}
                            disableQuickAdd={true}
                        />
                    ) : (
                        <>
                            {/* --- "New Tasks" Column (replaces Triage) --- */}
                            {(() => { // This column displays unclassifiedTasks
                                const unsortedTasksToDisplay = unclassifiedTasks;
                                const isEffectivelyCollapsedUnsorted = (settings.autoCollapse && unsortedTasksToDisplay.length === 0) ? true : (collapsedColumns['unsorted'] || false);
                                
                                // Render if tasks exist, OR if no filters are active and it's not effectively collapsed
                                const shouldRenderUnsortedColumn = unsortedTasksToDisplay.length > 0 || (activeTags.length === 0 && !isEffectivelyCollapsedUnsorted);

                                if (shouldRenderUnsortedColumn) {
                                    return (
                                        <PriorityColumn
                                            key="unsorted-column"
                                            titleOverride="Unsorted" // Updated title
                                            priority={null} // Base styling on unprioritized, but title is overridden
                                            tasks={unsortedTasksToDisplay}
                                            isCollapsed={isEffectivelyCollapsedUnsorted}
                                            onToggleCollapse={() => setCollapsedColumns(p => ({ ...p, 'unsorted': !p['unsorted'] }))}
                                            showCompleted={showCompleted}
                                            isVerticalLayout={settings.verticalLayout}
                                            clockTimezone={clockTimezone}
                                            isSwimlane={false} // Indicate this is a primary column
                                        /> );
                                } return null;
                            })()}
                            {activeSwimlanes.map(item => { // Iterate over all active swimlanes (tags or priority display titles)
                                const tasksForThisSwimlane = swimlaneTasks[item] || [];
                                const isManuallyCollapsed = collapsedTagSwimlanes[item] || false;
                                const isEffectivelyCollapsedTag = (settings.autoCollapse && tasksForThisSwimlane.length === 0) ? true : isManuallyCollapsed;

                                // Render if tasks exist, OR if no filters are active and it's not effectively collapsed
                                const shouldRenderTagColumn = tasksForThisSwimlane.length > 0 || (activeTags.length === 0 && !isEffectivelyCollapsedTag);

                                if (!shouldRenderTagColumn) {
                                    return null; // Hide the column if filters make it empty, or if no filters and it's effectively collapsed
                                }

                                // All active swimlanes (including those named "High", "Medium", "Low")
                                // will now be rendered by TagColumn.
                                // The "Unsorted" column is handled separately above.
                                return (
                                    <div
                                        key={item}
                                        draggable={!settings.verticalLayout} // Only allow drag in horizontal mode for now
                                        onDragStart={(e) => !settings.verticalLayout && handleDragStartSwimlane(e, item)}
                                        onDragOver={!settings.verticalLayout ? handleDragOverSwimlane : undefined}
                                        onDrop={() => !settings.verticalLayout && handleDropSwimlane(item)}
                                        className={`transition-opacity duration-200 ${draggedSwimlane === item ? 'opacity-30' : 'opacity-100'} ${settings.verticalLayout ? 'w-full' : 'flex-1 min-w-0'}`}
                                    >
                                        <TagColumn 
                                            tag={item} // 'item' is the swimlane name, e.g., "ProjectX" or "High"
                                            tasks={tasksForThisSwimlane} 
                                            clockTimezone={clockTimezone}
                                            isCollapsed={isEffectivelyCollapsedTag}
                                            onToggleCollapse={() => toggleSwimlaneCollapse(item)}
                                            isVerticalLayout={settings.verticalLayout}
                                            isBeingDragged={draggedSwimlane === item}
                                        />
                                    </div>
                                );
                            })}
                        </>
                    )}
                </main>
                <Footer onShowReleaseNotes={() => setShowReleaseNotesModal(true)} />
            </div>
        );
    };

    // --- Column & Modal Components ---
    const PriorityColumn = React.memo(({ priority, tasks, isCollapsed, onToggleCollapse, showCompleted, isVerticalLayout, clockTimezone, isSwimlane = false, titleOverride = null, disableQuickAdd = false }) => {
        const { addTask } = useAppContext();
        const [showQuickAdd, setShowQuickAdd] = useState(false); // State to show/hide quick add input

        const columnLayoutClasses = isVerticalLayout ? 'w-full h-auto' : 'flex-1 min-w-0 h-full';
        const config = PRIORITY_CONFIG[priority] || PRIORITY_CONFIG.null; // 'priority' can be PRIORITIES.LOW or null

        let displayTitleText = titleOverride || config.title;
        if (isSwimlane && !titleOverride && config.title !== PRIORITY_CONFIG.null.title) {
            displayTitleText = `${config.title} Priority`;
        } // "Unsorted" will use titleOverride

        const headerColorClass = titleOverride ? (isSwimlane ? 'text-slate-300' : 'text-slate-200') : config.color; // Generic color for "New Tasks", specific for priorities


        const headerContent = (
            <>
                <span className="truncate">{displayTitleText} ({tasks.length})</span>
                {isVerticalLayout && ( // Only show chevron in vertical mode
                    <ChevronDownIcon className={`transform transition-transform duration-200 ${isCollapsed ? '-rotate-90' : 'rotate-0'}`} />
                )}
            </>
        );
        
        const handleQuickAddTask = (titleFromInput) => {
            if (!titleFromInput.trim()) { setShowQuickAdd(false); return; }

            let taskPriorityToAdd = null;
            let taskTagsToAdd = []; // Default for "Unsorted" or priority columns

            if (titleOverride) { // "New Tasks" column
                taskPriorityToAdd = null;
                taskTagsToAdd = [];
            } else if (priority) { // Priority swimlane
                taskPriorityToAdd = priority; // The actual priority constant like PRIORITIES.LOW
                taskTagsToAdd = []; // DO NOT add the priority display title to tags array
            }
            
            addTask(titleFromInput.trim(), taskPriorityToAdd, taskTagsToAdd);
            setShowQuickAdd(false);
        };


        return (
            <div className={`flex flex-col rounded-lg ${columnLayoutClasses} ${isSwimlane ? 'bg-slate-900/40 border border-slate-700/60' : (titleOverride ? 'bg-slate-800/50 border border-slate-700/50' : 'bg-slate-900/30')}`}>
                {isVerticalLayout ? ( // Clickable header for vertical layout
                    <Tooltip text={isCollapsed ? "Expand column" : "Collapse column"}>
                        <button 
                            onClick={onToggleCollapse} 
                            className={`flex items-center w-full text-left text-lg font-bold p-2 rounded-t-lg ${headerColorClass} ${isSwimlane ? 'bg-slate-800/70 hover:bg-slate-700/70' : (titleOverride ? 'bg-slate-700/60 hover:bg-slate-600/60' : 'hover:bg-slate-700/50')} flex-shrink-0 transition-colors`}
                        >
                            <div className="flex-grow min-w-0">{headerContent}</div>
                            {!isCollapsed && !showQuickAdd && !disableQuickAdd && (
                                <Tooltip text={`Quick add to ${displayTitleText}`}>
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); setShowQuickAdd(true); }} 
                                        className="ml-2 p-1 rounded-full hover:bg-slate-600/50 flex-shrink-0"
                                    >
                                        <PlusIcon />
                                    </button>
                                </Tooltip>
                            )}
                        </button>
                    </Tooltip>
                ) : ( // Static header for horizontal layout
                    <div className={`flex items-center w-full text-left text-lg font-bold p-2 rounded-t-lg ${headerColorClass} ${isSwimlane ? 'bg-slate-800/70' : (titleOverride ? 'bg-slate-700/60' : 'bg-slate-900/60')} flex-shrink-0`}>
                        <div className="flex-grow min-w-0">{headerContent}</div>
                        {!showQuickAdd && !disableQuickAdd && (
                             <Tooltip text={`Quick add to ${displayTitleText}`}>
                                <button 
                                    onClick={() => setShowQuickAdd(true)} 
                                    className="ml-2 p-1 rounded-full hover:bg-slate-600/50 flex-shrink-0"
                                >
                                    <PlusIcon />
                                </button>
                            </Tooltip>
                        )}
                    </div>
                )}
                {showQuickAdd && !isCollapsed && (
                    <QuickAddInputForm onAdd={handleQuickAddTask} onCancel={() => setShowQuickAdd(false)} />
                )}
                <div className={`
                    flex-grow p-2 transition-all duration-300 ease-in-out overflow-x-hidden
                    ${isVerticalLayout ? 
                        (isCollapsed ? 'max-h-0 py-0 opacity-0' : 'opacity-100') :
                        'max-h-full opacity-100 overflow-y-auto'
                    }
                `}>
                    {tasks.map((task) => (
                        <div key={task.id} className="w-full min-w-0">
                            <MemoizedTaskCard task={task} clockTimezone={clockTimezone} />
                        </div>
                    ))}
                </div>
            </div>
        );
    });

    const TagColumn = React.memo(({ tag, tasks, clockTimezone, isCollapsed, onToggleCollapse, isVerticalLayout, isBeingDragged }) => {
        const { addTask } = useAppContext();
        const [showQuickAdd, setShowQuickAdd] = useState(false); // State to show/hide quick add input

        const columnLayoutClasses = isVerticalLayout ? 'w-full h-auto' : 'flex-1 min-w-0 h-full';
        const dragStyle = isBeingDragged ? 'border-dashed border-sky-500' : 'border-indigo-800/50';

        const headerContent = (
            <>
                <span className="truncate">{tag} ({tasks.length})</span>
                {isVerticalLayout && <ChevronDownIcon className={`transform transition-transform duration-200 ${isCollapsed ? '-rotate-90' : 'rotate-0'}`} />} {/* Chevron only in vertical layout */}
            </>
        );

        const handleQuickAddTask = (titleFromInput) => {
            if (!titleFromInput.trim()) { setShowQuickAdd(false); return; }

            const priorityConstant = PRIORITY_TITLE_TO_CONSTANT_MAP[tag];

            if (priorityConstant) {
                addTask(titleFromInput.trim(), priorityConstant, []); // Set priority, no tags
            } else {
                addTask(titleFromInput.trim(), null, [tag]); // Null priority, add custom tag
            }
            setShowQuickAdd(false);
        };

        return (
            <div className={`flex flex-col overflow-x-hidden bg-indigo-900/20 backdrop-blur-sm border rounded-lg ${columnLayoutClasses} ${dragStyle} transition-all`}>
                {isVerticalLayout ? ( // Clickable header for vertical layout
                    <Tooltip text={isCollapsed ? "Expand column" : "Collapse column"}>
                        <button
                            onClick={onToggleCollapse}
                            className={`flex items-center w-full text-left text-lg font-bold p-2 rounded-t-lg text-indigo-300 bg-slate-900/60 hover:bg-slate-800/80 flex-shrink-0 transition-colors ${isBeingDragged ? 'cursor-grabbing' : 'cursor-pointer'}`}
                        >
                            <div className="flex-grow min-w-0">{headerContent}</div>
                            {!isCollapsed && !showQuickAdd && (
                                <Tooltip text={`Quick add to ${tag}`}>
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); setShowQuickAdd(true); }} 
                                        className="ml-2 p-1 rounded-full hover:bg-slate-800/50 flex-shrink-0"
                                    >
                                        <PlusIcon />
                                    </button>
                                </Tooltip>
                            )}
                        </button>
                    </Tooltip>
                ) : (
                    <div className={`flex justify-between items-center w-full text-left text-lg font-bold p-2 rounded-t-lg text-indigo-300 bg-slate-900/60 flex-shrink-0 ${isBeingDragged ? 'cursor-grabbing' : 'cursor-grab'}`}>
                        <div className="flex-grow min-w-0">{headerContent}</div>
                         {!showQuickAdd && (
                            <Tooltip text={`Quick add to ${tag}`}>
                                <button 
                                    onClick={() => setShowQuickAdd(true)} 
                                    className="ml-2 p-1 rounded-full hover:bg-slate-800/50 flex-shrink-0"
                                >
                                    <PlusIcon />
                                </button>
                            </Tooltip>
                        )}
                    </div>
                )}
                {showQuickAdd && !isCollapsed && (
                    <QuickAddInputForm onAdd={handleQuickAddTask} onCancel={() => setShowQuickAdd(false)} />
                )}
                <div className={`
                    flex-grow p-2 overflow-x-hidden transition-all duration-300 ease-in-out
                    ${isVerticalLayout ?
                        (isCollapsed ? 'max-h-0 py-0 opacity-0' : 'opacity-100') :
                        'max-h-full opacity-100 overflow-y-auto'
                    }
                `}>
                    {tasks.map(task => ( 
                        <div key={task.id} className="w-full min-w-0">
                            <MemoizedTaskCard task={task} clockTimezone={clockTimezone} />
                        </div>
                    ))}
                </div>
            </div>
        );
    });

    const Footer = React.memo(({ onShowReleaseNotes }) => {
        return (
            <footer className="bg-slate-900/80 backdrop-blur-sm p-3 text-center text-sm text-slate-400 shadow-t-lg z-40 flex-shrink-0">
                <div className="flex items-center justify-center space-x-4">
                    <div className="flex items-center justify-center space-x-1.5">
                        <span>Courtesy of</span>
                        <a href="https://github.com/closedloopchaos" target="_blank" rel="noopener noreferrer" className="inline-flex items-center text-sky-400 hover:text-sky-300 font-semibold hover:underline">
                            <svg className="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 16 16" aria-hidden="true">
                                <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
                            </svg>
                            closedloopchaos
                        </a>
                    </div>
                    <div className="border-l border-slate-600 h-5"></div>
                    <button onClick={onShowReleaseNotes} className="text-sky-400 hover:text-sky-300 font-semibold hover:underline">
                        Release Notes (v{CURRENT_APP_VERSION})
                    </button>
                </div>
            </footer>
        );
    });

    const QuickAddInputForm = React.memo(({ onAdd, onCancel, placeholder = "New task title..." }) => {
        const [internalValue, setInternalValue] = useState('');
        const inputRef = useRef(null);

        useEffect(() => {
            if (inputRef.current) inputRef.current.focus();
        }, []);

        const handleSubmit = () => {
            const trimmedValue = internalValue.trim();
            if (trimmedValue) {
                onAdd(trimmedValue);
                setInternalValue(''); // Reset for next potential use if not hidden immediately
            } else {
                // If input is empty and Enter/Add is pressed, effectively cancel.
                onCancel();
            }
        };

        return (
            <div className="p-2 border-b border-slate-700/50 bg-slate-800/30">
                <input
                    ref={inputRef}
                    type="text"
                    value={internalValue}
                    onChange={e => setInternalValue(e.target.value)}
                    onKeyDown={e => { if (e.key === 'Enter') handleSubmit(); if (e.key === 'Escape') onCancel(); }}
                    placeholder={placeholder}
                    className="w-full bg-slate-900/80 text-slate-200 text-sm p-2 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500"
                />
                <div className="mt-2 flex justify-end space-x-2">
                    <button onClick={onCancel} className="px-3 py-1 text-xs bg-slate-600 hover:bg-slate-500 rounded-md">Cancel</button>
                    <button onClick={handleSubmit} className="px-3 py-1 text-xs bg-sky-600 hover:bg-sky-500 rounded-md">Add Task</button>
                </div>
            </div>
        );
    });

    const AddTaskButton = React.memo(({ onAddTask }) => {
        return (
            <div className="relative">
                <Tooltip text="Add a new task">
                    <button 
                        onClick={onAddTask} 
                        className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg shadow-md hover:bg-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-opacity-75 transition-all"
                    >
                        + Add Task
                    </button>
                </Tooltip>
            </div>
        );
    });

    const Modal = ({ children, onClose }) => <div onClick={onClose} className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4">{children}</div>;
    const ModalContent = ({ title, children, onClose, headerActions }) => (
        <div 
            className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-md text-white flex flex-col" // Removed max-h-[85vh]
            onClick={e => e.stopPropagation()}
        >
            <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                <h3 className="text-xl font-bold">{title}</h3>
                {headerActions && <div>{headerActions}</div>}
            </div>
            <div className="px-3 py-4">{children}</div> {/* Adjusted padding: px-3 py-4. Removed overflow-y-auto and flex-grow */}
        </div>
    );
    const CompleteConfirmationModal = ({ task, onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Mark Task as Complete?</h3><p className="text-slate-300 mb-4">This will move the task "{task.title}" to the completed view.</p><div className="flex justify-center space-x-4"><Tooltip text="Keep task active"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button></Tooltip><Tooltip text="Confirm completion"><button onClick={onConfirm} className="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-500">Mark as Complete</button></Tooltip></div></div></Modal>;
    const DeleteConfirmationModal = ({ onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Delete Task?</h3><p className="text-slate-300 mb-4">Are you sure you want to permanently delete this task?</p><div className="flex justify-center space-x-4"><Tooltip text="Cancel deletion"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button></Tooltip><Tooltip text="Confirm permanent deletion"><button onClick={onConfirm} className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-500">Delete</button></Tooltip></div></div></Modal>;
    const DeleteAllCompletedModal = ({ onConfirm, onCancel, count }) => (
        <Modal onClose={onCancel}>
            <div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Delete All Completed Tasks?</h3><p className="text-slate-300 mb-4">Are you sure you want to permanently delete all {count} completed tasks? This action cannot be undone.</p><div className="flex justify-center space-x-4"><Tooltip text="Cancel deletion"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button></Tooltip><Tooltip text="Confirm permanent deletion of all completed tasks"><button onClick={onConfirm} className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-500">Delete All</button></Tooltip></div></div>
        </Modal>
    );
    const SettingsModal = ({ settings, onSettingsChange, onClose }) => { 
        const handleToggle = (key) => onSettingsChange(p => ({ ...p, [key]: !p[key] })); 
        return ( 
            <Modal onClose={onClose}>
                <ModalContent title="Settings" onClose={onClose}>
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Confirm on Delete</label>
                            <Tooltip text={settings.confirmOnDelete ? "Disable delete confirmation" : "Enable delete confirmation"}>
                                <button onClick={() => handleToggle('confirmOnDelete')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.confirmOnDelete ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.confirmOnDelete ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Show Tooltips</label>
                            <Tooltip text={settings.showTooltips ? "Disable Tooltips" : "Enable Tooltips"}>
                                <button onClick={() => handleToggle('showTooltips')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.showTooltips ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.showTooltips ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Auto-collapse Empty Columns</label>
                            <Tooltip text={settings.autoCollapse ? "Disable auto-collapse" : "Enable auto-collapse"}>
                                <button onClick={() => handleToggle('autoCollapse')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.autoCollapse ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.autoCollapse ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Stack Columns Vertically</label>
                            <Tooltip text={settings.verticalLayout ? "Switch to horizontal layout" : "Switch to vertical layout"}>
                                <button onClick={() => handleToggle('verticalLayout')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.verticalLayout ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.verticalLayout ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                    </div>
                </ModalContent>
            </Modal> 
        );
    };

    const ManageSwimlanesModal = ({ allTags, activeSwimlanes, setSwimlanes, onClose }) => {
        const handleToggle = (tag) => {
            setSwimlanes(prev =>
                prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag]
            );
        };
        // allTags from context is now already just custom tags, sorted.
        const manageableTags = allTags; 

        const doneButton = (
            <Tooltip text="Close swimlane management">
                <button onClick={onClose} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500 text-sm">Done</button>
            </Tooltip>
        );

        return (
            <Modal onClose={onClose}>
                <ModalContent title="Manage Swimlanes" onClose={onClose} headerActions={doneButton}>
                    <p className="text-sm text-slate-400 mb-4">Select custom tags to create dedicated swimlane columns. Priority-based columns are managed by task priority settings, not here.</p>
                    <div className="space-y-2">
                        {manageableTags.map(tag => (
                            <div key={tag} className="flex items-center justify-between p-2 bg-slate-700/50 rounded-md">
                                <label className="text-slate-300">{tag}</label>
                                <Tooltip text={activeSwimlanes.includes(tag) ? `Disable swimlane for '${tag}'` : `Enable swimlane for '${tag}'`}>
                                    <button onClick={() => handleToggle(tag)} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${activeSwimlanes.includes(tag) ? 'bg-indigo-500' : 'bg-slate-600'}`}>
                                        <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${activeSwimlanes.includes(tag) ? 'translate-x-6' : 'translate-x-1'}`} />
                                    </button>
                                </Tooltip>
                            </div>
                        ))}
                        {manageableTags.length === 0 && (
                            <p className="text-sm text-slate-500 italic">No custom tags found to create swimlanes from. Add custom tags to your tasks first.</p>
                        )}
                    </div>
                    {/* "Done" button is now in the header via headerActions */}
                </ModalContent>
            </Modal>
        );
    };

    const SummaryModal = ({ summary, onClose }) => {
        const [copyButtonText, setCopyButtonText] = useState('Copy to Clipboard');

        const handleCopy = useCallback(() => {
            if (!navigator.clipboard) {
                console.error('Clipboard API not available.');
                setCopyButtonText('Copy failed');
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
                return;
            }
            navigator.clipboard.writeText(summary).then(() => {
                setCopyButtonText('Copied!');
                playTone(880, 0.1, 'sine', 0.2); // Success sound
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                setCopyButtonText('Failed to copy');
                playTone(220, 0.2, 'square', 0.2); // Error sound
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
            });
        }, [summary]);

        return (
            <Modal onClose={onClose}>
                <div className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-3xl text-white flex flex-col overflow-x-hidden max-h-[90vh]" onClick={e => e.stopPropagation()}>
                    <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                        <h3 className="text-xl font-bold">Completed Tasks Summary</h3>
                        <div className="flex items-center space-x-2">
                            <Tooltip text="Copy summary to your clipboard">
                                <button onClick={handleCopy} className="px-3 py-1 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500 text-sm transition-all duration-150 w-36 text-center">{copyButtonText}</button>
                            </Tooltip>
                            <Tooltip text="Close this summary">
                                <button onClick={onClose} className="px-4 py-1 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500 text-sm">Done</button>
                            </Tooltip>
                        </div>
                    </div>
                    <div className="p-4 overflow-y-auto"><pre className="text-sm text-slate-300 whitespace-pre-wrap font-mono bg-slate-900/50 p-4 rounded-md border border-slate-700">{summary}</pre></div>
                </div>
            </Modal>
        );
    };

    const ReleaseNotesModal = ({ version, releaseInfo, onClose }) => {
        if (!releaseInfo) return null;

        return (
            <Modal onClose={onClose}>
                <div className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-2xl text-white flex flex-col max-h-[90vh]" onClick={e => e.stopPropagation()}>
                    <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                        <h3 className="text-xl font-bold">{releaseInfo.title}</h3>
                        <Tooltip text="Close Release Notes">
                            <button onClick={onClose} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500 text-sm">Got it!</button>
                        </Tooltip>
                    </div>
                    <div className="p-6 overflow-y-auto space-y-4">
                        {releaseInfo.notes.map((note, index) => (
                            <div key={index} className="bg-slate-900/50 p-4 rounded-lg border border-slate-700">
                                <h4 className="font-bold text-sky-300 mb-1">{note.title}</h4>
                                <p className="text-sm text-slate-300">{note.description}</p>
                            </div>
                        ))}
                    </div>
                </div>
            </Modal>
        );
    };

    // --- App Entry Point ---
    const AppContainer = () => {
        return <App />;
    };

    const TaikoApp = () => {
        return (
            <AppProvider>
                <AppContainer />
            </AppProvider>
        );
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<TaikoApp />);

    </script>
</body>
</html>
