<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taiko Task Master</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom CSS for animations and theming -->
    <style>
        body {
            font-family: sans-serif;
            background-color: #0f172a; /* Fallback background */
        }
        .pulse-border-high { animation: pulse-border-high 1.2s infinite; }
        @keyframes pulse-border-high { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0.9); } 
            50% { box-shadow: 0 0 0 6px rgba(248, 113, 113, 0); } 
        }
        .pulse-border-medium { animation: pulse-border-medium 1.8s infinite; }
        @keyframes pulse-border-medium { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.8); } 
            50% { box-shadow: 0 0 0 5px rgba(251, 191, 36, 0); } 
        }
        .pulse-border-low { animation: pulse-border-low 2.5s infinite; }
        @keyframes pulse-border-low { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.7); } 
            50% { box-shadow: 0 0 0 4px rgba(56, 189, 248, 0); } 
        }
        .pulse-border-default { animation: pulse-border-default 2s infinite; }
        @keyframes pulse-border-default { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(100, 116, 139, 0.7); } /* slate-500 like for default pulse */
            50% { box-shadow: 0 0 0 5px rgba(100, 116, 139, 0); } 
        }
	:root {
	    --scrollbar-background: #273346;
            --scrollbar-thumb-background: #394b67;
            --scrollbar-thumb-border: #333;
            --scrollbar-track-background: #273346;
        }
        
        /* Style the scrollbar */
	::-webkit-scrollbar {
	    width: 8px;
	    height: 8px;
	}

        ::-webkit-scrollbar-thumb {
	    background-color: var(--scrollbar-thumb-background);
            border: 1px solid var(--scrollbar-thumb-border);
	    border-radius: 4px;
	}

	::-webkit-scrollbar-track {
	    background-color: var(--scrollbar-track-background);
	}

	::-webkit-scrollbar-corner {
	    background-color: var(--scrollbar-background);
	}

        #node-garden-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Places the canvas behind all other content */
        }
    </style>
</head>
<body>
    <canvas id="node-garden-canvas"></canvas>
    <div id="root"></div>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel Standalone for JSX Transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Main Application Logic -->
    <script type="text/babel">

    const { useState, useEffect, useRef, useCallback, createContext, useContext, useMemo } = React;


    // -----------------------------------------------------------------------------------------------------------------------------  THIS IS WHERE THE RELEASE NOTES ARE -----------------------------------------------------------------------------------------------------------------------------
    // --- Global Constants & Configurations ---
    const CURRENT_APP_VERSION = '1.2.0';

    const RELEASE_NOTES = {
        '1.2.0': {
            title: "What's New in Version 1.2.0",
            notes: [
                {
                    title: "🎨 Major UI Redesign: Task Cards",
                    description: "Task cards have been completely redesigned for better clarity and functionality, featuring a cleaner layout and a new way to manage status."
                },
                {
                    title: "📝 Feature: Detailed Task Notes",
                    description: "You can now add, edit, and view multi-line notes directly within each task card. The notes section is expandable and auto-saves your content."
                },
                {
                    title: "🚀 Feature: Completed Task Summary",
                    description: "Generate a detailed, timezone-aware summary of all completed tasks, including their notes and subtasks. Find the new document icon in the header!"
                }
            ]
        }
        // Future versions can be added here
    };


    const PRIORITIES = { // These are the internal constant values
        LOW: 'PRIORITY_LOW', // Actual tag string
        MEDIUM: 'PRIORITY_MEDIUM',
        HIGH: 'PRIORITY_HIGH'
    };

    const getPrioritySortValue = (priority) => {
        if (priority === PRIORITIES.HIGH) return 0;
        if (priority === PRIORITIES.MEDIUM) return 1;
        if (priority === PRIORITIES.LOW) return 2;
        return 3; // For null or undefined priority (Unprioritized)
    };

    // PRIORITY_CONFIG must be defined after PRIORITIES and before constants that use it.
    // We will add sound generation parameters here later if needed, or handle in the playSound function.
    const PRIORITY_CONFIG = {
        [PRIORITIES.LOW]: { title: "Low", color: "text-sky-400", bgColor: "bg-sky-500/20", borderColor: "border-sky-500", pulseClass: 'pulse-border-low' },
        [PRIORITIES.MEDIUM]: { title: "Medium", color: "text-yellow-400", bgColor: "bg-yellow-500/20", borderColor: "border-yellow-500", pulseClass: 'pulse-border-medium' },
        [PRIORITIES.HIGH]: { title: "High", color: "text-red-400", bgColor: "bg-red-500/20", borderColor: "border-red-500", pulseClass: 'pulse-border-high' },
        null: { title: "Unprioritized", color: "text-slate-400", bgColor: "bg-slate-500/10", borderColor: "border-slate-600", pulseClass: 'pulse-border-default' } // For null priority
    };

    // Now define constants that depend on PRIORITIES and PRIORITY_CONFIG
    const PRIORITY_DISPLAY_TITLES_ARRAY = Object.values(PRIORITIES) // e.g., ["Low", "Medium", "High"]
        .map(pKey => PRIORITY_CONFIG[pKey]?.title)
        .filter(Boolean); // e.g., ["Low", "Medium", "High"]
    const PRIORITY_TITLE_TO_CONSTANT_MAP = Object.fromEntries( // e.g., { "Low": "PRIORITY_LOW", ... }
      Object.values(PRIORITIES).map(pConstant => [PRIORITY_CONFIG[pConstant]?.title, pConstant]).filter(([title]) => title)
    ); // e.g., { "Low": "PRIORITY_LOW", ... }

    const TASK_STATUS = { TO_DO: 'To Do', IN_PROGRESS: 'In Progress', ON_HOLD: 'On Hold', DONE: 'Done' };
    const TIMEZONE_MAP = { EST: 'America/New_York', PST: 'America/Los_Angeles', UTC: 'UTC' };
    const TIMEZONE_ORDER = ['EST', 'PST', 'UTC'];
    const TASK_STATUS_CONFIG = {
        [TASK_STATUS.TO_DO]: { 
            label: 'To Do', 
            selectBgColor: 'bg-sky-900/50', 
            accentClass: 'bg-sky-400',
            glowClass: 'shadow-[0_0_15px_-4px_rgba(56,189,248,0.5)] hover:shadow-[0_0_18px_-3px_rgba(56,189,248,0.7)]'
        },
        [TASK_STATUS.IN_PROGRESS]: { 
            label: 'In Progress', 
            selectBgColor: 'bg-yellow-900/50', 
            accentClass: 'bg-amber-400',
            glowClass: 'shadow-[0_0_15px_-4px_rgba(251,191,36,0.5)] hover:shadow-[0_0_18px_-3px_rgba(251,191,36,0.7)]'
        },
        [TASK_STATUS.ON_HOLD]: { 
            label: 'On Hold', 
            selectBgColor: 'bg-slate-700/50', 
            accentClass: 'bg-slate-500',
            glowClass: 'shadow-[0_0_15px_-4px_rgba(100,116,139,0.4)] hover:shadow-[0_0_18px_-3px_rgba(100,116,139,0.6)]'
        },
        [TASK_STATUS.DONE]: { 
            label: 'Done', 
            selectBgColor: 'bg-green-900/50', 
            accentClass: 'bg-green-500',
            glowClass: 'shadow-[0_0_12px_-5px_rgba(34,197,94,0.5)]' // More subtle glow for "Done"
        }
    };

    // --- Web Audio API Sound Generation ---
    let audioContext = null;
    const getAudioContext = () => {
        if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioContext;
    };

    const playTone = (frequency, duration = 0.5, type = 'sine', volume = 0.3) => {
        const actx = getAudioContext();
        if (!actx) {
            console.warn("Web Audio API is not supported in this browser.");
            return;
        }

        const oscillator = actx.createOscillator();
        const gainNode = actx.createGain();

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, actx.currentTime);
        gainNode.gain.setValueAtTime(volume, actx.currentTime);
        // Simple fade out to avoid clicking
        gainNode.gain.linearRampToValueAtTime(0.0001, actx.currentTime + duration - 0.05);

        oscillator.connect(gainNode);
        gainNode.connect(actx.destination);

        oscillator.start();
        oscillator.stop(actx.currentTime + duration);
    };

    // --- Context for State Management ---
    const AppContext = createContext(null);

    // --- Provider Component ---
    const AppProvider = ({ children }) => {
        // --- Core State ---
        const [tasks, setTasks] = useState([]);
        const [settings, setSettings] = useState({ 
            confirmOnDelete: true, 
            autoCollapse: true, // Default to true
        });

        // --- Modal-related State ---
        const [taskToComplete, setTaskToComplete] = useState(null);
        const [taskToDelete, setTaskToDelete] = useState(null);
        // --- UI Interaction State (lifted from App) ---
        const [showCompleted, setShowCompleted] = useState(false);
        const [activeTags, setActiveTags] = useState([]); // For filtering
        const [collapsedTagSwimlanes, setCollapsedTagSwimlanes] = useState({});
        const [collapsedColumns, setCollapsedColumns] = useState({ 'unsorted': false }); // For fixed columns like "Unsorted"

        const appId = 'taiko-app-local';

        // --- Local Storage Persistence ---
        useEffect(() => {
            const savedTasks = localStorage.getItem(`${appId}-tasks`);
            if (savedTasks) try { setTasks(JSON.parse(savedTasks)); } catch { console.error("Could not parse saved tasks."); }
            
            const defaultSettings = {
                confirmOnDelete: true,
                showTooltips: true,
                autoCollapse: true,
                animationSettings: { enabled: true, particleCount: 250, connectionDistance: 170, particleSpeed: 0.5 }
            };

            const savedSettings = localStorage.getItem(`${appId}-settings`);
            if (savedSettings) {
                try { 
                    const parsed = JSON.parse(savedSettings);
                    // Deep merge for animationSettings
                    const mergedSettings = {
                        ...defaultSettings, ...parsed,
                        animationSettings: { ...defaultSettings.animationSettings, ...(parsed.animationSettings || {}) }
                    };
                    setSettings(mergedSettings);
                } catch { 
                    console.error("Could not parse saved settings. Using defaults.");
                    setSettings(defaultSettings); // Fallback to defaults on parse error
                }
            } else {
                setSettings(defaultSettings); // No saved settings, use defaults
            }

            const savedShowCompleted = localStorage.getItem(`${appId}-showCompleted`);
            if (savedShowCompleted) try { setShowCompleted(JSON.parse(savedShowCompleted)); } catch { console.error("Could not parse saved showCompleted state."); setShowCompleted(false); }

            const savedActiveTags = localStorage.getItem(`${appId}-activeTags`);
            if (savedActiveTags) try { setActiveTags(JSON.parse(savedActiveTags)); } catch { console.error("Could not parse saved active tags."); setActiveTags([]); }

            const savedCollapsedTagSwimlanes = localStorage.getItem(`${appId}-collapsedTagSwimlanes`);
            if (savedCollapsedTagSwimlanes) try { setCollapsedTagSwimlanes(JSON.parse(savedCollapsedTagSwimlanes)); } catch { console.error("Could not parse saved collapsed tag swimlanes."); setCollapsedTagSwimlanes({}); }
            
            const defaultCollapsedColumns = { 'unsorted': false }; // Updated key
            const savedCollapsedColumns = localStorage.getItem(`${appId}-collapsedColumns`);
            if (savedCollapsedColumns) {
                try {
                    setCollapsedColumns(JSON.parse(savedCollapsedColumns));
                } catch {
                    console.error("Could not parse saved collapsed columns. Using defaults.");
                    setCollapsedColumns(defaultCollapsedColumns);
                }
            } else {
                setCollapsedColumns(defaultCollapsedColumns);
            }
        }, [appId]); 

        // --- Consolidated Local Storage Persistence ---
        useEffect(() => {
            try {
                localStorage.setItem(`${appId}-tasks`, JSON.stringify(tasks));
                localStorage.setItem(`${appId}-settings`, JSON.stringify(settings));
                localStorage.setItem(`${appId}-showCompleted`, JSON.stringify(showCompleted));
                localStorage.setItem(`${appId}-activeTags`, JSON.stringify(activeTags));
                localStorage.setItem(`${appId}-collapsedTagSwimlanes`, JSON.stringify(collapsedTagSwimlanes));
                localStorage.setItem(`${appId}-collapsedColumns`, JSON.stringify(collapsedColumns));
            } catch (error) {
                console.error("Failed to save state to localStorage", error);
            }
        }, [tasks, settings, showCompleted, activeTags, collapsedTagSwimlanes, collapsedColumns, appId]);

        // --- Effect to dispatch animation settings changes to the global scope ---
        useEffect(() => {
            const event = new CustomEvent('animationSettingsChange', { detail: settings.animationSettings });
            window.dispatchEvent(event);
        }, [settings.animationSettings]);

        // --- Notification Permission ---
        useEffect(() => {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }, []);

        // --- Derived State ---
        const currentTasks = useMemo(() => showCompleted ? tasks.filter(t => t.status === TASK_STATUS.DONE) : tasks.filter(t => t.status !== TASK_STATUS.DONE), [tasks, showCompleted]);

        // --- Core Data Actions ---
        const updateTask = useCallback((id, updatedFields) => {
            setTasks(prevTasks => prevTasks.map(task => 
                task.id === id ? { ...task, ...updatedFields, timestamp: new Date().toISOString() } : task
            ));
        }, []);
        
        const addTask = useCallback((initialTitle = 'New Task', initialPriority = null, initialTags = []) => {
            const newTask = {
                id: crypto.randomUUID(),
                title: initialTitle, 
                checklist: [],
                priority: initialPriority, 
                status: 'To Do',
                rank: tasks.filter(t => t.priority === initialPriority && !t.archived).length, // Rank will be based on the current priority value
                timestamp: new Date().toISOString(), 
                startedAt: null,
                notes: '', // Add a notes field
                totalElapsedTimeInSeconds: 0,
                reminderAt: null, 
                reminderFired: false, 
                tags: Array.isArray(initialTags) ? [...new Set(initialTags)] : [] // Ensure unique tags
            };
            setTasks(prevTasks => [newTask, ...prevTasks].sort((a, b) => (a.rank || 0) - (b.rank || 0) || new Date(a.timestamp) - new Date(b.timestamp))); // Add to top and re-sort
        }, [tasks]);

        const deleteTask = useCallback((id) => {
            setTasks(prevTasks => prevTasks.filter(task => task.id !== id));
        }, []);

        const deleteAllCompletedTasks = useCallback(() => {
            setTasks(prevTasks => prevTasks.filter(task => task.status !== TASK_STATUS.DONE));
        }, []);

        const allTags = useMemo(() => {
            // allTags should contain all custom tags from ALL tasks to ensure swimlane management is always complete.
            const customTagsSet = new Set();
            tasks.forEach(task => { // Iterate over all tasks
                (task.tags || []).forEach(tag => {
                    // Check if the tag is a priority display title (case-insensitive)
                    const isPriorityTitle = PRIORITY_DISPLAY_TITLES_ARRAY.some(
                        pTitle => pTitle.toLowerCase() === tag.toLowerCase()
                    );
                    if (!isPriorityTitle) {
                        customTagsSet.add(tag);
                    }
                });
            });
            return Array.from(customTagsSet).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        }, [tasks, PRIORITY_DISPLAY_TITLES_ARRAY]); // Depends on all tasks now

        const toggleSwimlaneCollapse = useCallback((swimlaneName) => {
            setCollapsedTagSwimlanes(prev => ({ ...prev, [swimlaneName]: !prev[swimlaneName] }));
        }, []); // setCollapsedTagSwimlanes is stable


        const contextValue = useMemo(() => ({
            tasks, updateTask, addTask, deleteTask, deleteAllCompletedTasks,
            settings, setSettings, allTags,
            taskToComplete, setTaskToComplete,
            taskToDelete, setTaskToDelete,
            activeTags, setActiveTags,
            collapsedTagSwimlanes, setCollapsedTagSwimlanes,
            collapsedColumns, setCollapsedColumns, // Added for fixed columns
            toggleSwimlaneCollapse,
            showCompleted, setShowCompleted, currentTasks
        }), [
            tasks, updateTask, addTask, deleteTask, deleteAllCompletedTasks,
            settings, setSettings, allTags, 
            taskToComplete, setTaskToComplete,
            taskToDelete, setTaskToDelete,
            activeTags, setActiveTags, 
            collapsedTagSwimlanes, setCollapsedTagSwimlanes,
            collapsedColumns, setCollapsedColumns, toggleSwimlaneCollapse,
            showCompleted, currentTasks
        ]);
        
        return <AppContext.Provider value={contextValue}>{children}</AppContext.Provider>;
    };

    // --- Custom Hook to consume context ---
    const useAppContext = () => {
        const context = useContext(AppContext);
        if (context === null) throw new Error("useAppContext must be used within an AppProvider");
        return context;
    }

    // --- Helper Hooks ---
    const usePrevious = (value) => { const ref = useRef(); useEffect(() => { ref.current = value; }); return ref.current; };
    const useNow = (updateInterval = 1000) => { const [now, setNow] = useState(new Date()); useEffect(() => { const timerId = setInterval(() => setNow(new Date()), updateInterval); return () => clearInterval(timerId); }, [updateInterval]); return now; };
    const useWindowWidth = () => {
        const [width, setWidth] = useState(window.innerWidth);
        useEffect(() => {
            const handleResize = () => setWidth(window.innerWidth);
            window.addEventListener('resize', handleResize);
            return () => window.removeEventListener('resize', handleResize);
        }, []);
        return width;
    };

    // --- Helper Function for Time Parsing (MM:SS or SS duration) ---
    const parseHHMMSSDuration = (inputStr) => {
        if (!inputStr || typeof inputStr !== 'string') return null;

        const parts = inputStr.split(':').map(p => p.trim());
        
        let h = 0, m = 0, s = 0;
        let parsedSuccessfully = false;

        if (parts.length === 1) {
            const val = parseInt(parts[0], 10);
            if (!isNaN(val) && String(val) === parts[0]) { // Ensure clean integer parse
                s = val;
                parsedSuccessfully = true;
            }
        } else if (parts.length === 2) {
            const valM = parseInt(parts[0], 10);
            const valS = parseInt(parts[1], 10);
            if (!isNaN(valM) && String(valM) === parts[0] &&
                !isNaN(valS) && String(valS) === parts[1]) {
                m = valM;
                s = valS;
                parsedSuccessfully = true;
            }
        }

        if (!parsedSuccessfully) return null;

        // Normalize seconds to minutes, and minutes to hours (though hours are not directly input)
        if (s >= 60) { m += Math.floor(s / 60); s %= 60; }
        // h will remain 0 if not explicitly set, which is fine for MM:SS or SS input.
        if (m >= 60) { h += Math.floor(m / 60); m %= 60; }

        const totalSeconds = h * 3600 + m * 60 + s;
        return totalSeconds > 0 ? totalSeconds : null;
    };
    const PRIORITY_TAGS_LIST = [PRIORITIES.LOW, PRIORITIES.MEDIUM, PRIORITIES.HIGH]; // May be unused by new logic but kept for now.
    const DISPLAY_PRIORITY_ORDER = [PRIORITIES.LOW, PRIORITIES.MEDIUM, PRIORITIES.HIGH]; // For UI column display - CHANGED ORDER

    // --- Icon Components (Memoized) ---
    const DeleteIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>);
    const BellIcon = React.memo(({ className }) => <svg xmlns="http://www.w3.org/2000/svg" className={`h-4 w-4 ${className || ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6 6 0 10-12 0v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" /></svg>);
    const ChevronDownIcon = React.memo(({ className }) => (
        <svg 
            xmlns="http://www.w3.org/2000/svg" 
            className={`h-5 w-5 ${className || ''}`} 
            viewBox="0 0 20 20" 
            fill="currentColor"
        >
            <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
        </svg>
    ));
    const SettingsIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.096 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>);
    const BugIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" strokeWidth="2" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" d="M15.362 5.214A8.252 8.252 0 0112 21 8.25 8.25 0 016.038 7.048 8.287 8.287 0 009 9.6a8.983 8.983 0 013.361-6.867 8.21 8.21 0 003 2.48z" />
            <path strokeLinecap="round" strokeLinejoin="round" d="M12 18a3.75 3.75 0 00.495-7.467 5.99 5.99 0 00-1.925 3.546 5.974 5.974 0 01-2.133-1A3.75 3.75 0 0012 18z" />
        </svg>
    ));
    const DocumentTextIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
        </svg>
    ));
    const PlusIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>);
    const TaikoLogo = React.memo(() => <svg width="52" height="52" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" className="text-white"><g stroke="currentColor" strokeWidth="4" fill="none" strokeLinecap="round" strokeLinejoin="round"><path d="M 25,30 C 25,10 75,10 75,30 V 70 C 75,90 25,90 25,70 Z" fill="rgba(255,255,255,0.1)"/><path d="M 75,30 C 90,30 90,70 75,70" /><path d="M 25,30 C 10,30 10,70 25,70" /><circle cx="50" cy="50" r="28" strokeWidth="3"/><circle cx="50" cy="50" r="8" fill="currentColor"/></g></svg>);

    // --- Time & Countdown Components (Memoized) ---
    const LiveClock = React.memo(({ timezone, onTimezoneChange }) => {
        const time = useNow();
        const dateOptions = useMemo(() => ({ weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' }), []);
        const timeZone = useMemo(() => TIMEZONE_MAP[timezone], [timezone]);
        
        const formattedTime = time.toLocaleTimeString('en-US', { timeZone, hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });

        return (
            // This container will center its direct children: time, date, and button
            <div className="flex flex-col items-end text-slate-300">
                {/* Time, now clickable and with a hover tooltip for the timezone */}
                <div 
                    onClick={onTimezoneChange}
                    className="text-2xl md:text-4xl font-mono tracking-wider cursor-pointer relative group"
                    title="Click to change timezone" // Added title attribute for accessibility
                >
                    {formattedTime}
                    <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1.5 opacity-0 group-hover:opacity-100 transition-opacity duration-200 whitespace-nowrap bg-slate-700 text-xs font-mono text-white px-2 py-1 rounded-md shadow-lg pointer-events-none">
                        Timezone: {timezone}
                    </div>
                </div>
            </div>
        );
    });

    const TimeElapsed = React.memo(({ startTime, totalElapsedSeconds }) => {
        const [elapsed, setElapsed] = useState('00:00:00');
        const animationFrameRef = useRef();
        const formatTime = useCallback((s) => new Date(s * 1000).toISOString().substr(11, 8), []);

        useEffect(() => {
            let isMounted = true;
            const animate = () => {
                if (!startTime || !isMounted) return;
                const currentSessionSeconds = (new Date().getTime() - new Date(startTime).getTime()) / 1000;
                setElapsed(formatTime((totalElapsedSeconds || 0) + currentSessionSeconds));
                animationFrameRef.current = requestAnimationFrame(animate);
            };
            if (startTime) animate();
            else setElapsed(formatTime(totalElapsedSeconds || 0));
            return () => { isMounted = false; cancelAnimationFrame(animationFrameRef.current); };
        }, [startTime, totalElapsedSeconds, formatTime]);
        
        return <span className="text-xs font-mono bg-slate-700/50 text-amber-300 px-2 py-1 rounded">{elapsed}</span>;
    });

    // --- Reminder Countdown Component (Memoized) ---
    const ReminderCountdown = React.memo(({ reminderAt }) => {
        const [countdown, setCountdown] = useState('');
        const now = useNow(); // Use the existing useNow hook
    
        const formatCountdown = useCallback((ms) => {
            if (ms <= 0) return 'Due!'; // Or '00:00:00' if you prefer
            const totalSeconds = Math.max(0, Math.floor(ms / 1000));
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }, []);

        useEffect(() => {
            if (!reminderAt) { setCountdown(''); return; }
            const remainingMs = new Date(reminderAt).getTime() - now.getTime();
            setCountdown(formatCountdown(remainingMs));
        }, [reminderAt, now, formatCountdown]);

        if (!reminderAt || countdown === '') return null;
        return <div className="text-xs text-cyan-300 font-mono">Countdown: {countdown}</div>;
    });

    // --- UI Components ---
    const ChecklistItem = React.memo(({ 
        item, 
        onUpdate, // Now also receives completedAt
        onDelete, 
        onAddNewItemAfter, 
        isFocused, 
        onFocusHandled, 
        isLocked, 
        onDragStartItem, 
        onDropItem, 
        onDragEndItem,
        clockTimezone // Added for displaying subtask completion time
    }) => {
        const inputRef = useRef(null);
        const [isDragOver, setIsDragOver] = useState(false); // Local state for drag over visual feedback

        const handleDragStart = (e) => {
            e.stopPropagation(); // Prevent parent elements from also being dragged
            e.dataTransfer.setData('text/plain', item.id); // Set the ID of the dragged item
            e.dataTransfer.effectAllowed = 'move';
            onDragStartItem(item.id); // Notify parent TaskCard
        };

        const handleDragOver = (e) => {
            e.preventDefault(); // Necessary to allow dropping
            e.dataTransfer.dropEffect = 'move';
        };

        const handleDragEnter = (e) => {
            e.preventDefault();
            // Only highlight if the dragged item is not this item itself
            // We need to check against the currently dragged item ID from the parent
            if (onDragStartItem.current !== item.id) { 
                setIsDragOver(true);
            }
        };

        useEffect(() => {
            if (isFocused && inputRef.current) {
                inputRef.current.focus();
                onFocusHandled(); // Important to prevent re-focusing on every render
            }
        }, [isFocused, onFocusHandled]);

        const handleKeyDown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                onAddNewItemAfter(item.id);
            }
        };
        
        const handleDragLeave = () => {
            setIsDragOver(false);
        };

        const handleDrop = (e) => {
            e.preventDefault();
            setIsDragOver(false);
            const draggedId = e.dataTransfer.getData('text/plain');
            if (draggedId && draggedId !== item.id) {
                onDropItem(draggedId, item.id); // Notify parent TaskCard to reorder
            }
        };

        const handleDragEnd = () => {
            setIsDragOver(false);
            onDragEndItem(); // Notify parent TaskCard that drag has ended
        };

        return ( // Only draggable if not locked
            <li 
                draggable={!isLocked} 
                onDragStart={handleDragStart}
                onDragOver={handleDragOver}
                onDragEnter={handleDragEnter}
                onDragLeave={handleDragLeave}
                onDrop={handleDrop}
                onDragEnd={handleDragEnd}
                className={`flex items-center space-x-2 group p-1 rounded-md transition-all ${isDragOver ? 'bg-sky-700/30 border border-sky-500' : ''} ${isLocked ? 'cursor-default' : 'cursor-grab'}`}
            >
                <input 
                    type="checkbox" 
                    checked={item.completed} 
                    onChange={e => {
                        const isCompleted = e.target.checked;
                        onUpdate(item.id, { completed: isCompleted, completedAt: isCompleted ? new Date().toISOString() : null });
                    }} disabled={isLocked} className="form-checkbox h-4 w-4 rounded bg-slate-700 border-slate-500 text-sky-500 focus:ring-sky-500 cursor-pointer disabled:cursor-not-allowed disabled:opacity-50" />
                <input 
                    ref={inputRef}
                    type="text" 
                    value={item.text} 
                    onChange={e => onUpdate(item.id, { text: e.target.value })} 
                    onKeyDown={handleKeyDown}
                    readOnly={isLocked}
                    className={`flex-grow min-w-0 bg-transparent text-sm p-1 rounded-md transition-colors ${item.completed ? 'text-slate-500 line-through' : 'text-slate-300'} focus:bg-slate-700 read-only:cursor-default`} 
                />
                {item.completed && item.completedAt && (
                    <span className="text-xs text-slate-500 ml-2 whitespace-nowrap">
                        ({new Date(item.completedAt).toLocaleString('en-US', {
                            timeZone: TIMEZONE_MAP[clockTimezone] || 'UTC',
                            month: 'numeric', day: 'numeric', year: 'numeric',
                            hour: '2-digit', minute: '2-digit'
                        })})
                    </span>
                )}

                <Tooltip text="Delete item">
                    <button onClick={() => onDelete(item.id)} disabled={isLocked} className="text-slate-500 hover:text-red-400 opacity-0 group-hover:opacity-100 transition-opacity disabled:hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                    </button>
                </Tooltip>
            </li>
        );
    });

    const Tooltip = ({ text, children }) => {
        const { settings } = useAppContext();
        
        if (!settings.showTooltips) {
            return <div className="relative group flex items-center">{children}</div>;
        }
        
        return (
            <div className="relative group flex items-center">
                {children}
                <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1.5 whitespace-nowrap bg-slate-700 text-white text-xs font-mono rounded-md py-1 px-2 shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none z-30">{text}</div>
            </div>
        );
    };

    // --- Task Card Component ---
    const TaskCard = ({ task, clockTimezone, isCompact }) => { // Added clockTimezone and isCompact props
        const { updateTask, deleteTask, allTags, settings, setTaskToDelete, setTaskToComplete, activeTags } = useAppContext();
        const now = useNow();
        const isLocked = task.status === TASK_STATUS.DONE;

        const [isEditingTitle, setIsEditingTitle] = useState(false); // To be wrapped
        const [title, setTitle] = useState(task.title);
        const [isSettingReminder, setIsSettingReminder] = useState(false);
        const [reminderInput, setReminderInput] = useState('');
        const [checklist, setChecklist] = useState(task.checklist || []);
        const [newTag, setNewTag] = useState('');
        const [tagError, setTagError] = useState('');
        // State for task notes
        const [notes, setNotes] = useState(task.notes || '');
        // State for notes visibility
        const [isNotesExpanded, setIsNotesExpanded] = useState(false);
        // State to manage which checklist item should be focused
        const [focusedItemId, setFocusedItemId] = useState(null);
        const draggedChecklistItemId = useRef(null); // Use ref to avoid re-renders during drag
        const notesTextareaRef = useRef(null); // Ref for the notes textarea
        
        useEffect(() => { setChecklist(task.checklist || []); }, [task.checklist]);
        useEffect(() => { setTitle(task.title); }, [task.title]);

        useEffect(() => {
            if (tagError) {
                const timer = setTimeout(() => {
                    setTagError('');
                }, 3000); // Clear error after 3 seconds
                return () => clearTimeout(timer);
            }
        }, [tagError]);
        useEffect(() => { setNotes(task.notes || ''); }, [task.notes]); // Sync notes state with prop
        
        // Effect to auto-resize the notes textarea
        useEffect(() => {
            if (isNotesExpanded && notesTextareaRef.current) {
                const textarea = notesTextareaRef.current;
                textarea.style.height = 'auto'; // Reset height to allow shrinking
                textarea.style.height = `${textarea.scrollHeight}px`; // Set to content height
            }
        }, [notes, isNotesExpanded]); // Rerun on content change or when expanded

        const handleDeleteRequest = useCallback(() => {
            if (settings.confirmOnDelete) {
                setTaskToDelete(task.id); // Corrected: Should set the task ID
            } else {
                deleteTask(task.id);
            }
        }, [task.id, settings.confirmOnDelete, deleteTask, setTaskToDelete]);
        const handleUpdateChecklist = useCallback((updatedList) => {
            // Checklist updates no longer automatically change task status.
            // Status is now manually set via the dropdown.
            updateTask(task.id, { checklist: updatedList });
        }, [task.id, updateTask]);
        
        const handleItemUpdate = (id, values) => handleUpdateChecklist(checklist.map(i => i.id === id ? { ...i, ...values } : i));
        const handleItemDelete = (id) => handleUpdateChecklist(checklist.filter(i => i.id !== id));
        const handleAddItem = () => {
            const newId = crypto.randomUUID();
            setFocusedItemId(newId); // Set the new item to be focused
            handleUpdateChecklist([...checklist, { id: newId, text: '', completed: false }]);
        };
        const handleAddNewItemAfter = useCallback((currentItemId) => {
            const newId = crypto.randomUUID();
            setFocusedItemId(newId); // Set the ID of the new item to be focused
            const currentIndex = checklist.findIndex(i => i.id === currentItemId);
            const newChecklist = [...checklist];
            // Insert the new item right after the current one
            newChecklist.splice(currentIndex + 1, 0, { id: newId, text: '', completed: false });
            handleUpdateChecklist(newChecklist);
        }, [checklist, handleUpdateChecklist]);
        const handleTitleBlur = () => { setIsEditingTitle(false); if (title !== task.title) updateTask(task.id, { title }); };
        const handleTitleKeyDown = (e) => { if (e.key === 'Enter') { e.preventDefault(); handleTitleBlur(); } };
        
        const handleAddTag = () => {
            const currentTags = task.tags || [];
            const trimmedNewTag = newTag.trim();
    
            // Prohibit adding priority display titles as custom tags (case-insensitive)
            const isPriorityTitle = PRIORITY_DISPLAY_TITLES_ARRAY.some(
                pTitle => pTitle.toLowerCase() === trimmedNewTag.toLowerCase()
            );
    
            if (trimmedNewTag && !isPriorityTitle && !currentTags.includes(trimmedNewTag)) {
                const newTagsArray = [...currentTags, trimmedNewTag];
                updateTask(task.id, { tags: newTagsArray });
    
            } else if (isPriorityTitle) {
                setTagError('Cannot add "Low", "Medium", or "High" as custom tags. Use priority buttons.');
                playTone(220, 0.3, 'square', 0.2); // Play a low, short error tone
            }
            setNewTag(''); // Clear input in all cases
        };

        const handleRemoveTag = (tagToRemove) => {
            const currentTags = task.tags || [];
            const newTags = (task.tags || []).filter(tag => tag !== tagToRemove);
            updateTask(task.id, { tags: newTags });
        };

        const handleSetReminder = useCallback(() => {
            if (!reminderInput) return;

            const durationInSeconds = parseHHMMSSDuration(reminderInput);

            if (durationInSeconds === null || durationInSeconds <= 0) {
                console.warn("Invalid duration input for reminder:", reminderInput);
                // Optionally, you could set an error state here to show a message to the user
                return;
            }

            const reminderDate = new Date(Date.now() + durationInSeconds * 1000);
            updateTask(task.id, { reminderAt: reminderDate.toISOString(), reminderFired: false });
            setIsSettingReminder(false);
            setReminderInput(''); // Clear input after setting
        }, [reminderInput, task.id, updateTask, setIsSettingReminder, setReminderInput]);

        const handleReminderKeyDown = (e) => {
            if (e.key === 'Enter') { e.preventDefault(); handleSetReminder(); }
        };

        const handleNotesKeyDown = (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                updateTask(task.id, { notes }); // Save notes
                setIsNotesExpanded(false); // Collapse view
            }
        };
        
        const handleSetPriority = (priorityToSet) => {
            // If the clicked priority is the same as the current one, clear it. Otherwise, set it.
            const newPriority = task.priority === priorityToSet ? null : priorityToSet;
            updateTask(task.id, { priority: newPriority });
        };

        const handleStatusChange = (e) => {
            const newStatus = e.target.value;
            if (newStatus === TASK_STATUS.DONE) {
                setTaskToComplete(task); // Show confirmation modal
            } else {
                updateTask(task.id, { status: newStatus }); // Update directly for other statuses
            }
        };
        
        // Drag and Drop Handlers for Checklist Items
        const handleDragStartChecklistItem = useCallback((id) => {
            draggedChecklistItemId.current = id;
        }, []);

        const handleDropChecklistItem = useCallback((draggedId, targetId) => {
            const draggedIndex = checklist.findIndex(item => item.id === draggedId);
            const targetIndex = checklist.findIndex(item => item.id === targetId);

            if (draggedIndex === -1 || targetIndex === -1) return;

            const newChecklist = [...checklist];
            const [draggedItem] = newChecklist.splice(draggedIndex, 1);
            newChecklist.splice(targetIndex, 0, draggedItem);

            handleUpdateChecklist(newChecklist);
        }, [checklist, handleUpdateChecklist]);

        const handleDragEndChecklistItem = useCallback(() => { draggedChecklistItemId.current = null; }, []);

        // Pulse should continue as long as the reminder time has passed,
        // regardless of whether the notification itself has fired.
        const reminderIsDue = task.reminderAt && new Date(task.reminderAt) <= now;
        const pulseClass = reminderIsDue ? (PRIORITY_CONFIG[task.priority]?.pulseClass || '') : '';

        const cardPadding = isCompact ? 'p-2' : 'p-3';
        const titleFontSize = isCompact ? 'text-base' : ''; // Default is text-lg from h3
        const textSize = isCompact ? 'text-xs' : 'text-sm';

        return (
            <div className={`w-full min-w-0 bg-slate-800/90 backdrop-blur-xl border border-slate-700/50 rounded-lg shadow-lg transition-shadow duration-300 ${pulseClass} ${TASK_STATUS_CONFIG[task.status]?.glowClass || ''}`}>
                <div className={`h-1 rounded-t-lg ${TASK_STATUS_CONFIG[task.status]?.accentClass}`}></div>
                <div className={cardPadding}>
                    <div className="flex justify-between items-start mb-1.5">
                        {isEditingTitle ? (
                            <input type="text" value={title} onChange={e => setTitle(e.target.value)} onBlur={handleTitleBlur} onKeyDown={handleTitleKeyDown} autoFocus className={`flex-1 min-w-0 bg-slate-900/50 rounded-md p-1 text-slate-100 font-bold border border-slate-600 focus:ring-2 focus:ring-sky-500 ${titleFontSize}`} />
                        ) : (
                            <Tooltip text={isLocked ? "Task is completed" : "Double-click to edit title"}>
                                <h3 onDoubleClick={isLocked ? undefined : () => setIsEditingTitle(true)} className={`font-bold text-slate-100 flex-grow min-w-0 break-words ${isLocked ? 'cursor-default' : 'cursor-pointer'} ${titleFontSize}`}>{task.title}</h3>
                            </Tooltip>
                        )}
                    </div>

                    <ul className="space-y-1 my-2">{checklist.map(item => 
                        <ChecklistItem 
                            key={item.id} 
                            item={item} 
                            onUpdate={handleItemUpdate} 
                            onDelete={handleItemDelete} 
                            onAddNewItemAfter={handleAddNewItemAfter}
                            isFocused={focusedItemId === item.id}
                            onFocusHandled={() => setFocusedItemId(null)}
                            isLocked={isLocked}
                            clockTimezone={clockTimezone} // Pass clockTimezone to ChecklistItem
                            onDragStartItem={handleDragStartChecklistItem}
                            onDropItem={handleDropChecklistItem}
                            onDragEndItem={handleDragEndChecklistItem}
                        />
                    )}</ul>
                    <Tooltip text="Add a new checklist item">
                        <button onClick={handleAddItem} disabled={isLocked} className={`w-full text-left text-sky-400 hover:text-sky-300 p-1 rounded-md hover:bg-slate-700/50 disabled:text-slate-500 disabled:cursor-not-allowed disabled:hover:bg-transparent ${textSize}`}>+ Add item</button>
                    </Tooltip>

                    {/* --- Notes Section --- */}
                    <div className="mt-2 pt-2 border-t border-slate-700/50">
                        {isNotesExpanded ? (
                            <>
                                <div className="flex justify-between items-center mb-1">
                                    <label htmlFor={`notes-${task.id}`} className="block text-xs text-slate-400">Notes:</label>
                                    <Tooltip text="Collapse notes section">
                                        <button onClick={() => setIsNotesExpanded(false)} className={`text-sky-400 hover:text-sky-300 ${textSize}`}>Collapse</button>
                                    </Tooltip>
                                </div>
                                <textarea
                                    ref={notesTextareaRef}
                                    id={`notes-${task.id}`}
                                    value={notes}
                                    onChange={e => setNotes(e.target.value)}
                                    onBlur={() => updateTask(task.id, { notes })}
                                    onKeyDown={handleNotesKeyDown}
                                    placeholder="Add detailed notes here..."
                                    className={`w-full bg-slate-900/50 text-slate-200 p-2 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500 resize-none min-h-[60px] overflow-hidden ${textSize}`}
                                    autoFocus
                                ></textarea>
                            </>
                        ) : (
                            <div className="flex justify-between items-center min-h-[24px]"> {/* Set min-height to prevent layout shift */}
                                {notes ? (
                                    <p className={`${textSize} text-slate-400 truncate flex-1 pr-2`}><span className="font-semibold text-slate-300">Note:</span> {notes.split('\n')[0]}</p>
                                ) : (
                                    <p className={`${textSize} text-slate-500 italic`}>No notes for this task.</p>
                                )}
                                <Tooltip text={notes ? 'View or edit notes' : 'Add notes'}><button onClick={() => setIsNotesExpanded(true)} disabled={isLocked} className={`${textSize} text-sky-400 hover:text-sky-300 flex-shrink-0 disabled:text-slate-500 disabled:cursor-not-allowed`}>{notes ? 'View/Edit' : 'Add Note'}</button></Tooltip>
                            </div>
                        )}
                    </div>
                    {/* --- Tagging UI --- */}
                    <div className="mt-2 pt-2 border-t border-slate-700/50">
                        <div className="flex flex-wrap items-center gap-1 mb-2">
                            <span className="text-xs text-slate-400">Priority:</span> {/* Removed mr-2, gap will handle spacing */}
                            {DISPLAY_PRIORITY_ORDER.map(pTag => ( /* Use DISPLAY_PRIORITY_ORDER for consistent button order */
                                <Tooltip key={pTag} text={`Set priority to ${PRIORITY_CONFIG[pTag].title}`}>
                                    <button 
                                        onClick={() => handleSetPriority(pTag)}
                                        disabled={isLocked} className={`px-2 py-0.5 text-xs font-semibold rounded-md border ${task.priority === pTag ? `${PRIORITY_CONFIG[pTag].bgColor} ${PRIORITY_CONFIG[pTag].borderColor} ${PRIORITY_CONFIG[pTag].color}` : `bg-slate-600/50 border-slate-500 text-slate-300 hover:${PRIORITY_CONFIG[pTag].bgColor}`} flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed`} /* Removed mr-1 mb-1, added flex-shrink-0 */
                                    >
                                        {PRIORITY_CONFIG[pTag].title}
                                    </button>
                                </Tooltip>
                            ))}
                            <Tooltip text="Clear priority (Unprioritized)">
                                <button onClick={() => handleSetPriority(null)} disabled={isLocked} className={`px-2 py-0.5 text-xs font-semibold rounded-md border ${task.priority === null ? `${PRIORITY_CONFIG[null].bgColor} ${PRIORITY_CONFIG[null].borderColor} ${PRIORITY_CONFIG[null].color}` : 'bg-slate-600/50 border-slate-500 text-slate-300 hover:bg-slate-500/30'} flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed`}> {/* Removed mr-1 mb-1, added flex-shrink-0 */}
                                    Clear
                                </button>
                            </Tooltip>
                        </div>
                        </div>
                    <div className="mt-2 pt-2 border-t border-slate-700/50"> {/* This is the start of the custom tags section, unchanged by this request */}
                        <div className="flex flex-wrap gap-2 mb-2"> {/* Added mb-2 for spacing before input */}
                            {(task.tags || []).filter(tag => !PRIORITY_DISPLAY_TITLES_ARRAY.includes(tag)).map(tag => (
                                <span key={tag} className="bg-slate-700 text-xs text-slate-200 px-2 py-1 rounded-full flex items-center">
                                    {tag}
                                    <Tooltip text={`Remove tag: ${tag}`}>
                                        <button onClick={() => handleRemoveTag(tag)} disabled={isLocked} className="ml-2 text-slate-400 hover:text-white leading-none disabled:hidden">&times;</button>
                                    </Tooltip>
                                </span>
                            ))}
                        </div>
                        <div className="flex"> {/* Removed mt-2 as mb-2 was added above */}
                            <input
                                list="tag-suggestions"
                                type="text"
                                value={newTag}
                                onChange={(e) => setNewTag(e.target.value)}
                                onKeyDown={(e) => {if (e.key === 'Enter') handleAddTag()}}
                                placeholder="Add a tag..."                                disabled={isLocked} className="bg-slate-900/50 text-slate-200 text-xs p-1 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500 flex-grow min-w-0 disabled:cursor-not-allowed disabled:bg-slate-800"
                            />
                            <datalist id="tag-suggestions">
                                {allTags.map(tag => <option key={tag} value={tag} />)}
                            </datalist>
                            <Tooltip text="Add this tag to the task">
                                <button onClick={handleAddTag} disabled={isLocked} className="ml-2 text-xs bg-sky-600 text-white px-3 py-1 rounded-md hover:bg-sky-500 disabled:bg-slate-600 disabled:cursor-not-allowed">Add</button> {/* Adjusted py-1 for consistency */}
                            </Tooltip>
                        </div>
                        {tagError && <div className="mt-1.5 text-xs text-red-400">{tagError}</div>}
                    </div>

                    {isSettingReminder && !task.archived && (
                        <div className="mt-2 flex items-center space-x-2">
                            <input 
                                type="text" 
                                value={reminderInput}
                                onChange={e => setReminderInput(e.target.value)}
                                onKeyDown={handleReminderKeyDown}
                                autoFocus 
                                placeholder="Set in: MM:SS / SS"                                className="bg-slate-900/70 border border-slate-600 text-slate-200 text-sm rounded-md p-1 flex-1 min-w-0"/>
                            <Tooltip text="Set reminder from input">
                                <button onClick={handleSetReminder} className="px-3 py-1 bg-sky-600 text-white text-sm rounded-md hover:bg-sky-500">Set</button>
                            </Tooltip>
                        </div>
                    )}
                    {task.reminderAt && !isSettingReminder && (
                        <div className="mt-2 text-xs">
                            <div className="text-sky-300 flex justify-between items-center mb-0.5">
                                <span>
                                    Set for: {new Date(task.reminderAt).toLocaleTimeString([], {
                                        timeZone: TIMEZONE_MAP[clockTimezone] || 'UTC', // Fallback to UTC if map fails
                                        hour: '2-digit', minute:'2-digit', second: '2-digit'
                                    })} {clockTimezone}
                                </span>
                                <Tooltip text="Clear reminder">
                                    <button onClick={() => updateTask(task.id, { reminderAt: null, reminderFired: false })} className="text-red-400 hover:text-red-300 text-xs">(clear)</button>
                                </Tooltip>
                            </div>
                            <ReminderCountdown reminderAt={task.reminderAt} />
                        </div>
                    )}
                    <div className="mt-2 pt-2 border-t border-slate-700 flex justify-between items-center">
                        {/* Manual Status Selector */}
                        <div className="flex items-center space-x-2">
                            <label htmlFor={`status-select-${task.id}`} className={`${textSize} text-slate-400`}>Status:</label>
                            <select
                                id={`status-select-${task.id}`}
                                value={task.status}
                                onChange={handleStatusChange}
                                className={`${TASK_STATUS_CONFIG[task.status]?.selectBgColor || 'bg-slate-900/50'} text-slate-200 p-1 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500 transition-colors ${textSize}`}
                            >
                                {Object.values(TASK_STATUS).map(status => (
                                    <option key={status} value={status}>{status}</option>
                                ))}
                            </select>
                            {task.status === TASK_STATUS.DONE && task.timestamp && (
                                <span className="text-xs text-green-400 whitespace-nowrap">
                                    ({new Date(task.timestamp).toLocaleString('en-US', {
                                        timeZone: TIMEZONE_MAP[clockTimezone] || 'UTC',
                                        month: 'numeric',
                                        day: 'numeric',
                                        hour: '2-digit',
                                        minute: '2-digit',
                                        hour12: true
                                    })})
                                </span>
                            )}
                        </div>
                        <div className="flex items-center space-x-2">
                            <Tooltip text={isSettingReminder ? "Cancel reminder setup" : "Set Reminder"}>
                                <button onClick={() => setIsSettingReminder(!isSettingReminder)} disabled={task.status === TASK_STATUS.DONE} className="text-slate-400 hover:text-white transition-colors p-1 rounded-full hover:bg-slate-700 disabled:opacity-50"><BellIcon /></button>
                            </Tooltip>
                            <Tooltip text="Delete Permanently"><button onClick={handleDeleteRequest} className="text-red-400 hover:text-white transition-colors p-1 rounded-full hover:bg-red-500"><DeleteIcon /></button></Tooltip>
                        </div>
                    </div>
                </div>
            </div>
        );
    };
    const MemoizedTaskCard = React.memo(TaskCard);


    // --- Main Presentation Component ---
    const App = () => {
        const { 
            tasks, addTask,
            settings, setSettings,
            taskToComplete, setTaskToComplete, taskToDelete, setTaskToDelete, deleteAllCompletedTasks,
            allTags, deleteTask, updateTask, // Core data functions
            activeTags, setActiveTags,                     // Filter state
            collapsedTagSwimlanes, toggleSwimlaneCollapse, // Swimlane collapse state & toggle fn
            collapsedColumns, setCollapsedColumns,          // Fixed column collapse state & setter
            showCompleted, setShowCompleted, currentTasks   // View state and derived tasks from provider
        } = useAppContext();

        const tagsForCurrentView = useMemo(() => {
            const customTagsSet = new Set();
            currentTasks.forEach(task => {
                (task.tags || []).forEach(tag => {
                    // This check prevents priority display titles from appearing as tag filters.
                    const isPriorityTitle = PRIORITY_DISPLAY_TITLES_ARRAY.some(
                        pTitle => pTitle.toLowerCase() === tag.toLowerCase()
                    );
                    if (!isPriorityTitle) { customTagsSet.add(tag); }
                });
            });
            return Array.from(customTagsSet).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        }, [currentTasks]);

        const now = useNow(); // Get current time, updates every second

        // const [collapsedColumns, setCollapsedColumns] = useState({ 'new-tasks': false }); // MOVED to AppProvider
        const [showSettings, setShowSettings] = useState(false);
        // const [collapsedTagSwimlanes, setCollapsedTagSwimlanes] = useState({}); // Moved to AppProvider
        const [clockTimezone, setClockTimezone] = useState('EST');
        const [draggedSwimlane, setDraggedSwimlane] = useState(null); // For swimlane reordering

        // State for the summary modal
        const [showSummaryModal, setShowSummaryModal] = useState(false);
        const [summaryText, setSummaryText] = useState('');
        const [showDeleteAllCompletedModal, setShowDeleteAllCompletedModal] = useState(false);
        const [forceVertical, setForceVertical] = useState(false);
        const [showReleaseNotesModal, setShowReleaseNotesModal] = useState(false);

        const windowWidth = useWindowWidth();
        const prevTasks = usePrevious(currentTasks);

        // --- Effect for showing release notes once per version ---
        useEffect(() => {
            const lastSeenVersion = localStorage.getItem('taiko-app-local-lastSeenVersion');
            if (lastSeenVersion !== CURRENT_APP_VERSION) {
                setShowReleaseNotesModal(true);
            }
        }, []); // Run only once on mount

        const handleCloseReleaseNotes = () => {
            setShowReleaseNotesModal(false);
            localStorage.setItem('taiko-app-local-lastSeenVersion', CURRENT_APP_VERSION);
        };


        useEffect(() => {
            // Ensure that when the view switches between active and archived,
            // or when tasks are modified, the counts for filters are based on the currently displayed tasks.
            // The `currentTasks` variable already reflects this.
        }, [currentTasks]);

        const allTasksCount = useMemo(() => currentTasks.length, [currentTasks]);

        const completedTasksCount = useMemo(() => tasks.filter(t => t.status === TASK_STATUS.DONE).length, [tasks]);

        const priorityFilterCounts = useMemo(() => {
            const counts = {};
            DISPLAY_PRIORITY_ORDER.forEach(priorityConstant => {
                const displayTitle = PRIORITY_CONFIG[priorityConstant].title;
                counts[displayTitle] = currentTasks.filter(task => task.priority === priorityConstant).length;
            });
            return counts;
        }, [currentTasks]); // DISPLAY_PRIORITY_ORDER and PRIORITY_CONFIG are stable constants

        const customTagFilterCounts = useMemo(() => {
            const counts = {};
            const customTagsToDisplay = allTags.filter(tag => !PRIORITY_DISPLAY_TITLES_ARRAY.includes(tag));
            customTagsToDisplay.forEach(tag => {
                counts[tag] = currentTasks.filter(task => task.tags && task.tags.includes(tag)).length;
            });
            return counts;
        }, [currentTasks, allTags]); // PRIORITY_DISPLAY_TITLES_ARRAY is a stable constant

        // --- Effect for Reminder Notifications & Sounds ---
        useEffect(() => {
            if (!('Notification' in window) || Notification.permission !== 'granted') {
                return; // Notifications not supported or permission not granted
            }

            tasks.forEach(task => {
                if (task.reminderAt && !task.reminderFired && task.status !== TASK_STATUS.DONE && new Date(task.reminderAt) <= now) {
                    // console.log(`Firing reminder for task: ${task.title}`); // For debugging
                    new Notification('Taiko Task Reminder', {
                        body: `Reminder for: ${task.title}`,
                        // icon: 'your_icon.png' // Optional: Add an icon URL here
                    });
                    updateTask(task.id, { reminderFired: true });

                    // Play sound based on priority
                    switch (task.priority) {
                        case PRIORITIES.HIGH:
                            playTone(880, 0.6, 'sawtooth', 0.4); // Higher pitch, slightly harsher, louder
                            setTimeout(() => playTone(880, 0.3, 'sawtooth', 0.4), 150); // Quick second beep
                            break;
                        case PRIORITIES.MEDIUM:
                            playTone(660, 0.8, 'square', 0.35); // Medium pitch
                            break;
                        case PRIORITIES.LOW:
                            playTone(440, 1.0, 'sine', 0.3); // Lower pitch, softer
                            break;
                        default: // Unprioritized or null
                            playTone(523, 0.7, 'sine', 0.25); // A general C5 note
                    }
                }
            });
        }, [tasks, now, updateTask]);

        const handleConfirmDelete = useCallback(() => {
            if (!taskToDelete) return;
            deleteTask(taskToDelete);
            setTaskToDelete(null);
        }, [taskToDelete, deleteTask]);

        const handleConfirmComplete = useCallback(() => {
            if (!taskToComplete) return;
            updateTask(taskToComplete.id, { status: TASK_STATUS.DONE });
            setTaskToComplete(null);
        }, [taskToComplete, updateTask]);

        const [showAddTaskModal, setShowAddTaskModal] = useState(false);
        const handleAddTaskFromModal = ({ title, priority, tags }) => {
            // Add the task first
            addTask(title, priority, tags); 
            setShowAddTaskModal(false); 
        };
        const handleConfirmDeleteAllCompleted = useCallback(() => {
            deleteAllCompletedTasks();
            setShowDeleteAllCompletedModal(false);
        }, [deleteAllCompletedTasks]);

        const handleTimezoneChange = () => setClockTimezone(p => TIMEZONE_ORDER[(TIMEZONE_ORDER.indexOf(p) + 1) % TIMEZONE_ORDER.length]);
        
        const handleViewChange = (isCompletedView) => {
            if (showCompleted === isCompletedView) return; // Avoid unnecessary state updates
            setShowCompleted(isCompletedView);
            setActiveTags([]); // Reset filters when changing views
        };
        // Effect to automatically hide empty swimlanes if autoCollapse is enabled (and they are empty after filtering)

        const generateCompletedTasksSummary = useCallback(() => {
            const completedTasks = tasks.filter(t => t.status === TASK_STATUS.DONE)
                                        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); // Sort by completion time
            
            const timeZone = TIMEZONE_MAP[clockTimezone] || 'UTC';
            const localeOptions = {
                year: 'numeric', month: 'numeric', day: 'numeric',
                hour: 'numeric', minute: 'numeric', second: 'numeric',
                hour12: true,
                timeZone: timeZone
            };

            
            let summary;
            if (completedTasks.length === 0) {
                summary = "No tasks have been completed yet.";
            } else {
                summary = `--- Completed Tasks Summary ---\n`;
                summary += `Total Completed: ${completedTasks.length}\n`;
                summary += `Generated on: ${new Date().toLocaleString('en-US', localeOptions)} ${clockTimezone}\n\n`;
                summary += "========================================\n\n";

                completedTasks.forEach(task => {
                    summary += `Task: ${task.title}\n`;
                    
                    const priorityTitle = PRIORITY_CONFIG[task.priority]?.title || PRIORITY_CONFIG.null.title;
                    summary += `Priority: ${priorityTitle}\n`;
                    
                    summary += `Completed On: ${new Date(task.timestamp).toLocaleString('en-US', localeOptions)} ${clockTimezone}\n`;

                    if (task.notes && task.notes.trim()) {
                        summary += `\n  Notes:\n`;
                        summary += `    ${task.notes.trim().replace(/\n/g, '\n    ')}\n`; // Indent notes
                    } else {
                        summary += `\n  Notes:\n    No notes.\n`;
                    }

                    const validSubtasks = (task.checklist || []).filter(item => item.text && item.text.trim() !== '');

                    // Only include subtasks that were actually completed if we're showing completed tasks
                    // Or all subtasks if we're showing active tasks
                    const subtasksToSummarize = showCompleted ? validSubtasks.filter(item => item.completed) : validSubtasks;

                    if (subtasksToSummarize.length > 0) {
                        summary += `\n  Subtasks:\n`;
                        subtasksToSummarize.forEach(item => {
                            let subtaskLine = `    [${item.completed ? 'x' : ' '}] ${item.text}`;
                            if (item.completed && item.completedAt) {
                                subtaskLine += ` (Completed: ${new Date(item.completedAt).toLocaleString('en-US', localeOptions)})`;
                            }
                            summary += `${subtaskLine}\n`;
                        });
                    } else {
                        summary += `\n  Subtasks:\n    No subtasks.\n`;
                    }

                    summary += "\n========================================\n\n";
                });
            }
            setSummaryText(summary);
            setShowSummaryModal(true);
        }, [tasks, clockTimezone]); // Dependency on `tasks` and `clockTimezone` state

        const handleTagFilterClick = (tag) => {
            const isPriorityTag = PRIORITY_TITLE_TO_CONSTANT_MAP[tag];

            setActiveTags(prevActiveTags => {
                if (isPriorityTag) {
                    // Clicked a priority filter.
                    // If it's already the active filter, clear all filters.
                    // Otherwise, make it the ONLY active filter.
                    if (prevActiveTags.length === 1 && prevActiveTags[0] === tag) {
                        return [];
                    } else {
                        return [tag];
                    }
                } else {
                    // Clicked a custom tag filter.
                    // Remove any active priority filters.
                    const customTagsOnly = prevActiveTags.filter(t => !PRIORITY_TITLE_TO_CONSTANT_MAP[t]);
                    
                    // Now, toggle the clicked custom tag within that list.
                    if (customTagsOnly.includes(tag)) {
                        return customTagsOnly.filter(t => t !== tag);
                    } else {
                        return [...customTagsOnly, tag];
                    }
                }
            });
        };

        const clearTagFilter = () => setActiveTags([]);

        const tasksMatchingActiveFilters = useMemo(() => {
            if (activeTags.length === 0) return currentTasks;
            return currentTasks.filter(task =>
                activeTags.some(activeTag => {
                    const priorityConstant = PRIORITY_TITLE_TO_CONSTANT_MAP[activeTag];
                    return priorityConstant ? task.priority === priorityConstant : (task.tags && task.tags.includes(activeTag))
                })
            );
        }, [currentTasks, activeTags]);
        // const handleDropSwimlane = (targetSwimlaneName) => {
        //     if (!draggedSwimlane || draggedSwimlane === targetSwimlaneName) {
        //         setDraggedSwimlane(null);
        //         return;
        //     }
        //     const newActiveSwimlanes = [...activeSwimlanes];
        //     const draggedIndex = newActiveSwimlanes.indexOf(draggedSwimlane);
        //     const targetIndex = newActiveSwimlanes.indexOf(targetSwimlaneName);
        //
        //     newActiveSwimlanes.splice(draggedIndex, 1); // Remove dragged item
        //     newActiveSwimlanes.splice(targetIndex, 0, draggedSwimlane); // Insert at new position
        //     setActiveSwimlanes(newActiveSwimlanes);
        //     setDraggedSwimlane(null);
        // };
        // --- Swimlane Drag and Drop Handlers ---
        const handleDragStartSwimlane = (e, swimlaneName) => {
            setDraggedSwimlane(swimlaneName);
            e.dataTransfer.effectAllowed = 'move';
            // Optional: Add a class to the body or a specific element for global drag styling
        };

        const handleDragOverSwimlane = (e) => {
            e.preventDefault(); // Necessary to allow dropping
        };

        const { swimlaneTasks, unclassifiedTasks, activeSwimlanes } = useMemo(() => {
            const st = {};
            const ut = []; // unclassifiedTasks

            const taskSorter = (a, b) => {
                if (showCompleted) {
                    return new Date(b.timestamp) - new Date(a.timestamp); // Newest completed first
                } else {
                    return (a.rank ?? Infinity) - (b.rank ?? Infinity); 
                }
            };

            // Determine active swimlanes based on tasks that match filters
            const swimlanesWithTasks = new Set();
            tasksMatchingActiveFilters.forEach(task => {
                if (task.priority) {
                    swimlanesWithTasks.add(PRIORITY_CONFIG[task.priority].title);
                }
                (task.tags || []).forEach(tag => swimlanesWithTasks.add(tag));
            });
            // This defines the swimlanes to be rendered.
            const activeSwimlanes = Array.from(swimlanesWithTasks).sort();

            for (const task of tasksMatchingActiveFilters) {
                let inSwimlane = false;
                
                for (const swimlaneName of activeSwimlanes) { 
                    const isPrioritySwimlane = PRIORITY_TITLE_TO_CONSTANT_MAP[swimlaneName];
                    let matchesSwimlane = false;

                    if (isPrioritySwimlane) {
                        matchesSwimlane = task.priority === PRIORITY_TITLE_TO_CONSTANT_MAP[swimlaneName];
                    } else {
                        matchesSwimlane = task.tags && task.tags.includes(swimlaneName);
                    }

                    if (matchesSwimlane) {
                        if (!st[swimlaneName]) st[swimlaneName] = [];
                        st[swimlaneName].push(task);
                        inSwimlane = true;
                        break; // Task assigned, move to the next task
                    }
                }

                if (!inSwimlane) {
                    ut.push(task);
                }
            }

            // Sort unclassified tasks
            ut.sort(taskSorter);

            // Sort tasks within each swimlane
            for (const swimlaneName in st) {
                st[swimlaneName].sort(taskSorter);
            }
            return { swimlaneTasks: st, unclassifiedTasks: ut, activeSwimlanes };
        }, [tasksMatchingActiveFilters, showCompleted, PRIORITY_TITLE_TO_CONSTANT_MAP]);
        
        const mainContainerRef = useRef(null);
        
        // This effect checks if the horizontal columns overflow their container.
        // If they do, it forces a vertical layout.
        useEffect(() => {
            if (mainContainerRef.current && windowWidth >= 768) {
                const containerWidth = mainContainerRef.current.clientWidth;
                
                // Determine how many columns would be rendered
                let columnCount = 0;
                if (unclassifiedTasks.length > 0 || activeTags.length === 0) {
                    columnCount++; // The "Unsorted" column
                }
                columnCount += activeSwimlanes.filter(item => {
                    const tasksForThisSwimlane = swimlaneTasks[item] || [];
                    return tasksForThisSwimlane.length > 0 || activeTags.length === 0;
                }).length;

                const columnWidth = 384; // w-96 is 24rem = 384px
                const gapWidth = 16; // space-x-4 is 1rem = 16px
                const totalRequiredWidth = (columnCount * columnWidth) + (Math.max(0, columnCount - 1) * gapWidth);

                setForceVertical(totalRequiredWidth > containerWidth);
            } else {
                setForceVertical(false); // Don't force vertical on small screens, it's already handled
            }
        }, [activeSwimlanes, unclassifiedTasks, windowWidth, swimlaneTasks, activeTags, settings.autoCollapse]); // Re-check when columns or window size change
        const isEffectiveVerticalLayout = forceVertical || windowWidth < 768; // Force vertical on small screens or when content overflows
        const mainLayoutClasses = isEffectiveVerticalLayout ? 'flex-col space-y-4' : 'flex-row space-x-4 items-start';
        const backgroundOverlayClass = showCompleted ? 'bg-green-900/10' : '';
        
        return (
            <div className="h-screen w-screen font-sans flex flex-col overflow-x-hidden" style={{ background: 'transparent' }}>

                {taskToComplete && <CompleteConfirmationModal task={taskToComplete} onConfirm={handleConfirmComplete} onCancel={() => setTaskToComplete(null)} />}
                {taskToDelete && <DeleteConfirmationModal onConfirm={handleConfirmDelete} onCancel={() => setTaskToDelete(null)} />}
                {showSettings && <SettingsModal settings={settings} onSettingsChange={setSettings} onClose={() => setShowSettings(false)} />}
                {showDeleteAllCompletedModal && <DeleteAllCompletedModal onConfirm={handleConfirmDeleteAllCompleted} onCancel={() => setShowDeleteAllCompletedModal(false)} count={completedTasksCount} />}
                {showSummaryModal && <SummaryModal summary={summaryText} onClose={() => setShowSummaryModal(false)} />}
                {showReleaseNotesModal && <ReleaseNotesModal version={CURRENT_APP_VERSION} releaseInfo={RELEASE_NOTES[CURRENT_APP_VERSION]} onClose={handleCloseReleaseNotes} />}
                {showAddTaskModal && <AddTaskModal onAdd={handleAddTaskFromModal} onCancel={() => setShowAddTaskModal(false)} allTags={allTags} />}
                
                <header className="sticky top-0 z-10 p-4 bg-slate-900/70 backdrop-blur-md shadow-lg flex flex-col space-y-3">
                    {/* --- Top Row: Title & Clock --- */}
                    <div className="flex justify-between items-center w-full">
                        <div className="flex items-center space-x-4">
                            <TaikoLogo />
                            <div>
                                <h1 className="text-3xl font-bold" style={{ color: '#E0E7FF', textTransform: 'uppercase', letterSpacing: '0.2em' }}>Taiko</h1>
                                <p className="text-slate-400 text-sm hidden md:block">Operations Task Master</p>
                            </div>
                        </div>
                        <div className="flex-shrink-0">
                            <LiveClock timezone={clockTimezone} onTimezoneChange={handleTimezoneChange} />
                        </div>
                    </div>
                    {/* --- Bottom Row: Toolbar (now responsive) --- */}
                    <div className="flex justify-between items-center w-full flex-wrap gap-2">
                        <HeaderToolbar isSmallScreen={windowWidth < 768} onShowSettings={() => setShowSettings(true)} onGenerateSummary={generateCompletedTasksSummary} onShowDeleteAllModal={() => setShowDeleteAllCompletedModal(true)} showDeleteAllButton={showCompleted && completedTasksCount > 0} />
                        <div className="flex items-center flex-wrap gap-2">
                            <AddTaskButton onAddTask={() => setShowAddTaskModal(true)} />
                        </div>
                    </div>
                </header>
                
                <div className="px-6 py-2 flex-shrink-0 border-b border-slate-800 flex justify-between items-center flex-wrap gap-2">
                    <FilterToolbar
                        isSmallScreen={windowWidth < 768}
                        showCompleted={showCompleted}
                        completedTasksCount={completedTasksCount}
                        activeTags={activeTags}
                        allTasksCount={allTasksCount}
                        priorityFilterCounts={priorityFilterCounts}
                        tagsForCurrentView={tagsForCurrentView}
                        customTagFilterCounts={customTagFilterCounts}
                        onViewChange={handleViewChange}
                        onClearFilters={clearTagFilter}
                        onTagFilterClick={handleTagFilterClick}
                    />
                </div>

                <main ref={mainContainerRef} className={`flex-grow p-4 pt-4 flex overflow-auto transition-all duration-300 ${mainLayoutClasses} ${backgroundOverlayClass} ${!isEffectiveVerticalLayout ? 'overflow-x-auto' : 'overflow-y-auto'}`}>
                    {showCompleted ? (
                        <PriorityColumn
                            key="completed-column"
                            titleOverride="Completed Tasks"
                            priority={null}
                            tasks={tasksMatchingActiveFilters}
                            isCollapsed={false}
                            onToggleCollapse={() => {}} // No-op for completed view
                            showCompleted={showCompleted}
                            isVerticalLayout={isEffectiveVerticalLayout}
                            clockTimezone={clockTimezone}
                            isSwimlane={false}
                            isCompact={settings.compactView}
                            disableQuickAdd={true}
                        />
                    ) : (
                        <>
                            {/* --- "New Tasks" Column (replaces Triage) --- */}
                            {(() => { // This column displays unclassifiedTasks
                                const unsortedTasksToDisplay = unclassifiedTasks;
                                const isEffectivelyCollapsedUnsorted = (settings.autoCollapse && unsortedTasksToDisplay.length === 0) ? true : (collapsedColumns['unsorted'] || false);
                                
                                // Render if tasks exist, OR if no filters are active and it's not effectively collapsed
                                const shouldRenderUnsortedColumn = unsortedTasksToDisplay.length > 0 || (activeTags.length === 0 && !isEffectivelyCollapsedUnsorted);

                                if (shouldRenderUnsortedColumn) {
                                    return (
                                        <PriorityColumn
                                            key="unsorted-column"
                                            titleOverride="Unsorted" // Updated title
                                            priority={null} // Base styling on unprioritized, but title is overridden
                                            tasks={unsortedTasksToDisplay}
                                            isCollapsed={isEffectivelyCollapsedUnsorted}
                                            onToggleCollapse={() => setCollapsedColumns(p => ({ ...p, 'unsorted': !p['unsorted'] }))}
                                            showCompleted={showCompleted}
                                            isVerticalLayout={isEffectiveVerticalLayout}
                                            clockTimezone={clockTimezone}
                                            isSwimlane={false} // Indicate this is a primary column
                                            isCompact={settings.compactView}
                                        /> );
                                } return null;
                            })()}
                            {activeSwimlanes.map(item => { // Iterate over all active swimlanes (tags or priority display titles)
                                const tasksForThisSwimlane = swimlaneTasks[item] || [];
                                const isManuallyCollapsed = collapsedTagSwimlanes[item] || false;
                                const isEffectivelyCollapsedTag = (settings.autoCollapse && tasksForThisSwimlane.length === 0) ? true : isManuallyCollapsed;

                                // Render if tasks exist, OR if no filters are active and it's not effectively collapsed
                                const shouldRenderTagColumn = tasksForThisSwimlane.length > 0 || (activeTags.length === 0 && !isEffectivelyCollapsedTag);

                                if (!shouldRenderTagColumn) {
                                    return null; // Hide the column if filters make it empty, or if no filters and it's effectively collapsed
                                }

                                // All active swimlanes (including those named "High", "Medium", "Low")
                                // will now be rendered by TagColumn.
                                // The "Unsorted" column is handled separately above.
                                return (
                                    <div
                                        key={item}
                                        draggable={!isEffectiveVerticalLayout} // Only allow drag in horizontal mode
                                        // onDragStart={(e) => !isEffectiveVerticalLayout && handleDragStartSwimlane(e, item)}
                                        // onDragOver={!isEffectiveVerticalLayout ? handleDragOverSwimlane : undefined}
                                        // onDrop={() => !isEffectiveVerticalLayout && handleDropSwimlane(item)}
                                        className={`transition-opacity duration-200 ${draggedSwimlane === item ? 'opacity-30' : 'opacity-100'} ${isEffectiveVerticalLayout ? 'w-full' : 'flex-shrink-0 w-96'}`}
                                    >
                                        <TagColumn 
                                            tag={item} // 'item' is the swimlane name, e.g., "ProjectX" or "High"
                                            tasks={tasksForThisSwimlane} 
                                            clockTimezone={clockTimezone}
                                            isCollapsed={isEffectivelyCollapsedTag}
                                            onToggleCollapse={() => toggleSwimlaneCollapse(item)}
                                            isVerticalLayout={isEffectiveVerticalLayout}
                                            isBeingDragged={draggedSwimlane === item}
                                            isCompact={settings.compactView}
                                        />
                                    </div>
                                );
                            })}
                        </>
                    )}
                </main>
                <Footer onShowReleaseNotes={() => setShowReleaseNotesModal(true)} />
            </div>
        );
    };

    // --- Column & Modal Components ---
    const FilterToolbar = React.memo(({
        isSmallScreen,
        showCompleted,
        completedTasksCount,
        activeTags,
        allTasksCount,
        priorityFilterCounts,
        tagsForCurrentView,
        customTagFilterCounts,
        onViewChange,
        onClearFilters,
        onTagFilterClick
    }) => {
        const [isFilterMenuOpen, setIsFilterMenuOpen] = useState(false);
        const filterMenuRef = useRef(null);

        useEffect(() => {
            const handleClickOutside = (event) => {
                if (filterMenuRef.current && !filterMenuRef.current.contains(event.target)) {
                    setIsFilterMenuOpen(false);
                }
            };
            document.addEventListener("mousedown", handleClickOutside);
            return () => document.removeEventListener("mousedown", handleClickOutside);
        }, [filterMenuRef]);

        const secondaryFilters = (
            <>
                <Tooltip text="Show all tasks (clear tag filters)">
                    <button onClick={onClearFilters} className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${activeTags.length === 0 ? 'bg-sky-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>All <span className="opacity-80"> ({allTasksCount})</span></button>
                </Tooltip>
                {DISPLAY_PRIORITY_ORDER.map(priorityConstant => {
                    const displayTitle = PRIORITY_CONFIG[priorityConstant].title;
                    return (
                        <Tooltip key={displayTitle} text={`Filter by priority: ${displayTitle}`}>
                            <button onClick={() => onTagFilterClick(displayTitle)} className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${activeTags.includes(displayTitle) ? `${PRIORITY_CONFIG[priorityConstant].bgColor} text-white` : 'text-slate-400 hover:bg-slate-700/50'}`}>
                                {displayTitle} <span className="opacity-80">({priorityFilterCounts[displayTitle] || 0})</span>
                            </button>
                        </Tooltip>
                    );
                })}
                {tagsForCurrentView.length > 0 && <div className="border-l border-slate-700 h-5"></div>}
                {tagsForCurrentView.map(tag => (
                    <Tooltip key={tag} text={`Filter by custom tag: ${tag}`}>
                        <button onClick={() => onTagFilterClick(tag)} className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${activeTags.includes(tag) ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>
                            {tag} <span className="opacity-80"> ({customTagFilterCounts[tag] || 0})</span>
                        </button>
                    </Tooltip>
                ))}
            </>
        );

        const mobileFilterButtonText = activeTags.length > 0 ? `Filtered: ${activeTags.join(', ')}` : 'Filter by...';

        return (
            <div className="flex items-center space-x-2 flex-wrap">
                {/* --- Primary View Tabs (Always Visible) --- */}
                <Tooltip text="Show active tasks"><button onClick={() => onViewChange(false)} className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${!showCompleted ? 'bg-sky-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>Active</button></Tooltip>
                <Tooltip text="Show completed tasks"><button onClick={() => onViewChange(true)} className={`px-3 py-1 text-sm font-medium rounded-md transition-colors ${showCompleted ? 'bg-green-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>Completed <span className="opacity-80">({completedTasksCount})</span></button></Tooltip>
                <div className="border-l border-slate-700 h-5 mx-2"></div>

                {isSmallScreen ? (
                    <div className="relative" ref={filterMenuRef}>
                        <Tooltip text="Select a filter">
                            <button onClick={() => setIsFilterMenuOpen(p => !p)} className={`px-3 py-1 text-sm font-medium rounded-md transition-colors flex items-center gap-1 ${activeTags.length > 0 ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>
                                {mobileFilterButtonText}
                                <ChevronDownIcon className={`h-4 w-4 transition-transform ${isFilterMenuOpen ? 'rotate-180' : ''}`} />
                            </button>
                        </Tooltip>
                        {isFilterMenuOpen && (
                            <div className="absolute left-0 mt-2 w-56 bg-slate-800 border border-slate-700 rounded-md shadow-lg py-1 z-20">
                                <button onClick={() => { onClearFilters(); setIsFilterMenuOpen(false); }} className={`w-full text-left px-4 py-2 text-sm ${activeTags.length === 0 ? 'text-white bg-sky-600' : 'text-slate-200 hover:bg-slate-700'}`}>All ({allTasksCount})</button>
                                <div className="my-1 border-t border-slate-700"></div>
                                {DISPLAY_PRIORITY_ORDER.map(pConst => {
                                    const title = PRIORITY_CONFIG[pConst].title;
                                    return <button key={title} onClick={() => { onTagFilterClick(title); setIsFilterMenuOpen(false); }} className={`w-full text-left px-4 py-2 text-sm ${activeTags.includes(title) ? `text-white ${PRIORITY_CONFIG[pConst].bgColor}` : 'text-slate-200 hover:bg-slate-700'}`}>{title} ({priorityFilterCounts[title] || 0})</button>
                                })}
                                {tagsForCurrentView.length > 0 && <div className="my-1 border-t border-slate-700"></div>}
                                {tagsForCurrentView.map(tag => (
                                    <button key={tag} onClick={() => { onTagFilterClick(tag); setIsFilterMenuOpen(false); }} className={`w-full text-left px-4 py-2 text-sm ${activeTags.includes(tag) ? 'text-white bg-indigo-600' : 'text-slate-200 hover:bg-slate-700'}`}>{tag} ({customTagFilterCounts[tag] || 0})</button>
                                ))}
                            </div>
                        )}
                    </div>
                ) : (
                    <>
                        {/* --- Secondary Filter Tabs (Desktop) --- */}
                        {secondaryFilters}
                    </>
                )}
            </div>
        );
    });
    const HeaderToolbar = React.memo(({ isSmallScreen, onShowSettings, onGenerateSummary, onShowDeleteAllModal, showDeleteAllButton }) => {
        const [isMenuOpen, setIsMenuOpen] = useState(false);
        const menuRef = useRef(null);

        useEffect(() => {
            const handleClickOutside = (event) => {
                if (menuRef.current && !menuRef.current.contains(event.target)) {
                    setIsMenuOpen(false);
                }
            };
            document.addEventListener("mousedown", handleClickOutside);
            return () => document.removeEventListener("mousedown", handleClickOutside);
        }, [menuRef]);

        const menuItems = (
            <>
                <button onClick={onShowSettings} className="w-full text-left px-4 py-2 text-sm text-slate-200 hover:bg-slate-700">Settings</button>
                <a href="https://github.com/closedloopchaos/taiko/issues/new/choose" target="_blank" rel="noopener noreferrer" className="block w-full text-left px-4 py-2 text-sm text-slate-200 hover:bg-slate-700">Report Issue</a>
                <button onClick={onGenerateSummary} className="w-full text-left px-4 py-2 text-sm text-slate-200 hover:bg-slate-700">Generate Summary</button>
                {showDeleteAllButton && <button onClick={onShowDeleteAllModal} className="w-full text-left px-4 py-2 text-sm text-red-400 hover:bg-red-500/20">Delete All Completed</button>}
            </>
        );

        if (isSmallScreen) {
            return (
                <div className="relative" ref={menuRef}>
                    <Tooltip text="More options">
                        <button onClick={() => setIsMenuOpen(prev => !prev)} className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z" /></svg>
                        </button>
                    </Tooltip>
                    {isMenuOpen && (
                        <div className="absolute left-0 mt-2 w-48 bg-slate-800 border border-slate-700 rounded-md shadow-lg py-1 z-20">
                            {menuItems}
                        </div>
                    )}
                </div>
            );
        }

        return (
            <div className="flex items-center flex-wrap gap-2">
                <Tooltip text="Settings"><button onClick={onShowSettings} className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><SettingsIcon /></button></Tooltip>
                <Tooltip text="Report Issue or Submit Feedback"><a href="https://github.com/closedloopchaos/taiko/issues/new/choose" target="_blank" rel="noopener noreferrer" className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><BugIcon /></a></Tooltip>
                <Tooltip text="Generate Summary of Completed Tasks"><button onClick={onGenerateSummary} className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><DocumentTextIcon /></button></Tooltip>
                {showDeleteAllButton && <Tooltip text="Delete All Completed Tasks"><button onClick={onShowDeleteAllModal} className="p-2 text-red-400 hover:text-white rounded-full hover:bg-red-500 transition-colors"><DeleteIcon /></button></Tooltip>}
            </div>
        );
    });
    const PriorityColumn = React.memo(({ priority, tasks, isCollapsed, onToggleCollapse, showCompleted, isVerticalLayout, clockTimezone, isSwimlane = false, titleOverride = null, disableQuickAdd = false, isCompact }) => {
        const { addTask } = useAppContext();
        const [showQuickAdd, setShowQuickAdd] = useState(false); // State to show/hide quick add input

        const columnLayoutClasses = isVerticalLayout ? 'w-full' : 'flex-shrink-0 w-96 h-full';
        const config = PRIORITY_CONFIG[priority] || PRIORITY_CONFIG.null; // 'priority' can be PRIORITIES.LOW or null

        let displayTitleText = titleOverride || config.title;
        if (isSwimlane && !titleOverride && config.title !== PRIORITY_CONFIG.null.title) {
            displayTitleText = `${config.title} Priority`;
        } // "Unsorted" will use titleOverride

        const headerColorClass = titleOverride ? (isSwimlane ? 'text-slate-300' : 'text-slate-200') : config.color; // Generic color for "New Tasks", specific for priorities


        const headerContent = (
            <div className="flex items-center justify-between w-full">
                <span className="truncate flex-grow">{displayTitleText} ({tasks.length})</span>
                {isVerticalLayout && ( // Only show chevron in vertical mode
                    <ChevronDownIcon className={`transform transition-transform duration-200 flex-shrink-0 ${isCollapsed ? '-rotate-90' : 'rotate-0'}`} />
                )}
            </div>
        );
        
        const handleQuickAddTask = (titleFromInput) => {
            if (!titleFromInput.trim()) { setShowQuickAdd(false); return; }

            let taskPriorityToAdd = null;
            let taskTagsToAdd = []; // Default for "Unsorted" or priority columns

            if (titleOverride) { // "New Tasks" column
                taskPriorityToAdd = null;
                taskTagsToAdd = [];
            } else if (priority) { // Priority swimlane
                taskPriorityToAdd = priority; // The actual priority constant like PRIORITIES.LOW
                taskTagsToAdd = []; // DO NOT add the priority display title to tags array
            }
            
            addTask(titleFromInput.trim(), taskPriorityToAdd, taskTagsToAdd);
            setShowQuickAdd(false);
        };


        return (
            <div className={`flex flex-col rounded-lg ${columnLayoutClasses} ${isSwimlane ? 'bg-slate-900/40 border border-slate-700/60' : (titleOverride ? 'bg-slate-800/50 border border-slate-700/50' : 'bg-slate-900/30')}`}>
                {isVerticalLayout ? ( // Clickable header for vertical layout
                    <Tooltip text={isCollapsed ? "Expand column" : "Collapse column"}>
                        <button 
                            onClick={onToggleCollapse} 
                            className={`flex items-center w-full text-left text-lg font-bold p-2 rounded-t-lg ${headerColorClass} ${isSwimlane ? 'bg-slate-800/70 hover:bg-slate-700/70' : (titleOverride ? 'bg-slate-700/60 hover:bg-slate-600/60' : 'hover:bg-slate-700/50')} flex-shrink-0 transition-colors`}
                        >
                            <div className="flex-grow min-w-0">{headerContent}</div>
                            {!isCollapsed && !showQuickAdd && !disableQuickAdd && (
                                <Tooltip text={`Quick add to ${displayTitleText}`}>
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); setShowQuickAdd(true); }} 
                                        className="ml-2 p-1 rounded-full hover:bg-slate-600/50 flex-shrink-0"
                                    >
                                        <PlusIcon />
                                    </button>
                                </Tooltip>
                            )}
                        </button>
                    </Tooltip>
                ) : ( // Static header for horizontal layout
                    <div className={`flex items-center w-full text-left text-lg font-bold p-2 rounded-t-lg ${headerColorClass} ${isSwimlane ? 'bg-slate-800/70' : (titleOverride ? 'bg-slate-700/60' : 'bg-slate-900/60')} flex-shrink-0`}>
                        <div className="flex-grow min-w-0">{headerContent}</div>
                        {!showQuickAdd && !disableQuickAdd && (
                             <Tooltip text={`Quick add to ${displayTitleText}`}>
                                <button 
                                    onClick={() => setShowQuickAdd(true)} 
                                    className="ml-2 p-1 rounded-full hover:bg-slate-600/50 flex-shrink-0"
                                >
                                    <PlusIcon />
                                </button>
                            </Tooltip>
                        )}
                    </div>
                )}
                {showQuickAdd && !isCollapsed && (
                    <QuickAddInputForm onAdd={handleQuickAddTask} onCancel={() => setShowQuickAdd(false)} />
                )}
                <div className={`flex-grow p-2 transition-all duration-300 ease-in-out
                    ${isVerticalLayout ? 
                        (isCollapsed ? 'max-h-0 py-0 opacity-0 overflow-hidden' : 'max-h-full opacity-100 flex flex-col space-y-4') :
                        'max-h-full opacity-100 overflow-y-auto flex flex-col space-y-4' // Horizontal view remains the same
                    }
                `}>
                    {(!isVerticalLayout || !isCollapsed) && tasks.map((task) => (
                        <MemoizedTaskCard key={task.id} task={task} clockTimezone={clockTimezone} isCompact={isCompact} />
                    ))}
                </div>
            </div>
        );
    });

    const TagColumn = React.memo(({ tag, tasks, clockTimezone, isCollapsed, onToggleCollapse, isVerticalLayout, isBeingDragged, isCompact }) => {
        const { addTask } = useAppContext();
        const [showQuickAdd, setShowQuickAdd] = useState(false); // State to show/hide quick add input

        const columnLayoutClasses = isVerticalLayout ? 'w-full' : 'w-96 h-full';
        const dragStyle = isBeingDragged ? 'border-dashed border-sky-500' : 'border-indigo-800/50';

        const headerContent = (
            <div className="flex items-center justify-between w-full">
                <span className="truncate flex-grow">{tag} ({tasks.length})</span>
                {isVerticalLayout && <ChevronDownIcon className={`transform transition-transform duration-200 flex-shrink-0 ${isCollapsed ? '-rotate-90' : 'rotate-0'}`} />}
            </div>
        );

        const handleQuickAddTask = (titleFromInput) => {
            if (!titleFromInput.trim()) { setShowQuickAdd(false); return; }

            const priorityConstant = PRIORITY_TITLE_TO_CONSTANT_MAP[tag];

            if (priorityConstant) {
                addTask(titleFromInput.trim(), priorityConstant, []); // Set priority, no tags
            } else {
                addTask(titleFromInput.trim(), null, [tag]); // Null priority, add custom tag
            }
            setShowQuickAdd(false);
        };

        return (
            <div className={`flex flex-col overflow-x-hidden bg-indigo-900/20 backdrop-blur-sm border rounded-lg ${columnLayoutClasses} ${dragStyle} transition-all`}>
                {isVerticalLayout ? ( // Clickable header for vertical layout
                    <Tooltip text={isCollapsed ? "Expand column" : "Collapse column"}>
                        <button
                            onClick={onToggleCollapse}
                            className={`flex items-center w-full text-left text-lg font-bold p-2 rounded-t-lg text-indigo-300 bg-slate-900/60 hover:bg-slate-800/80 flex-shrink-0 transition-colors ${isBeingDragged ? 'cursor-grabbing' : 'cursor-pointer'}`}
                        >
                            <div className="flex-grow min-w-0">{headerContent}</div>
                            {!isCollapsed && !showQuickAdd && (
                                <Tooltip text={`Quick add to ${tag}`}>
                                    <button 
                                        onClick={(e) => { e.stopPropagation(); setShowQuickAdd(true); }} 
                                        className="ml-2 p-1 rounded-full hover:bg-slate-800/50 flex-shrink-0"
                                    >
                                        <PlusIcon />
                                    </button>
                                </Tooltip>
                            )}
                        </button>
                    </Tooltip>
                ) : (
                    <div className={`flex justify-between items-center w-full text-left text-lg font-bold p-2 rounded-t-lg text-indigo-300 bg-slate-900/60 flex-shrink-0 ${isBeingDragged ? 'cursor-grabbing' : 'cursor-grab'}`}>
                        <div className="flex-grow min-w-0">{headerContent}</div>
                         {!showQuickAdd && (
                            <Tooltip text={`Quick add to ${tag}`}>
                                <button 
                                    onClick={() => setShowQuickAdd(true)} 
                                    className="ml-2 p-1 rounded-full hover:bg-slate-800/50 flex-shrink-0"
                                >
                                    <PlusIcon />
                                </button>
                            </Tooltip>
                        )}
                    </div>
                )}
                {showQuickAdd && !isCollapsed && (
                    <QuickAddInputForm onAdd={handleQuickAddTask} onCancel={() => setShowQuickAdd(false)} />
                )}
                <div className={`flex-grow p-2 transition-all duration-300 ease-in-out
                    ${isVerticalLayout ?
                        (isCollapsed ? 'max-h-0 py-0 opacity-0 overflow-hidden' : 'max-h-full opacity-100 flex flex-col space-y-4') :
                        'max-h-full opacity-100 overflow-y-auto flex flex-col space-y-4' // Horizontal view remains the same
                    }
                `}>
                    {(!isVerticalLayout || !isCollapsed) && tasks.map(task => ( 
                        <MemoizedTaskCard key={task.id} task={task} clockTimezone={clockTimezone} isCompact={isCompact} />
                    ))}
                </div>
            </div>
        );
    });

    const Footer = React.memo(({ onShowReleaseNotes }) => {
        return (
            <footer className="bg-slate-900/80 backdrop-blur-sm p-3 text-center text-sm text-slate-400 shadow-t-lg z-40 flex-shrink-0">
                <div className="flex items-center justify-center space-x-4">
                    <div className="flex items-center justify-center space-x-1.5">
                        <span>Courtesy of</span>
                        <a href="https://github.com/closedloopchaos" target="_blank" rel="noopener noreferrer" className="inline-flex items-center text-sky-400 hover:text-sky-300 font-semibold hover:underline">
                            <svg className="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 16 16" aria-hidden="true">
                                <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
                            </svg>
                            closedloopchaos
                        </a>
                    </div>
                    <div className="border-l border-slate-600 h-5"></div>
                    <button onClick={onShowReleaseNotes} className="text-sky-400 hover:text-sky-300 font-semibold hover:underline">
                        Release Notes (v{CURRENT_APP_VERSION})
                    </button>
                </div>
            </footer>
        );
    });

    const QuickAddInputForm = React.memo(({ onAdd, onCancel, placeholder = "New task title..." }) => {
        const [internalValue, setInternalValue] = useState('');
        const inputRef = useRef(null);

        useEffect(() => {
            if (inputRef.current) inputRef.current.focus();
        }, []);

        const handleSubmit = () => {
            const trimmedValue = internalValue.trim();
            if (trimmedValue) {
                onAdd(trimmedValue);
                setInternalValue(''); // Reset for next potential use if not hidden immediately
            } else {
                // If input is empty and Enter/Add is pressed, effectively cancel.
                onCancel();
            }
        };

        return (
            <div className="p-2 border-b border-slate-700/50 bg-slate-800/30">
                <input
                    ref={inputRef}
                    type="text"
                    value={internalValue}
                    onChange={e => setInternalValue(e.target.value)}
                    onKeyDown={e => { if (e.key === 'Enter') handleSubmit(); if (e.key === 'Escape') onCancel(); }}
                    placeholder={placeholder}
                    className="w-full bg-slate-900/80 text-slate-200 text-sm p-2 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500"
                />
                <div className="mt-2 flex justify-end space-x-2">
                    <button onClick={onCancel} className="px-3 py-1 text-xs bg-slate-600 hover:bg-slate-500 rounded-md">Cancel</button>
                    <button onClick={handleSubmit} className="px-3 py-1 text-xs bg-sky-600 hover:bg-sky-500 rounded-md">Add Task</button>
                </div>
            </div>
        );
    });

    const AddTaskButton = React.memo(({ onAddTask }) => {
        return (
            <div className="relative">
                <Tooltip text="Add a new task">
                    <button 
                        onClick={onAddTask} 
                        className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg shadow-md hover:bg-sky-500 focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-opacity-75 transition-all"
                    >
                        + Add Task
                    </button>
                </Tooltip>
            </div>
        );
    });

    const AddTaskModal = ({ onAdd, onCancel, allTags }) => {
        const [title, setTitle] = useState('');
        const [priority, setPriority] = useState(null);
        const [tags, setTags] = useState([]);
        const [currentTagInput, setCurrentTagInput] = useState('');
        const inputRef = useRef(null);

        useEffect(() => {
            if (inputRef.current) inputRef.current.focus();
        }, []);

        const handleAdd = () => {
            if (title.trim()) {
                onAdd({ title: title.trim(), priority, tags });
            }
        };

        const handleAddTag = () => {
            const trimmedTag = currentTagInput.trim();
            if (trimmedTag && !tags.includes(trimmedTag)) {
                setTags([...tags, trimmedTag]);
            }
            setCurrentTagInput('');
        };

        const handleRemoveTag = (tagToRemove) => {
            setTags(tags.filter(tag => tag !== tagToRemove));
        };

        return (
            <Modal onClose={onCancel}>
                <ModalContent title="Add New Task" onClose={onCancel}>
                    <div className="space-y-4">
                        {/* Title Input */}
                        <input
                            ref={inputRef}
                            type="text"
                            value={title}
                            onChange={e => setTitle(e.target.value)}
                            onKeyDown={e => { if (e.key === 'Enter' && !e.shiftKey) handleAdd(); }}
                            placeholder="Enter task title..."
                            className="w-full bg-slate-900/80 text-slate-200 text-lg p-3 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500"
                        />

                        {/* Priority Selection */}
                        <div className="pt-2 border-t border-slate-700/50">
                            <div className="flex flex-wrap items-center gap-2">
                                <span className="text-sm text-slate-400">Priority:</span>
                                {DISPLAY_PRIORITY_ORDER.map(pConst => (
                                    <Tooltip key={pConst} text={`Set priority to ${PRIORITY_CONFIG[pConst].title}`}>
                                        <button 
                                            onClick={() => setPriority(pConst === priority ? null : pConst)}
                                            className={`px-3 py-1 text-xs font-semibold rounded-md border transition-colors ${priority === pConst ? `${PRIORITY_CONFIG[pConst].bgColor} ${PRIORITY_CONFIG[pConst].borderColor} ${PRIORITY_CONFIG[pConst].color}` : `bg-slate-600/50 border-slate-500 text-slate-300 hover:${PRIORITY_CONFIG[pConst].bgColor}`}`}
                                        >
                                            {PRIORITY_CONFIG[pConst].title}
                                        </button>
                                    </Tooltip>
                                ))}
                            </div>
                        </div>

                        {/* Tagging UI */}
                        <div className="pt-2 border-t border-slate-700/50">
                            <label className="text-sm text-slate-400 mb-2 block">Tags:</label>
                            <div className="flex flex-wrap gap-2 mb-2">
                                {tags.map(tag => (
                                    <span key={tag} className="bg-slate-700 text-xs text-slate-200 px-2 py-1 rounded-full flex items-center">
                                        {tag}
                                        <Tooltip text={`Remove tag: ${tag}`}>
                                            <button onClick={() => handleRemoveTag(tag)} className="ml-2 text-slate-400 hover:text-white leading-none">&times;</button>
                                        </Tooltip>
                                    </span>
                                ))}
                            </div>
                            <div className="flex">
                                <input
                                    list="tag-suggestions-modal"
                                    type="text"
                                    value={currentTagInput}
                                    onChange={(e) => setCurrentTagInput(e.target.value)}
                                    onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault(); handleAddTag(); } }}
                                    placeholder="Add a tag..."
                                    className="bg-slate-900/50 text-slate-200 text-sm p-2 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500 flex-grow min-w-0"
                                />
                                <datalist id="tag-suggestions-modal">
                                    {allTags.map(tag => <option key={tag} value={tag} />)}
                                </datalist>
                                <Tooltip text="Add this tag">
                                    <button onClick={handleAddTag} className="ml-2 text-sm bg-sky-600 text-white px-4 py-1 rounded-md hover:bg-sky-500">Add</button>
                                </Tooltip>
                            </div>
                        </div>

                        {/* Action Buttons */}
                        <div className="flex justify-end space-x-2 pt-3 border-t border-slate-700/50">
                            <button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button>
                            <button onClick={handleAdd} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500">Add Task</button>
                        </div>
                    </div>
                </ModalContent>
            </Modal>
        );
    };

    const Modal = ({ children, onClose }) => <div onClick={onClose} className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4">{children}</div>;
    const ModalContent = ({ title, children, onClose, headerActions }) => (
        <div 
            className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-md text-white flex flex-col max-h-[90vh]"
            onClick={e => e.stopPropagation()}
        >
            <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                <h3 className="text-xl font-bold">{title}</h3>
                {headerActions && <div>{headerActions}</div>}
            </div>
            <div className="p-4 overflow-y-auto">{children}</div>
        </div>
    );
    const CompleteConfirmationModal = ({ task, onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Mark Task as Complete?</h3><p className="text-slate-300 mb-4">This will move the task "{task.title}" to the completed view.</p><div className="flex justify-center space-x-4"><Tooltip text="Keep task active"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button></Tooltip><Tooltip text="Confirm completion"><button onClick={onConfirm} className="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-500">Mark as Complete</button></Tooltip></div></div></Modal>;
    const DeleteConfirmationModal = ({ onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Delete Task?</h3><p className="text-slate-300 mb-4">Are you sure you want to permanently delete this task?</p><div className="flex justify-center space-x-4"><Tooltip text="Cancel deletion"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button></Tooltip><Tooltip text="Confirm permanent deletion"><button onClick={onConfirm} className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-500">Delete</button></Tooltip></div></div></Modal>;
    const SettingsModal = ({ settings, onSettingsChange, onClose }) => { 
        const handleToggle = (key) => onSettingsChange(p => ({ ...p, [key]: !p[key] })); 
        const handleAnimationSettingChange = (key, value) => onSettingsChange(p => ({ ...p, animationSettings: { ...p.animationSettings, [key]: value } }));
        return ( 
            <Modal onClose={onClose}>
                <ModalContent title="Settings" onClose={onClose}>
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Confirm on Delete</label>
                            <Tooltip text={settings.confirmOnDelete ? "Disable delete confirmation" : "Enable delete confirmation"}>
                                <button onClick={() => handleToggle('confirmOnDelete')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.confirmOnDelete ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.confirmOnDelete ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Show Tooltips</label>
                            <Tooltip text={settings.showTooltips ? "Disable Tooltips" : "Enable Tooltips"}>
                                <button onClick={() => handleToggle('showTooltips')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.showTooltips ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.showTooltips ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Auto-collapse Empty Columns</label>
                            <Tooltip text={settings.autoCollapse ? "Disable auto-collapse" : "Enable auto-collapse"}>
                                <button onClick={() => handleToggle('autoCollapse')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.autoCollapse ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.autoCollapse ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Compact View</label>
                            <Tooltip text={settings.compactView ? "Switch to default view" : "Switch to compact view"}>
                                <button onClick={() => handleToggle('compactView')} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.compactView ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.compactView ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </Tooltip>
                        </div>
                        <div className="pt-4 border-t border-slate-700/50 space-y-4">
                            <h4 className="text-lg font-semibold text-slate-200">Background Animation</h4>
                            <div className="flex items-center justify-between">
                                <label className="text-slate-300">Enable Animation</label>
                                <Tooltip text={settings.animationSettings.enabled ? "Disable background animation" : "Enable background animation"}>
                                    <button onClick={() => handleAnimationSettingChange('enabled', !settings.animationSettings.enabled)} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.animationSettings.enabled ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.animationSettings.enabled ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                                </Tooltip>
                            </div>
                            <div className="flex flex-col space-y-2">
                                <label htmlFor="particleCount" className="text-slate-300 flex justify-between">
                                    <span>Particle Count</span>
                                    <span className="text-sky-400 font-mono">{settings.animationSettings.particleCount}</span>
                                </label>
                                <input id="particleCount" type="range" min="250" max="500" step="5"
                                    value={settings.animationSettings.particleCount}
                                    onChange={e => handleAnimationSettingChange('particleCount', parseInt(e.target.value, 10))}
                                    disabled={!settings.animationSettings.enabled}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                                />
                            </div>
                            <div className="flex flex-col space-y-2">
                                <label htmlFor="connectionDistance" className="text-slate-300 flex justify-between">
                                    <span>Connection Distance</span>
                                    <span className="text-sky-400 font-mono">{settings.animationSettings.connectionDistance}px</span>
                                </label>
                                <input id="connectionDistance" type="range" min="30" max="250" step="5"
                                    value={settings.animationSettings.connectionDistance}
                                    onChange={e => handleAnimationSettingChange('connectionDistance', parseInt(e.target.value, 10))}
                                    disabled={!settings.animationSettings.enabled}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                                />
                            </div>
                            <div className="flex flex-col space-y-2">
                                <label htmlFor="particleSpeed" className="text-slate-300 flex justify-between">
                                    <span>Particle Speed</span>
                                    <span className="text-sky-400 font-mono">{settings.animationSettings.particleSpeed.toFixed(1)}</span>
                                </label>
                                <input id="particleSpeed" type="range" min="0.1" max="2" step="0.1"
                                    value={settings.animationSettings.particleSpeed}
                                    onChange={e => handleAnimationSettingChange('particleSpeed', parseFloat(e.target.value))}
                                    disabled={!settings.animationSettings.enabled}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                                />
                            </div>
                        </div>
                    </div>
                </ModalContent>
            </Modal> 
        );
    };
    const DeleteAllCompletedModal = ({ onConfirm, onCancel, count }) => (
        <Modal onClose={onCancel}>
            <div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Delete All Completed Tasks?</h3><p className="text-slate-300 mb-4">Are you sure you want to permanently delete all {count} completed tasks? This action cannot be undone.</p><div className="flex justify-center space-x-4"><Tooltip text="Cancel deletion"><button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button></Tooltip><Tooltip text="Confirm permanent deletion of all completed tasks"><button onClick={onConfirm} className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-500">Delete All</button></Tooltip></div></div>
        </Modal>
    );

    const SummaryModal = ({ summary, onClose }) => {
        const [copyButtonText, setCopyButtonText] = useState('Copy to Clipboard');

        const handleCopy = useCallback(() => {
            if (!navigator.clipboard) {
                console.error('Clipboard API not available.');
                setCopyButtonText('Copy failed');
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
                return;
            }
            navigator.clipboard.writeText(summary).then(() => {
                setCopyButtonText('Copied!');
                playTone(880, 0.1, 'sine', 0.2); // Success sound
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                setCopyButtonText('Failed to copy');
                playTone(220, 0.2, 'square', 0.2); // Error sound
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
            });
        }, [summary]);

        return (
            <Modal onClose={onClose}>
                <div className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-3xl text-white flex flex-col overflow-x-hidden max-h-[90vh]" onClick={e => e.stopPropagation()}>
                    <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                        <h3 className="text-xl font-bold">Completed Tasks Summary</h3>
                        <div className="flex items-center space-x-2">
                            <Tooltip text="Copy summary to your clipboard">
                                <button onClick={handleCopy} className="px-3 py-1 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500 text-sm transition-all duration-150 w-36 text-center">{copyButtonText}</button>
                            </Tooltip>
                            <Tooltip text="Close this summary">
                                <button onClick={onClose} className="px-4 py-1 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500 text-sm">Done</button>
                            </Tooltip>
                        </div>
                    </div>
                    <div className="p-4 overflow-y-auto"><pre className="text-sm text-slate-300 whitespace-pre-wrap font-mono bg-slate-900/50 p-4 rounded-md border border-slate-700">{summary}</pre></div>
                </div>
            </Modal>
        );
    };

    const ReleaseNotesModal = ({ version, releaseInfo, onClose }) => {
        if (!releaseInfo) return null;

        return (
            <Modal onClose={onClose}>
                <div className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-2xl text-white flex flex-col max-h-[90vh]" onClick={e => e.stopPropagation()}>
                    <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                        <h3 className="text-xl font-bold">{releaseInfo.title}</h3>
                        <Tooltip text="Close Release Notes">
                            <button onClick={onClose} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500 text-sm">Got it!</button>
                        </Tooltip>
                    </div>
                    <div className="p-6 overflow-y-auto space-y-4">
                        {releaseInfo.notes.map((note, index) => (
                            <div key={index} className="bg-slate-900/50 p-4 rounded-lg border border-slate-700">
                                <h4 className="font-bold text-sky-300 mb-1">{note.title}</h4>
                                <p className="text-sm text-slate-300">{note.description}</p>
                            </div>
                        ))}
                    </div>
                </div>
            </Modal>
        );
    };

    // --- App Entry Point ---
    const AppContainer = () => {
        return <App />;
    };

    const TaikoApp = () => {
        return (
            <AppProvider>
                <AppContainer />
            </AppProvider>
        );
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<TaikoApp />);

    </script>

    <!-- Node Garden Background Animation Script -->
    <script>
        const canvas = document.getElementById('node-garden-canvas');
        const ctx = canvas.getContext('2d');

        // --- Default Animation Settings ---
        let animSettings = {
            enabled: true,
            particleCount: window.innerWidth > 768 ? 100 : 40,
            connectionDistance: 120,
            particleSpeed: 0.5,
        };

        let particles = [];
        const mouse = { x: null, y: null, radius: 150 };
        let animationFrameId;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Use a smaller radius on mobile for a more subtle effect
            mouse.radius = canvas.width < 768 ? (canvas.width / 15) + 20 : (canvas.width / 12) + 50;
            // On resize, if animation is enabled, re-initialize to distribute particles evenly.
            if (animSettings.enabled) {
                init();
            }
        }

        window.addEventListener('resize', () => {
            resizeCanvas(); // This will call init() if needed
        });

        window.addEventListener('mousemove', (event) => {
            mouse.x = event.x;
            mouse.y = event.y;
        });

        window.addEventListener('mouseout', () => {
            mouse.x = null;
            mouse.y = null;
        });

        // Listen for settings changes from React
        window.addEventListener('animationSettingsChange', (event) => {
            const oldSettings = { ...animSettings };
            animSettings = { ...animSettings, ...event.detail };

            if (animSettings.enabled && !oldSettings.enabled) {
                startAnimation(); // Start if it was just enabled
            } else if (!animSettings.enabled && oldSettings.enabled) {
                stopAnimation(); // Stop if it was just disabled
            } else if (animSettings.enabled && animSettings.particleCount !== oldSettings.particleCount) {
                init(); // Re-initialize if particle count changes while enabled
            } else if (animSettings.enabled && animSettings.particleSpeed !== oldSettings.particleSpeed) {
                // Adjust speed of existing particles without re-initializing
                const speedRatio = oldSettings.particleSpeed > 0 ? animSettings.particleSpeed / oldSettings.particleSpeed : 1;
                particles.forEach(p => {
                    p.vx *= speedRatio;
                    p.vy *= speedRatio;
                });
            }
        });

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.baseSize = Math.random() * 1.5 + 0.5;
                this.size = this.baseSize;
                this.density = (Math.random() * 30) + 1;
                this.defaultColor = 'rgba(100, 116, 139, 0.8)'; // slate-500
                this.vx = (Math.random() - 0.5) * animSettings.particleSpeed; // Velocity X
                this.vy = (Math.random() - 0.5) * animSettings.particleSpeed; // Velocity Y
                // For pulsing effect
                this.pulseAngle = Math.random() * Math.PI * 2;
                this.pulseSpeed = 0.02 + Math.random() * 0.02;
            }

            draw() {
                ctx.fillStyle = this.currentColor || this.defaultColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }

            update() {
                // Autonomous movement and wall bouncing
                this.x += this.vx;
                this.y += this.vy;
                if (this.x <= 0 || this.x >= canvas.width) { this.vx *= -1; }
                if (this.y <= 0 || this.y >= canvas.height) { this.vy *= -1; }

                // Pulsing effect
                this.pulseAngle += this.pulseSpeed;
                this.size = this.baseSize + Math.sin(this.pulseAngle) * (this.baseSize * 0.5);

                // Mouse interaction - determine color
                this.currentColor = null; // Reset color
                if (mouse.x !== null) {
                    let dx = mouse.x - this.x;
                    let dy = mouse.y - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    this.currentColor = getColorFromDistance(distance, mouse.radius);
                }
            }
        }

        // Helper function to get color based on distance to mouse
        function getColorFromDistance(distance, maxDistance) {
            if (distance < maxDistance) {
                const normalizedDistance = distance / maxDistance; // 0 (closest) to 1 (farthest)
                let r, g, b;
                
                // Gradient: Red -> Yellow -> Green
                if (normalizedDistance < 0.5) {
                    // Interpolate from Red (239, 68, 68) to Yellow (251, 191, 36)
                    const t = normalizedDistance * 2; // Scale to 0-1 range
                    r = 239 + (251 - 239) * t;
                    g = 68 + (191 - 68) * t;
                    b = 68 + (36 - 68) * t;
                } else {
                    // Interpolate from Yellow (251, 191, 36) to Green (34, 197, 94)
                    const t = (normalizedDistance - 0.5) * 2; // Scale to 0-1 range
                    r = 251 + (34 - 251) * t;
                    g = 191 + (197 - 191) * t;
                    b = 36 + (94 - 36) * t;
                }
                return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
            }
            return null;
        }

        function init() {
            if (!animSettings.enabled) return;
            particles = [];
            for (let i = 0; i < animSettings.particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function animate() {
            if (!animSettings.enabled) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw connecting lines
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < animSettings.connectionDistance) {
                        ctx.beginPath();
                        
                        let strokeStyle = `rgba(100, 116, 139, ${1 - distance / animSettings.connectionDistance})`;
                        
                        // Check for mouse interaction color
                        if (mouse.x !== null) {
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            const mouseDx = mouse.x - midX;
                            const mouseDy = mouse.y - midY;
                            const midPointDistanceToMouse = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);
                            const lineColor = getColorFromDistance(midPointDistanceToMouse, mouse.radius);
                            
                            if (lineColor) {
                                // Extract the RGB part and add the alpha from the original style
                                const alpha = 1 - distance / animSettings.connectionDistance;
                                strokeStyle = lineColor.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                            }
                        }

                        ctx.strokeStyle = strokeStyle;
                        ctx.lineWidth = 0.4;
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }

            // Update and draw each particle
            particles.forEach(p => { p.update(); p.draw(); });

            animationFrameId = requestAnimationFrame(animate);
        }

        function startAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            init();
            animate();
        }

        function stopAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        resizeCanvas();
        startAnimation();
    </script>
</body>
</html>
