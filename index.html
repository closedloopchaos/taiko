<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taiko</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom CSS for animations and theming -->
    <style>
        body {
            font-family: sans-serif;
            background-color: #0f172a; /* Fallback background */
        }
        .transition-all {
            /* Use a smoother easing curve for all transitions */
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        }
        .pulse-border-high { animation: pulse-border-high 1.2s infinite; }
        @keyframes pulse-border-high { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0.9); } 
            50% { box-shadow: 0 0 0 6px rgba(248, 113, 113, 0); } 
        }
        .pulse-border-medium { animation: pulse-border-medium 1.8s infinite; }
        @keyframes pulse-border-medium { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.8); } 
            50% { box-shadow: 0 0 0 5px rgba(251, 191, 36, 0); } 
        }
        .pulse-border-low { animation: pulse-border-low 2.5s infinite; }
        @keyframes pulse-border-low { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.7); } 
            50% { box-shadow: 0 0 0 4px rgba(56, 189, 248, 0); } 
        }
        .pulse-border-default { animation: pulse-border-default 2s infinite; }
        @keyframes pulse-border-default { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(100, 116, 139, 0.7); } /* slate-500 like for default pulse */
            50% { box-shadow: 0 0 0 5px rgba(100, 116, 139, 0); } 
        }
	:root {
	    --scrollbar-background: #273346;
            --scrollbar-thumb-background: #394b67;
            --scrollbar-thumb-border: #333;
            --scrollbar-track-background: #273346;
        }
        
        /* Style the scrollbar */
	::-webkit-scrollbar {
	    width: 8px;
	    height: 8px;
	}

        ::-webkit-scrollbar-thumb {
	    background-color: var(--scrollbar-thumb-background);
            border: 1px solid var(--scrollbar-thumb-border);
	    border-radius: 4px;
	}

	::-webkit-scrollbar-track {
	    background-color: var(--scrollbar-track-background);
	}

	::-webkit-scrollbar-corner {
	    background-color: var(--scrollbar-background);
	}

        #node-garden-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Places the canvas behind all other content */
        }
    </style>
</head>
<body>
    <canvas id="node-garden-canvas"></canvas>
    <div id="root"></div>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel Standalone for JSX Transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Main Application Logic -->
    <script type="text/babel">

    const { useState, useEffect, useRef, useCallback, createContext, useContext, useMemo } = React;


    // -----------------------------------------------------------------------------------------------------------------------------  THIS IS WHERE THE RELEASE NOTES ARE -----------------------------------------------------------------------------------------------------------------------------
    // --- Global Constants & Configurations ---
    const CURRENT_APP_VERSION = '1.3.1';

    const RELEASE_NOTES = {
        '1.0.0': {
            title: "Version 1.0.0",
            notes: [
                {
                    title: "🚀 Initial Launch",
                    description: "The first version of Taiko is here! A simple, clean, and effective task manager designed to help you focus."
                }
            ]
        },
        '1.2.0': {
            title: "Previous Version: 1.2.0",
            notes: [
                {
                    title: "✅ Core Task Management",
                    description: "Create, edit, and delete tasks. Set priorities (High, Medium, Low) and organize them into projects."
                },
                {
                    title: "⚙️ Project & Filter System",
                    description: "Filter tasks by project or priority to focus on what matters most. Manage projects with ease."
                },
                {
                    title: "✨ Interactive Background",
                    description: "Enjoy a dynamic, interactive particle animation in the background, with settings to customize the experience."
                }
            ]
        },
        '1.3.0': {
            title: "Previous Version: 1.3.0",
            notes: [
                {
                    title: "✨ New UI: Master-Detail Layout",
                    description: "The application has been redesigned with a master-detail layout. Browse a compact list of tasks on the left and see the full details of your selected task on the right."
                },
                {
                    title: "📂 New Feature: Project-Based Views",
                    description: "Click on any project header in the task list to view all tasks within that project together in the detail pane, making it easier to focus on specific workstreams."
                },
                {
                    title: "🎨 Redesigned Task Cards & Filters",
                    description: "Task cards have been updated for better clarity within the new layout, and the filtering UI has been streamlined into a single, easy-to-use dropdown menu."
                }
            ]
        },
        '1.3.1': {
            title: "What's New in Version 1.3.1",
            notes: [
                {
                    title: "🔗 Dependency Management UX",
                    description: "The user experience for managing task dependencies has been improved. When adding a downstream dependency (blocking another task), the UI is now cleaner and more consistent with the surrounding elements."
                },
                {
                    title: "🚫 Proactive Circular Dependency Prevention",
                    description: "To prevent errors, the app now stops you from creating circular dependencies before you can even select an invalid task. The dropdown list for blocking tasks will automatically filter out any options that would result in a dependency loop."
                }
            ]
        }
    }; // Versions should be in ascending order for display logic


    const PRIORITIES = { // These are the internal constant values
        LOW: 'PRIORITY_LOW', // Actual tag string
        MEDIUM: 'PRIORITY_MEDIUM',
        HIGH: 'PRIORITY_HIGH'
    };

    const getPrioritySortValue = (priority) => {
        if (priority === PRIORITIES.HIGH) return 0;
        if (priority === PRIORITIES.MEDIUM) return 1;
        if (priority === PRIORITIES.LOW) return 2;
        return 3; // For null or undefined priority (Unprioritized)
    };

    // PRIORITY_CONFIG must be defined after PRIORITIES and before constants that use it.
    // We will add sound generation parameters here later if needed, or handle in the playSound function.
    const PRIORITY_CONFIG = {
        [PRIORITIES.LOW]: { title: "Low", color: "text-sky-400", bgColor: "bg-sky-500/20", borderColor: "border-sky-500", pulseClass: 'pulse-border-low' },
        [PRIORITIES.MEDIUM]: { title: "Medium", color: "text-yellow-400", bgColor: "bg-yellow-500/20", borderColor: "border-yellow-500", pulseClass: 'pulse-border-medium' },
        [PRIORITIES.HIGH]: { title: "High", color: "text-red-400", bgColor: "bg-red-500/20", borderColor: "border-red-500", pulseClass: 'pulse-border-high' },
        null: { title: "Unprioritized", color: "text-slate-400", bgColor: "bg-slate-500/10", borderColor: "border-slate-600", pulseClass: 'pulse-border-default' } // For null priority
    };

    const PRIORITY_TITLE_TO_CONSTANT_MAP = Object.fromEntries( // e.g., { "Low": "PRIORITY_LOW", ... }
        Object.values(PRIORITIES).map(pConstant => [PRIORITY_CONFIG[pConstant]?.title, pConstant]).filter(([title]) => title)
    ); // e.g., { "Low": "PRIORITY_LOW", ... }

    const TASK_STATUS = { TO_DO: 'To Do', DONE: 'Completed' };
    const TIMEZONES = [
        { value: 'America/New_York', label: 'EST' },
        { value: 'America/Chicago', label: 'CST' },
        { value: 'America/Denver', label: 'MST' },
        { value: 'America/Los_Angeles', label: 'PST' },
        { value: 'UTC', label: 'UTC' },
    ];
    const TASK_STATUS_CONFIG = {
        [TASK_STATUS.TO_DO]: { 
            label: 'To Do', 
            selectBgColor: 'bg-sky-900/50', 
            accentClass: 'bg-sky-400',
            glowClass: 'shadow-[0_0_15px_-4px_rgba(56,189,248,0.5)] hover:shadow-[0_0_18px_-3px_rgba(56,189,248,0.7)]'
        },
        [TASK_STATUS.DONE]: { 
            label: 'Completed', 
            selectBgColor: 'bg-green-900/50', 
            accentClass: 'bg-green-500',
            glowClass: 'shadow-[0_0_12px_-5px_rgba(34,197,94,0.5)]' // More subtle glow for "Done"
        }
    };

    const TASK_SIZES = {
        F1: 'F1 (S)',
        F9: 'F9 (M)',
        FH: 'FH (L)',
        STARSHIP: 'Starship (XL)',
    };

    // --- Web Audio API Sound Generation ---
    let audioContext = null;
    const getAudioContext = () => {
        if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioContext;
    };

    const playTone = (frequency, duration = 0.5, type = 'sine', volume = 0.3) => {
        const actx = getAudioContext();
        if (!actx) {
            console.warn("Web Audio API is not supported in this browser.");
            return;
        }

        const oscillator = actx.createOscillator();
        const gainNode = actx.createGain();

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, actx.currentTime);
        gainNode.gain.setValueAtTime(volume, actx.currentTime);
        // Simple fade out to avoid clicking
        gainNode.gain.linearRampToValueAtTime(0.0001, actx.currentTime + duration - 0.05);

        oscillator.connect(gainNode);
        gainNode.connect(actx.destination);

        oscillator.start();
        oscillator.stop(actx.currentTime + duration);
    };

    // --- Context for State Management ---
    const AppContext = createContext(null);

    // --- Provider Component ---
    const AppProvider = ({ children }) => {
        // --- Core State ---
        const [tasks, setTasks] = useState([]);
        const [projectSettings, setProjectSettings] = useState({});
        const [settings, setSettings] = useState({ 
            confirmOnDelete: true, 
            animationSettings: { enabled: true, particleCount: 350, connectionDistance: 200, particleSpeed: 0.3, mouseInteraction: true, clickPulse: true }
        });

        // --- Modal-related State ---
        const [taskToDelete, setTaskToDelete] = useState(null);
        // --- UI Interaction State (lifted from App) ---
        const [selectedTaskId, setSelectedTaskId] = useState(null);
        const [activeTags, setActiveTags] = useState([]); // For filtering
        const [collapsedProjects, setCollapsedProjects] = useState({ 'Completed': true });


        const appId = 'taiko-app-local';

        // --- Data Migration Effect ---
        useEffect(() => {
            const savedTasks = localStorage.getItem(`${appId}-tasks`);
            if (savedTasks) {
                let tasksToMigrate = JSON.parse(savedTasks);
                // Migration: Add 'createdAt' field if it doesn't exist, using the existing 'timestamp' as a fallback.
                // Also add 'activityLog' array and 'size' field, and handle legacy 'size' values.
                const needsMigration = tasksToMigrate.some(t => !t.createdAt || !t.activityLog || t.size === undefined || (!Object.keys(TASK_SIZES).includes(t.size) && t.size !== null) || !t.dependsOn);
                if (needsMigration) {
                    tasksToMigrate = tasksToMigrate.map(t => ({ 
                        ...t, 
                        // If size is an old value (like 'XS', 'S', etc.), reset it to null.
                        // Otherwise, keep its value or set it to null if it's undefined.
                        size: t.size !== undefined && t.size !== null && Object.keys(TASK_SIZES).includes(t.size) ? t.size : null,
                        dependsOn: t.dependsOn || [],
                        createdAt: t.createdAt || t.timestamp,
                        activityLog: t.activityLog || [{ message: 'Task created.', timestamp: t.createdAt || t.timestamp }]
                    }));
                    localStorage.setItem(`${appId}-tasks`, JSON.stringify(tasksToMigrate));
                }
            }
        }, [appId]);
        // --- Local Storage Persistence ---
        useEffect(() => {
            const savedTasks = localStorage.getItem(`${appId}-tasks`);
            if (savedTasks) try { setTasks(JSON.parse(savedTasks)); } catch { console.error("Could not parse saved tasks."); }
            
            const defaultSettings = {
                confirmOnDelete: true,
                animationSettings: { enabled: true, particleCount: 350, connectionDistance: 200, particleSpeed: 0.3, mouseInteraction: true, clickPulse: true }
            };

            const savedSettings = localStorage.getItem(`${appId}-settings`);
            if (savedSettings) {
                try { 
                    const parsed = JSON.parse(savedSettings);
                    // Deep merge for animationSettings
                    const mergedSettings = {
                        ...defaultSettings, ...parsed,
                        animationSettings: { ...defaultSettings.animationSettings, ...(parsed.animationSettings || {}) }
                    };
                    setSettings(mergedSettings);
                } catch { 
                    console.error("Could not parse saved settings. Using defaults.");
                    setSettings(defaultSettings); // Fallback to defaults on parse error
                }
            } else {
                setSettings(defaultSettings); // No saved settings, use defaults
            }

            const savedActiveTags = localStorage.getItem(`${appId}-activeTags`);
            if (savedActiveTags) try { setActiveTags(JSON.parse(savedActiveTags)); } catch { console.error("Could not parse saved active tags."); setActiveTags([]); }

            const defaultCollapsedProjects = { 'Completed': true };
            const savedCollapsedProjects = localStorage.getItem(`${appId}-collapsedProjects`);
            if (savedCollapsedProjects) {
                try {
                    setCollapsedProjects(JSON.parse(savedCollapsedProjects));
                } catch {
                    setCollapsedProjects(defaultCollapsedProjects);
                }
            } else {
                setCollapsedProjects(defaultCollapsedProjects);
            }

            const savedProjectSettings = localStorage.getItem(`${appId}-projectSettings`);
            if (savedProjectSettings) try { setProjectSettings(JSON.parse(savedProjectSettings)); } catch { console.error("Could not parse saved project settings."); }
        }, [appId]); 
        useEffect(() => {
            const savedSelectedTask = localStorage.getItem(`${appId}-selectedTaskId`);
            if (savedSelectedTask) try { setSelectedTaskId(JSON.parse(savedSelectedTask)); } catch { console.error("Could not parse saved selected task."); setSelectedTaskId(null); }
        }, [appId]);

        // --- Consolidated Local Storage Persistence ---
        useEffect(() => {
            try {
                localStorage.setItem(`${appId}-tasks`, JSON.stringify(tasks));
                localStorage.setItem(`${appId}-settings`, JSON.stringify(settings));
                localStorage.setItem(`${appId}-projectSettings`, JSON.stringify(projectSettings));
                localStorage.setItem(`${appId}-activeTags`, JSON.stringify(activeTags));
                localStorage.setItem(`${appId}-collapsedProjects`, JSON.stringify(collapsedProjects));
                localStorage.setItem(`${appId}-selectedTaskId`, JSON.stringify(selectedTaskId));
            } catch (error) {
                console.error("Failed to save state to localStorage", error);
            }
        }, [tasks, settings, projectSettings, activeTags, collapsedProjects, selectedTaskId, appId]);

        // --- Effect to dispatch animation settings changes to the global scope ---
        useEffect(() => {
            const event = new CustomEvent('animationSettingsChange', { detail: settings.animationSettings });
            window.dispatchEvent(event);
        }, [settings.animationSettings]);

        // --- Effect to auto-collapse 'Completed' project when it becomes empty ---
        useEffect(() => {
            const completedCount = tasks.filter(task => task.status === TASK_STATUS.DONE).length;
            if (completedCount === 0) {
                if (collapsedProjects['Completed'] !== true) {
                    setCollapsedProjects(prev => ({ ...prev, 'Completed': true }));
                }
            }
        }, [tasks, collapsedProjects]); // Reruns when tasks change

        // When filters change, or tasks are deleted, make sure the selected task is still visible.
        useEffect(() => {
            if (selectedTaskId && !tasks.find(t => t.id === selectedTaskId)) {
                setSelectedTaskId(null);
            }
        }, [tasks, selectedTaskId]);


        // --- Core Data Actions ---
        const updateTask = useCallback((id, updatedFields, logMessage) => {
            const now = new Date().toISOString();
            setTasks(prevTasks => prevTasks.map(task => {
                if (task.id !== id) return task;

                // Create a new activity log entry if a message is provided
                const newActivityLog = task.activityLog ? [...task.activityLog] : [];
                if (logMessage) {
                    newActivityLog.push({ message: logMessage, timestamp: now });
                }

                // Handle specific field changes to generate log messages automatically
                if (updatedFields.priority !== undefined && updatedFields.priority !== task.priority) {
                    const oldP = PRIORITY_CONFIG[task.priority]?.title || 'none';
                    const newP = PRIORITY_CONFIG[updatedFields.priority]?.title || 'none';
                    newActivityLog.push({ message: `Priority changed from ${oldP} to ${newP}.`, timestamp: now });
                }
                if (updatedFields.project !== undefined && updatedFields.project !== task.project) {
                    const oldProj = task.project || 'Unassigned';
                    newActivityLog.push({ message: `Moved from project "${oldProj}" to "${updatedFields.project || 'Unassigned'}".`, timestamp: now });
                }
                if (updatedFields.size !== undefined && updatedFields.size !== task.size) {
                    const newSize = updatedFields.size ? TASK_SIZES[updatedFields.size] : 'Not Set';
                    newActivityLog.push({ message: `Size set to ${newSize}.`, timestamp: now });
                }
                if (updatedFields.status !== undefined && updatedFields.status !== task.status) {
                    newActivityLog.push({ message: `Status changed to ${updatedFields.status}.`, timestamp: now });
                }

                return { ...task, ...updatedFields, timestamp: now, activityLog: newActivityLog };
            }));
        }, []);
        
        const addTask = useCallback((initialTitle = 'New Task', initialProject = null, initialPriority = null) => {
            const now = new Date().toISOString();
            const newTask = {
                id: crypto.randomUUID(),
                title: initialTitle, 
                checklist: [],
                priority: initialPriority, 
                status: 'To Do',
                createdAt: now,
                timestamp: now, 
                project: initialProject,
                notes: '', 
                reminderAt: null,
                reminderFired: false,
                timeSpentSeconds: 0, 
                timingSessionStartTime: null,
                dueDate: null,
                tags: [],
                activityLog: [{ message: 'Task created.', timestamp: now }],
                size: null,
                dependsOn: []
            };
            setTasks(prevTasks => [newTask, ...prevTasks]);
            return newTask; // Return the new task so we can select it
        }, []);

        const deleteTask = useCallback((id) => {
            setTasks(prevTasks => prevTasks.filter(task => task.id !== id));
        }, []);

        const deleteAllCompletedTasks = useCallback(() => {
            setTasks(prevTasks => prevTasks.filter(task => task.status !== TASK_STATUS.DONE));
        }, []);

        const renameProject = useCallback((oldName, newName) => {
            if (!newName || oldName === newName) return;
            setTasks(prevTasks => 
                prevTasks.map(task => 
                    task.project === oldName ? { ...task, project: newName } : task
                )
            );
        }, []);

        const deleteProject = useCallback((projectName) => {
            setTasks(prevTasks => 
                prevTasks.map(task => 
                    task.project === projectName ? { ...task, project: null } : task
                )
            );
        }, []);

        const updateProjectSetting = useCallback((projectName, newSettings) => {
            setProjectSettings(prev => ({
                ...prev,
                [projectName]: {
                    ...(prev[projectName] || {}),
                    ...newSettings
                }
            }));
        }, []);
        const allTags = useMemo(() => {
            // This will now be allProjects
            const projectsSet = new Set();
            tasks.forEach(task => {
                if (task.project) {
                    projectsSet.add(task.project);
                }
            });
            return Array.from(projectsSet).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        }, [tasks]);

        const toggleProjectCollapse = useCallback((projectName) => {
            setCollapsedProjects(prev => ({ ...prev, [projectName]: !prev[projectName] }));
        }, []);


        const contextValue = useMemo(() => ({
            tasks, updateTask, addTask, deleteTask, deleteAllCompletedTasks, renameProject, deleteProject, updateProjectSetting,
            settings, setSettings, allTags, projectSettings,
            taskToDelete, setTaskToDelete,
            activeTags, setActiveTags,
            selectedTaskId, setSelectedTaskId,
            collapsedProjects,
            toggleProjectCollapse
        }), [
            tasks, updateTask, addTask, deleteTask, deleteAllCompletedTasks, renameProject, deleteProject, updateProjectSetting,
            settings, setSettings, allTags, projectSettings,
            taskToDelete, setTaskToDelete,
            activeTags, setActiveTags, selectedTaskId,
            collapsedProjects, toggleProjectCollapse
        ]);
        
        return <AppContext.Provider value={contextValue}>{children}</AppContext.Provider>;
    };

    // --- Custom Hook to consume context ---
    const useAppContext = () => {
        const context = useContext(AppContext);
        if (context === null) throw new Error("useAppContext must be used within an AppProvider");
        return context;
    }

    // --- Helper Hooks ---
    const usePrevious = (value) => { const ref = useRef(); useEffect(() => { ref.current = value; }); return ref.current; };
    const useNow = (updateInterval = 1000) => { const [now, setNow] = useState(new Date()); useEffect(() => { const timerId = setInterval(() => setNow(new Date()), updateInterval); return () => clearInterval(timerId); }, [updateInterval]); return now; };
    const useWindowWidth = () => {
        const [width, setWidth] = useState(window.innerWidth);
        useEffect(() => {
            const handleResize = () => setWidth(window.innerWidth);
            window.addEventListener('resize', handleResize);
            return () => window.removeEventListener('resize', handleResize);
        }, []);
        return width;
    };

    // --- Helper Function for Time Parsing (MM:SS or SS duration) ---
    const parseHHMMSSDuration = (inputStr) => {
        if (!inputStr || typeof inputStr !== 'string') return null;

        const parts = inputStr.split(':').map(p => p.trim());
        
        let h = 0, m = 0, s = 0;
        let parsedSuccessfully = false;

        if (parts.length === 1) {
            const val = parseInt(parts[0], 10);
            if (!isNaN(val) && String(val) === parts[0]) { // Ensure clean integer parse
                s = val;
                parsedSuccessfully = true;
            }
        } else if (parts.length === 2) {
            const valM = parseInt(parts[0], 10);
            const valS = parseInt(parts[1], 10);
            if (!isNaN(valM) && String(valM) === parts[0] &&
                !isNaN(valS) && String(valS) === parts[1]) {
                m = valM;
                s = valS;
                parsedSuccessfully = true;
            }
        }

        if (!parsedSuccessfully) return null;

        // Normalize seconds to minutes, and minutes to hours (though hours are not directly input)
        if (s >= 60) { m += Math.floor(s / 60); s %= 60; }
        // h will remain 0 if not explicitly set, which is fine for MM:SS or SS input.
        if (m >= 60) { h += Math.floor(m / 60); m %= 60; }

        const totalSeconds = h * 3600 + m * 60 + s;
        return totalSeconds > 0 ? totalSeconds : null;
    };
    const DISPLAY_PRIORITY_ORDER = [PRIORITIES.LOW, PRIORITIES.MEDIUM, PRIORITIES.HIGH]; // For UI column display

    // --- Icon Components (Memoized) ---
    const DeleteIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>);
    const BellIcon = React.memo(({ className }) => <svg xmlns="http://www.w3.org/2000/svg" className={`h-4 w-4 ${className || ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6 6 0 10-12 0v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" /></svg>);
    const ChevronDownIcon = React.memo(({ className }) => (
        <svg 
            xmlns="http://www.w3.org/2000/svg" 
            className={`h-5 w-5 ${className || ''}`} 
            viewBox="0 0 20 20" 
            fill="currentColor"
        >
            <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
        </svg>
    ));
    const SettingsIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.096 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>);
    const BugIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" strokeWidth="2" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" d="M15.362 5.214A8.252 8.252 0 0112 21 8.25 8.25 0 016.038 7.048 8.287 8.287 0 009 9.6a8.983 8.983 0 013.361-6.867 8.21 8.21 0 003 2.48z" />
            <path strokeLinecap="round" strokeLinejoin="round" d="M12 18a3.75 3.75 0 00.495-7.467 5.99 5.99 0 00-1.925 3.546 5.974 5.974 0 01-2.133-1A3.75 3.75 0 0012 18z" />
        </svg>
    ));
    const DocumentTextIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
        </svg>
    ));
    const NoteIcon = React.memo(({ hasNote, className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" className={`h-4 w-4 ${className || ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            {hasNote ? <path strokeLinecap="round" strokeLinejoin="round" d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" /> : <path strokeLinecap="round" strokeLinejoin="round" d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" />}
        </svg>
    ));
    const FolderIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
        </svg>
    ));
    const CheckIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={3}><path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" /></svg>);
    const PlusIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>);
    const TaikoLogo = React.memo(() => <svg width="52" height="52" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" className="text-white"><g stroke="currentColor" strokeWidth="4" fill="none" strokeLinecap="round" strokeLinejoin="round"><path d="M 25,30 C 25,10 75,10 75,30 V 70 C 75,90 25,90 25,70 Z" fill="rgba(255,255,255,0.1)"/><path d="M 75,30 C 90,30 90,70 75,70" /><path d="M 25,30 C 10,30 10,70 25,70" /><circle cx="50" cy="50" r="28" strokeWidth="3"/><circle cx="50" cy="50" r="8" fill="currentColor"/></g></svg>);

    // --- Time & Countdown Components (Memoized) ---
    const LiveClock = React.memo(({ timezone, onTimezoneChange }) => {
        const time = useNow();
        const formattedTime = time.toLocaleTimeString('en-US', { timeZone: timezone, hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const currentLabel = TIMEZONES.find(tz => tz.value === timezone)?.label || timezone;

        const handleTimezoneClick = () => {
            const currentIndex = TIMEZONES.findIndex(tz => tz.value === timezone);
            const nextIndex = (currentIndex + 1) % TIMEZONES.length;
            onTimezoneChange(TIMEZONES[nextIndex].value);
        };

        return (
            <button onClick={handleTimezoneClick} title="Change timezone" className="flex flex-row items-baseline space-x-2 text-slate-300 rounded-md p-2 -m-2 hover:bg-slate-700/50 transition-colors">
                <span className="text-2xl md:text-4xl font-mono tracking-wider">{formattedTime}</span>
                <span className="text-lg md:text-2xl font-mono text-slate-500">{currentLabel}</span>
            </button>
        );
    });

    const TimeElapsed = React.memo(({ startTime, totalElapsedSeconds }) => {
        const [elapsed, setElapsed] = useState('00:00:00'); // Initialize with a non-null value
        const animationFrameRef = useRef();
        const formatTime = useCallback((s) => new Date(s * 1000).toISOString().substr(11, 8), []);

        useEffect(() => {
            let isMounted = true;
            const animate = () => {
                if (!startTime || !isMounted) return;
                const currentSessionSeconds = (new Date().getTime() - new Date(startTime).getTime()) / 1000;
                setElapsed(formatTime((totalElapsedSeconds || 0) + currentSessionSeconds));
                animationFrameRef.current = requestAnimationFrame(animate);
            };
            if (startTime) animate();
            else setElapsed(formatTime(totalElapsedSeconds || 0));
            return () => { isMounted = false; cancelAnimationFrame(animationFrameRef.current); };
        }, [startTime, totalElapsedSeconds, formatTime]);
        
        return <span className="text-sm font-mono bg-slate-700/50 text-amber-300 px-2 py-1 rounded">{elapsed}</span>;
    });

    // --- Reminder Countdown Component (Memoized) ---
    const ReminderCountdown = React.memo(({ reminderAt }) => {
        const [countdown, setCountdown] = useState('');
        const now = useNow(); // Use the existing useNow hook
    
        const formatCountdown = useCallback((ms) => {
            if (ms <= 0) return 'Due!'; // Or '00:00:00' if you prefer
            const totalSeconds = Math.max(0, Math.floor(ms / 1000));
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }, []);

        useEffect(() => {
            if (!reminderAt) { setCountdown(''); return; }
            const remainingMs = new Date(reminderAt).getTime() - now.getTime();
            setCountdown(formatCountdown(remainingMs));
        }, [reminderAt, now, formatCountdown]);

        if (!reminderAt || countdown === '') return null;
        return <div className="text-xs text-cyan-300 font-mono">Countdown: {countdown}</div>;
    });

    // --- UI Components ---
    const ChecklistItem = React.memo(({ 
        item, 
        onUpdate, // Now also receives completedAt
        onDelete, 
        onAddNewItemAfter, 
        isFocused, 
        onFocusHandled, 
        isLocked, 
        onDropItem, 
        onDragEndItem,
        clockTimezone // Added for displaying subtask completion time
    }) => {
        const inputRef = useRef(null);
        const [isDragOver, setIsDragOver] = useState(false); // Local state for drag over visual feedback
        const [text, setText] = useState(item.text); // Local state for the input text

        const handleDragStart = (e) => {
            e.stopPropagation(); // Prevent parent elements from also being dragged
            e.dataTransfer.setData('text/plain', item.id); // Set the ID of the dragged item
            e.dataTransfer.effectAllowed = 'move';
        };

        const handleDragOver = (e) => {
            e.preventDefault(); // Necessary to allow dropping
            e.dataTransfer.dropEffect = 'move';
        };

        const handleDragEnter = (e) => {
            e.preventDefault();
            setIsDragOver(true);
        };

        useEffect(() => {
            if (isFocused && inputRef.current) {
                inputRef.current.focus();
                onFocusHandled(); // Important to prevent re-focusing on every render
            }
        }, [isFocused, onFocusHandled]);

        // Sync local state if the prop changes from outside
        useEffect(() => {
            setText(item.text);
        }, [item.text]);

        const handleBlur = () => {
            const trimmedText = text.trim();
            if (trimmedText === '') {
                onDelete(item.id); // Delete if the item is left blank
            } else if (trimmedText !== item.text) { // Only update if there's a meaningful change
                onUpdate(item.id, { text: trimmedText });
            }
        };

        const handleKeyDown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleBlur(); // Save changes on Enter
                onAddNewItemAfter(item.id);
            }
        };
        
        const handleDragLeave = () => {
            setIsDragOver(false);
        };

        const handleDrop = (e) => {
            e.preventDefault();
            setIsDragOver(false);
            const draggedId = e.dataTransfer.getData('text/plain');
            if (draggedId && draggedId !== item.id) {
                onDropItem(draggedId, item.id); // Notify parent TaskCard to reorder
            }
        };

        const handleDragEnd = () => {
            setIsDragOver(false);
            onDragEndItem(); // Notify parent TaskCard that drag has ended
        };

        return ( // Only draggable if not locked
            <li 
                draggable={!isLocked} 
                onDragStart={handleDragStart}
                onDragOver={handleDragOver}
                onDragEnter={handleDragEnter}
                onDragLeave={handleDragLeave}
                onDrop={handleDrop}
                onDragEnd={handleDragEnd}
                className={`flex items-center space-x-2 group p-1 rounded-md transition-all ${isDragOver ? 'bg-sky-700/30 border border-sky-500' : ''} ${isLocked ? 'cursor-default' : 'cursor-grab'}`}
            >
                <input 
                    type="checkbox" 
                    checked={item.completed} 
                    onChange={(e) => {
                        const isCompleted = e.target.checked;
                        onUpdate(item.id, { completed: isCompleted, completedAt: isCompleted ? new Date().toISOString() : null });
                    }} disabled={isLocked} className="form-checkbox h-4 w-4 rounded bg-slate-700 border-slate-500 text-sky-500 focus:ring-sky-500 cursor-pointer disabled:cursor-not-allowed disabled:opacity-50" />
                <input 
                    ref={inputRef}
                    type="text" 
                    value={text} 
                    onChange={e => setText(e.target.value)} 
                    onKeyDown={handleKeyDown} 
                    onBlur={handleBlur}
                    readOnly={isLocked}
                    className={`flex-grow min-w-0 bg-transparent text-sm p-1 rounded-md transition-colors ${item.completed ? 'text-slate-500 line-through' : 'text-slate-300'} ${!isLocked ? 'hover:bg-slate-700/50' : ''} focus:bg-slate-700 read-only:cursor-default`} 
                />
                {item.completed && item.completedAt && (
                    <span className="text-xs text-slate-500 ml-2 whitespace-nowrap">
                        ({new Date(item.completedAt).toLocaleString('en-US', {
                            timeZone: clockTimezone,
                            month: 'numeric', day: 'numeric', year: 'numeric',
                            hour: '2-digit', minute: '2-digit'
                        })})
                    </span>
                )}

                <button onClick={() => onDelete(item.id)} title="Delete item" disabled={isLocked} className="text-slate-500 hover:text-red-400 opacity-0 group-hover:opacity-100 transition-opacity disabled:hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </li>
        );
    });

    // --- Task Card Component ---
    const TaskCard = ({ task, clockTimezone, startInEditMode, onEditModeEnd, isDetailedView, onSelect }) => {
        const { tasks, updateTask, deleteTask, allTags, settings, setTaskToDelete, activeTags } = useAppContext();
        const now = useNow();
        const isLocked = task.status === TASK_STATUS.DONE;
        const [isEditingTitle, setIsEditingTitle] = useState(false); // To be wrapped
        const [title, setTitle] = useState(task.title);
        const [checklist, setChecklist] = useState(task.checklist || []);
        // State for task notes
        const [notes, setNotes] = useState(task.notes || '');
        // State to manage which checklist item should be focused
        const [focusedItemId, setFocusedItemId] = useState(null);
        const draggedChecklistItemId = useRef(null); // Use ref to avoid re-renders during drag
        const notesTextareaRef = useRef(null); // Ref for the notes textarea
        const titleInputRef = useRef(null); // Ref for the title input
        const [isChecklistExpanded, setIsChecklistExpanded] = useState(true);
        const [dueDateInput, setDueDateInput] = useState('');
        const [isActivityLogExpanded, setIsActivityLogExpanded] = useState(false);
        const [tagInput, setTagInput] = useState('');
        const [showResetTimeConfirm, setShowResetTimeConfirm] = useState(false);
        const [isAddingUpstream, setIsAddingUpstream] = useState(false);

        const upstreamTasks = useMemo(() => {
            if (!task.dependsOn || task.dependsOn.length === 0) return [];
            // Only show upstream tasks that are not yet completed.
            return task.dependsOn.map(depId => tasks.find(t => t.id === depId))
                .filter(t => t && t.status !== TASK_STATUS.DONE);
        }, [task.dependsOn, tasks]);

        const isBlocked = useMemo(() => {
            if (!task.dependsOn || task.dependsOn.length === 0) return false;
            return task.dependsOn.some(depId => {
                const dependencyTask = tasks.find(t => t.id === depId);
                // A task is blocked if any dependency exists and is not 'Completed'
                return dependencyTask && dependencyTask.status !== TASK_STATUS.DONE;
            });
        }, [task.dependsOn, tasks]);

        const isUnlocked = useMemo(() => {
            // A task is "unlocked" if it's not done, has dependencies, but is not currently blocked.
            if (isLocked || !task.dependsOn || task.dependsOn.length === 0) return false;
            return !isBlocked;
        }, [isLocked, task.dependsOn, isBlocked]);

        const blockedTasks = useMemo(() => {
            return tasks.filter(t => t.dependsOn?.includes(task.id));
        }, [tasks, task.id]);

        // State for the downstream add UI
        const [isAddingDownstream, setIsAddingDownstream] = useState(false);
        const addDownstreamInputRef = useRef(null);
        const addUpstreamInputRef = useRef(null);

        const availableDownstreamTasks = useMemo(() => {
            // A task cannot block another task that is already in its own upstream.
            const isCircular = (potentialUpstreamId, targetId) => {
                const taskToCheck = tasks.find(t => t.id === potentialUpstreamId);
                if (!taskToCheck || !taskToCheck.dependsOn) return false;
                if (taskToCheck.dependsOn.includes(targetId)) return true;
                // Recursively check the upstream dependencies of the potential upstream task.
                return taskToCheck.dependsOn.some(depId => isCircular(depId, targetId));
            };

            return tasks.filter(t => {
                // Standard filters: not itself, not done, not already blocked by this task.
                if (t.id === task.id || t.status === TASK_STATUS.DONE || t.dependsOn?.includes(task.id)) {
                    return false;
                }
                // Circular dependency check: `t` cannot be an upstream dependency of the current task.
                return !isCircular(task.id, t.id);
            });
        }, [tasks, task.id]);

        const availableUpstreamTasks = useMemo(() => {
            // A task cannot depend on another task that already depends on it.
            const isCircular = (potentialDownstreamId, targetId) => {
                const taskToCheck = tasks.find(t => t.id === potentialDownstreamId);
                if (!taskToCheck || !taskToCheck.dependsOn) return false;
                if (taskToCheck.dependsOn.includes(targetId)) return true;
                return taskToCheck.dependsOn.some(depId => isCircular(depId, targetId));
            };

            return tasks.filter(t => {
                // Standard filters: not itself, not done, not already a dependency.
                if (t.id === task.id || t.status === TASK_STATUS.DONE || task.dependsOn?.includes(t.id)) {
                    return false;
                }
                // Circular dependency check: `task` cannot be an upstream dependency of `t`.
                return !isCircular(t.id, task.id);
            });
        }, [tasks, task.id]);

        useEffect(() => { setDueDateInput(task.dueDate ? new Date(task.dueDate).toISOString().split('T')[0] : ''); }, [task.dueDate]);
        
        useEffect(() => { setChecklist(task.checklist || []); }, [task.checklist]);
        useEffect(() => { setTitle(task.title); }, [task.title]);
        useEffect(() => { setNotes(task.notes || ''); }, [task.notes]); // Sync notes state with prop

        useEffect(() => {
            if (startInEditMode) {
                setIsEditingTitle(true);
                // Callback to reset the state in the parent component
                if (onEditModeEnd) onEditModeEnd();
            }
        }, [startInEditMode, onEditModeEnd]);

        useEffect(() => {
            if (isEditingTitle && titleInputRef.current) {
                titleInputRef.current.focus();
            }
        }, [isEditingTitle]);

        useEffect(() => {
            if (isAddingDownstream && addDownstreamInputRef.current) {
                addDownstreamInputRef.current.focus();
            }
        }, [isAddingDownstream]);

        useEffect(() => {
            if (isAddingUpstream && addUpstreamInputRef.current) {
                addUpstreamInputRef.current.focus();
            }
        }, [isAddingUpstream]);

        // Effect to auto-resize the notes textarea
        useEffect(() => {
            if (notesTextareaRef.current) {
                const textarea = notesTextareaRef.current;
                textarea.style.height = 'auto'; // Reset height to allow shrinking
                textarea.style.height = `${textarea.scrollHeight}px`; // Set to content height
            }
        }, [notes]); // Rerun on content change

        const handleDeleteRequest = useCallback(() => {
            if (settings.confirmOnDelete) {
                setTaskToDelete(task.id); // Corrected: Should set the task ID
            } else {
                deleteTask(task.id);
            }
        }, [task.id, settings.confirmOnDelete, deleteTask, setTaskToDelete]);
        const handleUpdateChecklist = useCallback((updatedList) => {
            // Checklist updates no longer automatically change task status.
            // Status is now manually set via the dropdown.
            updateTask(task.id, { checklist: updatedList }, 'Checklist updated.');
        }, [task.id, updateTask]);
        
        const handleItemUpdate = (id, values) => handleUpdateChecklist(checklist.map(i => i.id === id ? { ...i, ...values } : i));
        const handleItemDelete = (id) => handleUpdateChecklist(checklist.filter(i => i.id !== id));
        const handleAddItem = () => {
            const newId = crypto.randomUUID();
            setFocusedItemId(newId); // Set the new item to be focused
            handleUpdateChecklist([...checklist, { id: newId, text: '', completed: false }]);
        };
        const handleAddNewItemAfter = useCallback((currentItemId) => {
            const newId = crypto.randomUUID();
            setFocusedItemId(newId); // Set the ID of the new item to be focused
            const currentIndex = checklist.findIndex(i => i.id === currentItemId);
            const newChecklist = [...checklist];
            // Insert the new item right after the current one
            newChecklist.splice(currentIndex + 1, 0, { id: newId, text: '', completed: false });
            handleUpdateChecklist(newChecklist);
        }, [checklist, handleUpdateChecklist]);
        const handleTitleBlur = () => {
            setIsEditingTitle(false);
            const trimmedTitle = title.trim();
            const finalTitle = trimmedTitle === '' ? 'Untitled Task' : trimmedTitle;
            if (finalTitle !== task.title) updateTask(task.id, { title: finalTitle }, 'Title was changed.');
        };
        const handleTitleKeyDown = (e) => { if (e.key === 'Enter') { e.preventDefault(); handleTitleBlur(); } };
        
        const handleSetPriority = (priorityToSet) => {
            // If the clicked priority is the same as the current one, clear it. Otherwise, set it.
            const newPriority = task.priority === priorityToSet ? null : priorityToSet;
            updateTask(task.id, { priority: newPriority });
        };

        const handleCompletionToggle = () => {
            const isCurrentlyDone = task.status === TASK_STATUS.DONE;
            if (isCurrentlyDone) {
                updateTask(task.id, { status: TASK_STATUS.TO_DO }, 'Task status changed to To Do.');
            } else {
                updateTask(task.id, { status: TASK_STATUS.DONE, reminderAt: null, reminderFired: false });
            }
        };
        
        // --- Time Tracking Handlers ---
        const handleToggleTimer = () => {
            if (task.timingSessionStartTime) {
                // Stop the timer
                const sessionSeconds = (new Date().getTime() - new Date(task.timingSessionStartTime).getTime()) / 1000;
                updateTask(task.id, {
                    timingSessionStartTime: null,
                    timeSpentSeconds: (task.timeSpentSeconds || 0) + sessionSeconds
                });
            } else {
                // Start the timer
                updateTask(task.id, { timingSessionStartTime: new Date().toISOString() });
            }
        };

        const handleResetTimer = () => {
            updateTask(task.id, {
                timeSpentSeconds: 0,
                timingSessionStartTime: null
            }, 'Time tracking was reset.');
            setShowResetTimeConfirm(false);
        };
        
        const handleDueDateChange = (e) => {
            const newDateValue = e.target.value;
            setDueDateInput(newDateValue);

            if (newDateValue) {
                const date = new Date(newDateValue);
                date.setUTCHours(23, 59, 59, 999); // Set to end of day in UTC to avoid timezone issues
                updateTask(task.id, { dueDate: date.toISOString() }, `Due date set to ${date.toLocaleDateString()}.`);
            } else {
                updateTask(task.id, { dueDate: null }, 'Due date was removed.');
            }
        };

        const handleTagKeyDown = (e) => {
            if (e.key === 'Enter' && tagInput.trim() !== '') {
                e.preventDefault();
                const newTags = [...new Set([...(task.tags || []), tagInput.trim()])];
                updateTask(task.id, { tags: newTags }, `Tag "${tagInput.trim()}" added.`);
                setTagInput('');
            }
        };

        const handleRemoveTag = (tagToRemove) => {
            const newTags = (task.tags || []).filter(t => t !== tagToRemove);
            updateTask(task.id, { tags: newTags });
        }; // This is a minor action, maybe doesn't need a log.


        const handleRemoveDependency = (depId) => {
            const dependencyTask = tasks.find(t => t.id === depId);
            updateTask(task.id, { 
                dependsOn: task.dependsOn.filter(id => id !== depId) 
            }, `Removed dependency on "${dependencyTask.title}".`);
        };

        const handleAddDownstreamDependency = (e) => {
            const taskToBlockId = e.target.value;
            if (!taskToBlockId) return;

            // --- Circular Dependency Check ---
            // A task cannot block another task that is already in its own upstream.
            const isCircular = (taskId, targetId) => {
                const taskToCheck = tasks.find(t => t.id === taskId);
                if (!taskToCheck || !taskToCheck.dependsOn) return false;
                if (taskToCheck.dependsOn.includes(targetId)) return true;
                return taskToCheck.dependsOn.some(depId => isCircular(depId, targetId));
            };

            if (isCircular(task.id, taskToBlockId)) {
                alert("Circular dependency detected! A task cannot block one of its own upstream dependencies.");
                e.target.value = '';
                return;
            }

            const taskToBlock = tasks.find(t => t.id === taskToBlockId);
            if (taskToBlock) {
                const newDependsOn = [...(taskToBlock.dependsOn || []), task.id];
                updateTask(taskToBlock.id, { dependsOn: newDependsOn }, `Is now blocked by "${task.title}".`);
            }
        };

        const handleAddUpstreamDependency = (e) => {
            const dependencyId = e.target.value;
            if (!dependencyId) return;

            const dependencyTask = tasks.find(t => t.id === dependencyId);
            if (dependencyTask) {
                const newDependsOn = [...(task.dependsOn || []), dependencyId];
                updateTask(task.id, { dependsOn: newDependsOn }, `Now depends on "${dependencyTask.title}".`);
            }
        };
        const handleRemoveDownstreamDependency = (taskToUnblockId) => {
            const taskToUnblock = tasks.find(t => t.id === taskToUnblockId);
            const newDependsOn = taskToUnblock.dependsOn.filter(id => id !== task.id);
            updateTask(taskToUnblock.id, { dependsOn: newDependsOn }, `Is no longer blocked by "${task.title}".`);
        };

        // Drag and Drop Handlers for Checklist Items
        const handleDropChecklistItem = useCallback((draggedId, targetId) => {
            const draggedIndex = checklist.findIndex(item => item.id === draggedId);
            const targetIndex = checklist.findIndex(item => item.id === targetId);

            if (draggedIndex === -1 || targetIndex === -1) return;

            const newChecklist = [...checklist];
            const [draggedItem] = newChecklist.splice(draggedIndex, 1);
            newChecklist.splice(targetIndex, 0, draggedItem);

            handleUpdateChecklist(newChecklist);
        }, [checklist, handleUpdateChecklist]);

        const handleDragEndChecklistItem = useCallback(() => { draggedChecklistItemId.current = null; }, []);

        // Pulse should continue as long as the reminder time has passed,
        // regardless of whether the notification itself has fired.
        const reminderIsDue = task.reminderAt && new Date(task.reminderAt) <= now;
        const pulseClass = reminderIsDue ? (PRIORITY_CONFIG[task.priority]?.pulseClass || '') : '';
        
        const cardPadding = 'p-3';
        const titleFontSize = ''; // Default is text-lg from h3
        const textSize = 'text-sm';
        
        return (
            !isDetailedView ? ( // This is the Project View Card
                // --- Project View Card (3-Column Layout) ---
                <div onClick={() => onSelect(task.id)} className={`w-full min-w-0 bg-slate-800/80 backdrop-blur-sm border border-slate-700/50 rounded-xl shadow-md transition-all duration-300 cursor-pointer hover:border-sky-500 hover:shadow-lg ${TASK_STATUS_CONFIG[task.status]?.glowClass || ''} ${isLocked ? 'opacity-60' : ''} ${isBlocked ? 'ring-2 ring-amber-500/50' : ''}`}>
                    <div className="px-4 pt-3 pb-2 border-b border-slate-700/50">
                        <div className="flex items-center gap-2">
                            {isUnlocked && <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-green-400 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor"><path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 016 0v2a1 1 0 102 0V7a5 5 0 00-5-5z" /></svg>}
                            {isBlocked && <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-amber-400 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z" clipRule="evenodd" /></svg>}
                            <h3 className={`font-semibold text-slate-100 break-words text-base ${isLocked ? 'line-through text-slate-500' : ''}`}>{task.title}</h3>
                        </div>
                    </div>
                    <div className="grid grid-cols-5 divide-x divide-slate-700 text-center">
                        {/* Column 1: Priority */}
                        <div className="p-3">
                            <div className="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-1">Priority</div>
                            <div className={`text-sm font-bold rounded-md py-1 ${PRIORITY_CONFIG[task.priority]?.color || 'text-slate-300'}`}>
                                {PRIORITY_CONFIG[task.priority]?.title || 'N/A'}
                            </div>
                        </div>
                        {/* Blocked By Column */}
                        <div className="p-3">
                            <div className="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-1">Blocked By</div>
                            <div className="text-xs text-slate-300 py-1 break-words">
                                {upstreamTasks.length > 0 ? (
                                    upstreamTasks.map((t, index) => (
                                        <React.Fragment key={t.id}>
                                            <button
                                                onClick={(e) => { e.stopPropagation(); onSelect(t.id); }}
                                                className="transition-all hover:text-sky-300 hover:[text-shadow:0_0_8px_theme(colors.sky.400)]"
                                                title={`Go to task: ${t.title}`}
                                            >{t.title}</button>
                                            {index < upstreamTasks.length - 1 ? ', ' : ''}
                                        </React.Fragment>
                                    ))
                                ) : <span className="italic text-slate-500">None</span>
                                }
                            </div>
                        </div>
                        {/* Column 2: Time Tracking */}
                        <div className="p-3">
                            <div className="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-1">Time Spent</div>
                            <TimeElapsed startTime={task.timingSessionStartTime} totalElapsedSeconds={task.timeSpentSeconds} />
                        </div>
                        {/* Column 3: Task Size */}
                        <div className="p-3">
                            <div className="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-1">Size</div>
                            <div className="text-sm font-bold text-slate-300 py-1">
                                {task.size ? TASK_SIZES[task.size] : 'N/A'}
                            </div>
                        </div>
                        {/* Column 4: Due Date */}
                        <div className="p-3">
                            <div className="text-xs font-semibold text-slate-400 uppercase tracking-wider mb-1">Due Date</div>
                            <div className={`text-sm font-bold py-1 ${task.dueDate && new Date(task.dueDate) < new Date() ? 'text-red-400' : 'text-slate-300'}`}>
                                {task.dueDate 
                                    ? new Date(task.dueDate).toLocaleDateString([], { month: 'numeric', day: 'numeric' }) 
                                    : 'N/A'
                                }
                            </div>
                        </div>
                    </div>
                </div>
            ) : (
            // --- Detailed View Card (Existing Layout) ---
            <>
            <div className={`w-full min-w-0 bg-slate-800/80 backdrop-blur-xl border border-slate-700/50 rounded-xl shadow-lg transition-shadow duration-300 ${pulseClass} ${TASK_STATUS_CONFIG[task.status]?.glowClass || ''} ${isLocked ? 'opacity-60' : ''} ${isBlocked ? 'ring-2 ring-amber-500/80' : ''}`}>
                {/* --- Header: Title & Priority --- */}
                <div className="px-4 pt-4 pb-3 border-b border-slate-700/50">
                    <div className="flex justify-between items-center mb-1">
                        {/* Task Title */}
                        <div className="flex-grow min-w-0 mr-4">
                            {isEditingTitle ? (
                                <input ref={titleInputRef} type="text" value={title} onChange={e => setTitle(e.target.value)} onBlur={handleTitleBlur} onKeyDown={handleTitleKeyDown} className={`w-full bg-slate-900/50 rounded-md py-1 text-slate-50 font-semibold text-lg border border-slate-600 focus:ring-2 focus:ring-sky-500`} />
                            ) : (
                                <div className="flex items-center gap-2">
                                    {isUnlocked && <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-green-400 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor"><path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 016 0v2a1 1 0 102 0V7a5 5 0 00-5-5z" /></svg>}
                                    {isBlocked && <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-amber-400 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z" clipRule="evenodd" /></svg>}
                                    <h3 onDoubleClick={isLocked ? undefined : () => setIsEditingTitle(true)} title={isLocked ? "Task is completed" : "Double-click to edit title"} className={`font-semibold text-slate-50 break-words text-lg rounded-md transition-colors ${isLocked ? 'cursor-default line-through text-slate-500' : 'cursor-pointer hover:bg-slate-700/50 px-2 -mx-2 py-1 -my-1'}`}>{task.title}</h3>
                                </div>
                            )}
                        </div>

                        {/* Right-side Header Actions: Priority & Completion */}
                        {isDetailedView && (
                            <div className="flex items-center gap-4 flex-shrink-0 ml-4">
                                {/* Priority Dots */}
                                <div className="flex items-center space-x-2">
                                    <span className="text-xs text-slate-400">Priority:</span>
                                    {DISPLAY_PRIORITY_ORDER.map(pConst => {
                                        const config = PRIORITY_CONFIG[pConst];
                                        const isSelected = task.priority === pConst;
                                        const isTogglingOff = isSelected;
                                        return (
                                            <button
                                                key={pConst} title={`Set priority: ${config.title}`}
                                                onClick={() => handleSetPriority(pConst)} disabled={isLocked}
                                                className={`px-3 py-1 text-xs font-semibold rounded-md border transition-colors ${isSelected ? `${config.bgColor} ${config.borderColor} ${config.color}` : `bg-slate-600/30 border-slate-600 text-slate-300 hover:${config.bgColor}`}`}
                                            >{config.title}</button>
                                        );
                                    })}
                                </div>
                                {/* Completion Button */}
                                <div>
                                    <button 
                                        onClick={handleCompletionToggle} 
                                        title={isBlocked ? "Task is blocked by a dependency" : (isLocked ? "Mark as 'To Do'" : "Mark as 'Completed'")} 
                                        disabled={isBlocked && !isLocked}
                                        className={`p-2 rounded-full transition-all duration-200 transform hover:scale-110 ${isLocked ? 'bg-green-500 text-white shadow-lg shadow-green-500/30' : 'text-slate-400 hover:text-green-400 hover:bg-green-500/20'} disabled:cursor-not-allowed disabled:text-slate-600 disabled:hover:bg-transparent disabled:scale-100`}
                                    >
                                        <CheckIcon />
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                </div>

                <div className="px-4 pb-3 space-y-3">
                    {/* --- Notes Section --- */}
                    {isDetailedView && (
                        <div className="bg-slate-900/40 p-3 rounded-lg border border-slate-700/50">
                            <h4 className="text-xs font-semibold text-slate-400 mb-1 uppercase tracking-wider">Notes</h4>
                            <textarea
                                ref={notesTextareaRef}
                                value={notes}
                                onChange={e => setNotes(e.target.value)}
                                onBlur={() => { if (notes !== task.notes) updateTask(task.id, { notes }, 'Notes were updated.')} }
                                placeholder="Notes..."
                                disabled={isLocked}
                                className={`w-full bg-transparent text-slate-300 p-1 rounded-md border border-transparent focus:bg-slate-900/80 focus:border-slate-600 focus:ring-0 resize-none overflow-hidden ${textSize} placeholder-slate-500 disabled:cursor-not-allowed ${!isLocked ? 'hover:bg-slate-900/80' : ''}`}
                            ></textarea>
                        </div>
                    )}

                    {/* --- Checklist Section --- */}
                    {(isDetailedView || checklist.length > 0 || !isLocked) && (
                        <div className="bg-slate-900/40 rounded-lg border border-slate-700/50">
                            <button onClick={() => setIsChecklistExpanded(p => !p)} className="w-full flex justify-between items-center p-3 text-left">
                                <h4 className="text-xs font-semibold text-slate-400 uppercase tracking-wider">Checklist ({checklist.length})</h4>
                                <ChevronDownIcon className={`h-5 w-5 text-slate-400 transition-transform ${isChecklistExpanded ? 'rotate-180' : ''}`} />
                            </button>
                            {isChecklistExpanded && <div className="p-3 pt-0 space-y-1">
                                <ul className="space-y-1">{checklist.map(item => 
                                    <ChecklistItem 
                                        key={item.id} 
                                        item={item} 
                                        onUpdate={handleItemUpdate} 
                                        onDelete={handleItemDelete} 
                                        onAddNewItemAfter={handleAddNewItemAfter}
                                        isFocused={focusedItemId === item.id}
                                        onFocusHandled={() => setFocusedItemId(null)}
                                        isLocked={isLocked}
                                        clockTimezone={clockTimezone}
                                        onDropItem={handleDropChecklistItem}
                                        onDragEndItem={handleDragEndChecklistItem}
                                    />
                                )}</ul>
                                <button onClick={handleAddItem} title="Add a new checklist item" disabled={isLocked} className={`w-full text-left text-sky-400 hover:text-sky-300 p-1 rounded-md hover:bg-slate-700/50 disabled:text-slate-500 disabled:cursor-not-allowed disabled:hover:bg-transparent ${textSize}`}>+ Add item</button>
                            </div>}
                        </div>
                    )}
                    
                    {/* --- Time Tracking Section (Detailed View Only) --- */}
                    {isDetailedView && (
                        <div className="bg-slate-900/40 p-3 rounded-lg border border-slate-700/50">
                            <h4 className="text-xs font-semibold text-slate-400 mb-2 uppercase tracking-wider">Time Tracking</h4>
                            <div className="flex items-center justify-between gap-2">
                                <TimeElapsed startTime={task.timingSessionStartTime} totalElapsedSeconds={task.timeSpentSeconds} />
                                <div className="flex items-center gap-2">
                                    <button
                                        onClick={() => setShowResetTimeConfirm(true)}
                                        disabled={isLocked || (!task.timeSpentSeconds && !task.timingSessionStartTime)}
                                        title="Reset timer"
                                        className="p-2 text-sm font-semibold rounded-md transition-colors text-slate-400 hover:bg-slate-700 hover:text-white disabled:opacity-50 disabled:cursor-not-allowed"
                                    >
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="currentColor" viewBox="0 0 16 16"><path fillRule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/></svg>
                                    </button>
                                    <button 
                                        onClick={handleToggleTimer} 
                                        disabled={isLocked}
                                        className={`px-4 py-1.5 text-sm font-semibold rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2 ${task.timingSessionStartTime ? 'bg-red-500/80 hover:bg-red-500 text-white' : 'bg-green-500/80 hover:bg-green-500 text-white'}`}
                                    >
                                        {task.timingSessionStartTime ? <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/></svg> : <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="currentColor" viewBox="0 0 16 16"><path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>}
                                        {task.timingSessionStartTime ? 'Stop' : 'Start'}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* --- Due Date & Tags Section (Detailed View Only) --- */}
                    {isDetailedView && (
                        <div className="bg-slate-900/40 p-3 rounded-lg border border-slate-700/50 space-y-3">
                            {/* Due Date */}
                            <div>
                                <h4 className="text-xs font-semibold text-slate-400 mb-1 uppercase tracking-wider">Due Date</h4>
                                <div className="flex items-center gap-2">
                                    <input
                                        type="date"
                                        value={dueDateInput}
                                        onChange={handleDueDateChange}
                                        disabled={isLocked}
                                        className="w-full bg-slate-700 text-slate-100 text-sm p-1.5 rounded-md border border-slate-500 focus:ring-1 focus:ring-sky-500 disabled:opacity-50"
                                    />
                                    {task.dueDate && (
                                        <span className={`text-xs font-semibold px-2 py-1 rounded-md whitespace-nowrap ${new Date(task.dueDate) < new Date() ? 'bg-red-500/30 text-red-300' : 'bg-slate-700 text-slate-300'}`}>
                                            {Math.ceil((new Date(task.dueDate) - new Date()) / (1000 * 60 * 60 * 24))} days left
                                        </span>
                                    )}
                                </div>
                            </div>
                            {/* Tags */}
                            <div>
                                <h4 className="text-xs font-semibold text-slate-400 mb-2 uppercase tracking-wider">Tags</h4>
                                <div className="flex flex-wrap gap-2 items-center">
                                    {(task.tags || []).map(tag => {
                                        const tagHash = tag.split('').reduce((acc, char) => char.charCodeAt(0) + ((acc << 5) - acc), 0);
                                        const colors = ['bg-red-500/80', 'bg-yellow-500/80', 'bg-green-500/80', 'bg-blue-500/80', 'bg-indigo-500/80', 'bg-purple-500/80', 'bg-pink-500/80'];
                                        const colorClass = colors[Math.abs(tagHash % colors.length)];
                                        return (
                                            <span key={tag} className={`flex items-center gap-1 text-xs font-semibold text-white px-2 py-1 rounded-full ${colorClass}`}>
                                                {tag}
                                                {!isLocked && <button onClick={() => handleRemoveTag(tag)} className="opacity-70 hover:opacity-100">&times;</button>}
                                            </span>
                                        );
                                    })}
                                    {!isLocked && <input type="text" value={tagInput} onChange={e => setTagInput(e.target.value)} onKeyDown={handleTagKeyDown} placeholder="+ Add tag"
                                        className="bg-transparent text-slate-300 text-xs p-1 focus:ring-0 focus:outline-none border-b border-dashed border-slate-600 focus:border-solid focus:border-sky-500"
                                    />}
                                </div>
                            </div>
                            {/* Task Size */}
                            <div>
                                <h4 className="text-xs font-semibold text-slate-400 mb-1 uppercase tracking-wider">Task Size</h4>
                                <select
                                    value={task.size || ''}
                                    onChange={(e) => updateTask(task.id, { size: e.target.value || null })}
                                    disabled={isLocked}
                                    className="w-full bg-slate-800 text-slate-200 text-sm p-1.5 rounded-md border border-slate-600 focus:ring-1 focus:ring-sky-500 disabled:opacity-50"
                                >
                                    <option value="">Not Set</option>
                                    {Object.entries(TASK_SIZES).map(([key, value]) => (
                                        <option key={key} value={key}>{value}</option>
                                    ))}
                                </select>
                            </div>
                        </div>
                    )}

                    {/* --- Dependencies Section (Detailed View Only) --- */}
                    {isDetailedView && (
                        <div className="bg-slate-900/40 p-3 rounded-lg border border-slate-700/50 space-y-3">
                            <div className="flex items-center gap-3 text-center">
                                <div className="flex-1 flex items-center justify-center gap-2">
                                    <label className="text-sm font-semibold text-slate-300">Upstream</label>
                                    {!isLocked && (
                                        <button onClick={() => setIsAddingUpstream(p => !p)} title="Add upstream dependency" className="text-sky-400 hover:text-sky-300">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clipRule="evenodd" /></svg>
                                        </button>
                                    )}
                                </div>
                                <div className="w-6 h-6 flex-shrink-0"></div> {/* Spacer for arrow */}
                                <label className="flex-1 w-1/3 text-sm font-semibold text-slate-300">Current Task</label>
                                <div className="w-6 h-6 flex-shrink-0"></div> {/* Spacer for arrow */}
                                <div className="flex-1 flex items-center justify-center gap-2">
                                    <label className="text-sm font-semibold text-slate-300">Downstream</label>
                                    {!isLocked && (
                                        <button onClick={() => setIsAddingDownstream(p => !p)} title="Block another task" className="text-sky-400 hover:text-sky-300">
                                            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clipRule="evenodd" /></svg>
                                        </button>
                                    )}
                                </div>
                            </div>
                            <div className="flex items-center gap-3">
                                {/* Upstream Column */}
                                <div className="flex-1 space-y-2">
                                    {(task.dependsOn || []).length > 0 ? (
                                        <div className="space-y-2">
                                            {(task.dependsOn || []).map(depId => {
                                                const depTask = tasks.find(t => t.id === depId);
                                                if (!depTask) return null; // <-- This is the fix.
                                                const isDepDone = depTask.status === TASK_STATUS.DONE;
                                                return (
                                                    <div key={depId} className="flex items-center justify-between bg-slate-800/70 p-3 rounded-md text-sm text-center min-h-[52px]">
                                                        <span className={`flex-grow ${isDepDone ? 'line-through text-slate-500' : 'text-slate-200'}`}>{depTask.title}</span>
                                                        {!isLocked && <button onClick={() => handleRemoveDependency(depId)} className="text-slate-500 hover:text-red-400 ml-2 flex-shrink-0">&times;</button>}
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ) : (
                                        !isAddingUpstream && <div className="text-xs text-slate-500 text-center italic min-h-[52px] flex items-center justify-center">None</div>
                                    )}
                                    {isAddingUpstream && !isLocked && (
                                        <select ref={addUpstreamInputRef} onChange={handleAddUpstreamDependency} onBlur={() => setIsAddingUpstream(false)} className="w-full bg-slate-800 text-slate-200 text-sm p-3 rounded-md border border-slate-600 focus:ring-1 focus:ring-sky-500 min-h-[52px]">
                                            <option value="">+ Add dependency...</option>
                                            {availableUpstreamTasks.map(t => (
                                                <option key={t.id} value={t.id} title={t.title}>{t.title}</option>
                                            ))}
                                        </select>
                                    )}
                                </div>

                                {/* Arrow 1 */}
                                <div className="flex-shrink-0 flex items-center h-[52px]">
                                    <svg className="w-6 h-6 text-slate-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 8l4 4m0 0l-4 4m4-4H3" /></svg>
                                </div>

                                {/* Current Task Column */}
                                <div className="flex-1 w-1/3">
                                    <div className="bg-sky-900/50 border border-sky-700 p-3 rounded-md text-sm text-center min-h-[52px] flex items-center justify-center">
                                        <span className="font-bold text-sky-200">{task.title}</span>
                                    </div>
                                </div>

                                {/* Arrow 2 */}
                                <div className="flex-shrink-0 flex items-center h-[52px]">
                                    <svg className="w-6 h-6 text-slate-500" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 8l4 4m0 0l-4 4m4-4H3" /></svg>
                                </div>

                                {/* Downstream Column */}
                                <div className="flex-1 space-y-2">
                                    {blockedTasks.length > 0 ? (
                                        <div className="space-y-2">
                                            {blockedTasks.map(blockedTask => (
                                                <div key={blockedTask.id} className="flex items-center justify-between bg-slate-800/70 p-3 rounded-md text-sm text-center min-h-[52px]">
                                                    <span className="text-slate-200 flex-grow">{blockedTask.title}</span>
                                                    {!isLocked && <button onClick={() => handleRemoveDownstreamDependency(blockedTask.id)} className="text-slate-500 hover:text-red-400 ml-2 flex-shrink-0">&times;</button>}
                                                </div>
                                            ))}
                                        </div>
                                    ) : (
                                        !isAddingDownstream && <div className="text-xs text-slate-500 text-center italic min-h-[52px] flex items-center justify-center">None</div>
                                    )}
                                    {isAddingDownstream && !isLocked && (
                                        <select ref={addDownstreamInputRef} onChange={handleAddDownstreamDependency} onBlur={() => setIsAddingDownstream(false)} className="w-full bg-slate-800 text-slate-200 text-sm p-3 rounded-md border border-slate-600 focus:ring-1 focus:ring-sky-500 min-h-[52px]">
                                            <option value="">+ Block another task...</option>
                                            {availableDownstreamTasks.map(t => (
                                                <option key={t.id} value={t.id} title={t.title}>{t.title}</option>
                                            ))}
                                        </select>
                                    )}
                                </div>
                            </div>
                        </div>
                    )}

                    {/* --- Activity Log Section (Detailed View Only) --- */}
                    {isDetailedView && (task.activityLog || []).length > 0 && (
                        <div className="bg-slate-900/40 rounded-lg border border-slate-700/50">
                            <button onClick={() => setIsActivityLogExpanded(p => !p)} className="w-full flex justify-between items-center p-3 text-left">
                                <h4 className="text-xs font-semibold text-slate-400 uppercase tracking-wider">Activity Log ({task.activityLog.length})</h4>
                                <ChevronDownIcon className={`h-5 w-5 text-slate-400 transition-transform ${isActivityLogExpanded ? 'rotate-180' : ''}`} />
                            </button>
                            {isActivityLogExpanded && (
                                <div className="px-3 pb-3">
                                    <div className="space-y-2 max-h-[22.5rem] overflow-y-auto pr-2 border-t border-slate-700/50 pt-3">
                                        {[...(task.activityLog || [])].reverse().map((log, index) => (
                                            <div key={index} className="flex justify-between items-center text-xs">
                                                <p className="text-slate-300">{log.message}</p>
                                                <p className="text-slate-500 whitespace-nowrap pl-4">
                                                    {new Date(log.timestamp).toLocaleString([], { 
                                                        timeZone: clockTimezone, 
                                                        month: 'numeric', day: 'numeric', hour: 'numeric', minute: '2-digit' 
                                                    })}
                                                </p>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                    )}

                    {task.reminderAt && (
                        <div className="pt-2 text-xs">
                            <div className="text-sky-300 flex justify-between items-center mb-0.5">
                                <span>
                                    Reminder: {new Date(task.reminderAt).toLocaleTimeString([], {
                                        timeZone: clockTimezone,
                                        hour: '2-digit', minute:'2-digit', second: '2-digit'
                                    })} {clockTimezone}
                                </span>
                                <button onClick={() => updateTask(task.id, { reminderAt: null, reminderFired: false })} title="Clear reminder" className="text-red-400 hover:text-red-300 text-xs">(clear)</button>
                            </div>
                            <ReminderCountdown reminderAt={task.reminderAt} />
                        </div>
                    )}
                    {isDetailedView && (
                        <div className="pt-3 border-t border-slate-700/50 space-y-3">
                            {/* Metadata */}
                            <div className="text-xs text-slate-500 space-y-1">
                                <div className="flex justify-between">
                                    <span>Created:</span>
                                    <span>{new Date(task.createdAt || task.timestamp).toLocaleString([], { timeZone: clockTimezone, dateStyle: 'medium', timeStyle: 'short' })}</span>
                                </div>
                                <div className="flex justify-between">
                                    <span>Last Updated:</span>
                                    <span>{new Date(task.timestamp).toLocaleString([], { timeZone: clockTimezone, dateStyle: 'medium', timeStyle: 'short' })}</span>
                                </div>
                            </div>
                            {/* Actions */}
                            <div className="flex justify-between items-center">
                            <select 
                                value={task.project || ''} 
                                onChange={(e) => updateTask(task.id, { project: e.target.value || null })}
                                disabled={isLocked}
                                className="text-sm bg-slate-800 text-slate-200 px-2 py-1 rounded-md border border-slate-600 hover:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:border-sky-500 disabled:cursor-not-allowed disabled:opacity-70"
                            >
                                <option value="">Unassigned</option>
                                {allTags.map(project => (
                                    <option key={project} value={project}>{project}</option>
                                ))}
                            </select>
                            <div className="flex items-center">
                                <button onClick={handleDeleteRequest} title="Delete Permanently" className="text-red-400 hover:text-white transition-colors p-1 rounded-full hover:bg-red-500"><DeleteIcon /></button>
                            </div>
                            </div>
                        </div>
                    )}
                </div>
            </div>
            {showResetTimeConfirm && (
                <Modal onClose={() => setShowResetTimeConfirm(false)}>
                    <div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}>
                        <h3 className="text-lg font-bold text-white mb-2">Reset Time?</h3>
                        <p className="text-slate-300 mb-4">Are you sure you want to reset the tracked time for this task? This cannot be undone.</p>
                        <div className="flex justify-center space-x-4"><button onClick={() => setShowResetTimeConfirm(false)} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button><button onClick={handleResetTimer} className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-500">Reset</button></div>
                    </div>
                </Modal>
            )}
            </>
            )
        );
    };
    const MemoizedTaskCard = React.memo(TaskCard);

    // --- New Components for Master-Detail Layout ---
    const TaskListItem = React.memo(({ task, isSelected, onSelect }) => {
        const { tasks: allTasks } = useAppContext(); // Get all tasks to check dependencies
        const priorityConfig = PRIORITY_CONFIG[task.priority] || PRIORITY_CONFIG.null;
        const isDone = task.status === TASK_STATUS.DONE;

        const isBlocked = useMemo(() => {
            if (isDone || !task.dependsOn || task.dependsOn.length === 0) return false;
            return task.dependsOn.some(depId => {
                const dependencyTask = allTasks.find(t => t.id === depId);
                return dependencyTask && dependencyTask.status !== TASK_STATUS.DONE;
            });
        }, [task.dependsOn, allTasks, isDone]);

        const isUnlocked = useMemo(() => {
            // A task is "unlocked" if it's not done, has dependencies, but is not currently blocked.
            if (isDone || !task.dependsOn || task.dependsOn.length === 0) return false;
            return !isBlocked;
        }, [isDone, task.dependsOn, isBlocked]);

        return (
            <button
                onClick={() => onSelect(task.id)}
                className={`w-full text-left p-3 rounded-lg border transition-all duration-150 ${isSelected ? 'bg-sky-500/30 border-sky-400 shadow-lg' : 'bg-slate-800/50 border-slate-700 hover:bg-slate-700/50 hover:border-slate-500'}`}
            >
                <div className="flex justify-between items-start gap-2">
                    <div className="flex-grow min-w-0">
                        <div className="flex items-center gap-1.5 flex-wrap">
                            {isUnlocked && <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-green-400 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor"><path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 016 0v2a1 1 0 102 0V7a5 5 0 00-5-5z" /></svg>}
                            {isBlocked && <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-amber-400 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z" clipRule="evenodd" /></svg>}
                            <p className={`font-semibold break-words ${isDone ? 'line-through text-slate-500' : 'text-slate-100'}`}>{task.title}</p>
                        </div>
                        <div className="flex items-center gap-x-2 gap-y-1 flex-wrap mt-1.5 text-xs">
                        {task.dueDate && (
                            <span className={`font-semibold px-2 py-0.5 rounded-full whitespace-nowrap ${new Date(task.dueDate) < new Date() && !isDone ? 'bg-red-500/30 text-red-300 border border-red-500/50' : 'bg-slate-700/50 text-slate-300 border border-slate-600'}`}>
                                {new Date(task.dueDate).toLocaleDateString([], { month: 'numeric', day: 'numeric' })}
                            </span>
                        )}
                        {task.size && (
                            <span className="font-semibold px-2 py-0.5 rounded-full bg-slate-700/50 text-slate-300 border border-slate-600 whitespace-nowrap">
                                {TASK_SIZES[task.size]}
                            </span>
                        )}
                        {(task.tags || []).map(tag => {
                            const tagHash = tag.split('').reduce((acc, char) => char.charCodeAt(0) + ((acc << 5) - acc), 0);
                            const colors = ['bg-red-900/70 text-red-300', 'bg-yellow-900/70 text-yellow-300', 'bg-green-900/70 text-green-300', 'bg-blue-900/70 text-blue-300', 'bg-indigo-900/70 text-indigo-300', 'bg-purple-900/70 text-purple-300', 'bg-pink-900/70 text-pink-300'];
                            const colorClass = colors[Math.abs(tagHash % colors.length)];
                            return <span key={tag} className={`font-semibold px-2 py-0.5 rounded-full whitespace-nowrap ${colorClass}`}>{tag}</span>
                        })}
                        </div>
                    </div>
                    <span className={`font-bold px-2 py-0.5 rounded-full border ${priorityConfig.color} ${priorityConfig.bgColor} ${priorityConfig.borderColor} flex-shrink-0 text-xs self-center`}>
                        {priorityConfig.title}
                    </span>
                </div>
            </button>
        );
    });

    const TaskList = React.memo(({ tasks, selectedTaskId, onSelectTask, onProjectHeaderClick, selectedProjectName, onShowDeleteAllModal, completedTasksCount, onAddTask }) => {
        const { projectSettings, collapsedProjects, toggleProjectCollapse } = useAppContext();
        const groupedAndSortedTasks = useMemo(() => { // This logic is correct, no changes needed here.
            // Manual sorting by rank is now the primary method.
            const activeTaskSorter = (a, b) => {
                const priorityA = getPrioritySortValue(a.priority);
                const priorityB = getPrioritySortValue(b.priority);
                if (priorityA !== priorityB) return priorityA - priorityB;
                return a.title.localeCompare(b.title);
            };
            const completedTaskSorter = (a, b) => new Date(b.timestamp) - new Date(a.timestamp);

            const grouped = tasks.reduce((acc, task) => {
                // Ensure 'Completed' group always exists
                if (!acc['Completed']) {
                    acc['Completed'] = [];
                }
                const key = task.status === TASK_STATUS.DONE ? 'Completed' : (task.project || 'Unassigned');
                if (!acc[key]) acc[key] = [];
                acc[key].push(task);
                return acc;
            }, {});

            // Sort tasks within each group
            for (const projectName in grouped) {
                if (projectName === 'Completed') {
                    grouped[projectName].sort(completedTaskSorter);
                } else {
                    grouped[projectName].sort(activeTaskSorter);
                }
            }

            // Sort the project groups themselves, keeping 'Completed' at the bottom
            return Object.entries(grouped).sort(([a], [b]) => {
                if (a === 'Completed') return 1;
                if (b === 'Completed') return -1;
                return a.localeCompare(b);
            });
        }, [tasks]);

        return (
            <div className="space-y-4">
                {groupedAndSortedTasks.map(([projectName, tasksInGroup]) => {
                    const isCollapsed = collapsedProjects[projectName];
                    const settings = projectSettings[projectName] || {};
                    const fallbackColors = ['bg-red-900/20', 'bg-yellow-900/20', 'bg-green-900/20', 'bg-blue-900/20', 'bg-indigo-900/20', 'bg-purple-900/20', 'bg-pink-900/20', 'bg-slate-900/20'];
                    const projectHash = projectName.split('').reduce((acc, char) => char.charCodeAt(0) + ((acc << 5) - acc), 0);
                    const fallbackColor = fallbackColors[Math.abs(projectHash % fallbackColors.length)];
                    const style = settings.color ? { backgroundColor: settings.color } : {};
                    const bgColorClass = settings.color ? '' : fallbackColor;

                    return (
                        <div key={projectName} className={`${bgColorClass} border rounded-lg backdrop-blur-sm transition-all duration-300 ${selectedProjectName === projectName ? 'border-sky-400' : 'border-slate-700/40'} ${projectName === 'Completed' ? 'border-green-700/60' : ''}`} style={style}>
                            <div className={`flex items-center justify-between w-full text-left text-sm font-bold uppercase tracking-wider pl-2 pr-4 pt-3 pb-2 border-b border-indigo-800/50 transition-colors`}>
                                <button onClick={() => toggleProjectCollapse(projectName)} title={isCollapsed ? 'Expand project' : 'Collapse project'} className="p-2 rounded-full hover:bg-slate-700/50 text-indigo-300 flex-shrink-0">
                                    <ChevronDownIcon className={`h-4 w-4 transition-transform duration-200 ${isCollapsed ? '-rotate-90' : ''}`} />
                                </button>
                                <div onClick={() => onProjectHeaderClick(projectName)} className="flex-grow cursor-pointer hover:bg-white/5 p-2 rounded-md">
                                    <span className="text-indigo-300 hover:underline">{projectName} ({tasksInGroup.length})</span>
                                </div>
                                {projectName !== 'Completed' && <>
                                    <button onClick={() => onAddTask(projectName)} title={`Add task to ${projectName}`} className="p-1 text-sky-300 hover:text-white rounded-full hover:bg-sky-500/30 transition-colors flex-shrink-0 mx-1"><PlusIcon /></button>
                                </>}
                                {projectName === 'Completed' && (
                                    <button onClick={onShowDeleteAllModal} title="Delete All Completed Tasks" className="p-1 text-red-400 hover:text-white rounded-full hover:bg-red-500/30 transition-colors flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed" disabled={completedTasksCount === 0}>
                                        <DeleteIcon />
                                    </button>
                                )}
                            </div>
                            {!isCollapsed && (
                                <div className="space-y-2 p-3">
                                    {tasksInGroup.map(task => <TaskListItem key={task.id} task={task} isSelected={selectedTaskId === task.id} onSelect={onSelectTask} />)}
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        );
    });

    // --- Main Presentation Component ---
    const App = () => {
        const { 
            tasks, addTask,
            settings, setSettings,
            taskToDelete, setTaskToDelete, deleteAllCompletedTasks,
            allTags, deleteTask, updateTask, // Core data functions
            activeTags, setActiveTags,                     // Filter state (now just for projects/priorities)
            selectedTaskId, setSelectedTaskId,             // Detail view state,
            collapsedProjects, toggleProjectCollapse
        } = useAppContext();

        const now = useNow(); // Get current time, updates every second

        const [showSettings, setShowSettings] = useState(false);
        const [clockTimezone, setClockTimezone] = useState('America/New_York');

        // State for the summary modal
        const [showSummaryModal, setShowSummaryModal] = useState(false);
        const [summaryText, setSummaryText] = useState('');
        const [showDeleteAllCompletedModal, setShowDeleteAllCompletedModal] = useState(false);
        const [showNewProjectModal, setShowNewProjectModal] = useState(false);
        const [showReleaseNotesModal, setShowReleaseNotesModal] = useState(false);
        const [selectedProjectName, setSelectedProjectName] = useState(null);
        const [taskToComplete, setTaskToComplete] = useState(null);
        const windowWidth = useWindowWidth();
        // --- Effect for showing release notes once per version ---

        useEffect(() => {
            const lastSeenVersion = localStorage.getItem('taiko-app-local-lastSeenVersion');
            if (lastSeenVersion !== CURRENT_APP_VERSION) {
                setShowReleaseNotesModal(true);
            }
        }, []); // Run only once on mount

        // --- Responsive State ---
        const isSmallScreen = windowWidth < 768; // Tailwind's `md` breakpoint
        const showDetailViewOnMobile = isSmallScreen && (selectedTaskId || selectedProjectName);
        const showListViewOnMobile = isSmallScreen && !showDetailViewOnMobile;


        const handleCloseReleaseNotes = () => {
            setShowReleaseNotesModal(false);
            localStorage.setItem('taiko-app-local-lastSeenVersion', CURRENT_APP_VERSION);
        };

        // --- Effect for Global Keyboard Shortcuts ---
        useEffect(() => {
            const handleKeyDown = (e) => {
                // Ignore shortcuts if user is typing in an input field
                if (['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                    return;
                }

                // Use 'd' key to delete the currently selected task
                if (e.key.toLowerCase() === 'd' && selectedTaskId) {
                    e.preventDefault();
                    if (settings.confirmOnDelete) {
                        setTaskToDelete(selectedTaskId);
                    } else {
                        deleteTask(selectedTaskId);
                    }
                }

                // Use 'c' key to complete the currently selected task
                if (e.key.toLowerCase() === 'c' && selectedTaskId) {
                    e.preventDefault();
                    // Find the task to show its title in the modal
                    const task = tasks.find(t => t.id === selectedTaskId);
                    if (task && task.status !== TASK_STATUS.DONE) {
                        setTaskToComplete(task);
                    }
                }
            };

            window.addEventListener('keydown', handleKeyDown);
            return () => window.removeEventListener('keydown', handleKeyDown);
        }, [selectedTaskId, settings.confirmOnDelete, setTaskToDelete, deleteTask, tasks, setTaskToComplete]);

        const activeTasksCount = useMemo(() => tasks.filter(t => t.status !== TASK_STATUS.DONE).length, [tasks]);

        const completedTasksCount = useMemo(() => tasks.filter(t => t.status === TASK_STATUS.DONE).length, [tasks]);

        const priorityFilterCounts = useMemo(() => {
            const counts = {};
            DISPLAY_PRIORITY_ORDER.forEach(priorityConstant => {
                const displayTitle = PRIORITY_CONFIG[priorityConstant].title;
                counts[displayTitle] = tasks.filter(task => task.status !== TASK_STATUS.DONE && task.priority === priorityConstant).length;
            });
            return counts;
        }, [tasks]); // DISPLAY_PRIORITY_ORDER and PRIORITY_CONFIG are stable constants

        const customTagFilterCounts = useMemo(() => {
            const counts = {};
            const activeTasks = tasks.filter(t => t.status !== TASK_STATUS.DONE);
            allTags.forEach(project => {
                counts[project] = activeTasks.filter(task => task.project === project).length;
            });
            return counts;
        }, [tasks, allTags]);

        // --- Effect for Reminder Notifications & Sounds ---
        useEffect(() => {
            tasks.forEach(task => {
                if (task.reminderAt && !task.reminderFired && task.status !== TASK_STATUS.DONE && new Date(task.reminderAt) <= now) {
                    updateTask(task.id, { reminderFired: true });

                    // Play sound based on priority
                    switch (task.priority) {
                        case PRIORITIES.HIGH:
                            playTone(880, 0.6, 'sawtooth', 0.4); // Higher pitch, slightly harsher, louder
                            setTimeout(() => playTone(880, 0.3, 'sawtooth', 0.4), 150); // Quick second beep
                            break;
                        case PRIORITIES.MEDIUM:
                            playTone(660, 0.8, 'square', 0.35); // Medium pitch
                            break;
                        case PRIORITIES.LOW:
                            playTone(440, 1.0, 'sine', 0.3); // Lower pitch, softer
                            break;
                        default: // Unprioritized or null
                            playTone(523, 0.7, 'sine', 0.25); // A general C5 note
                    }
                }
            });
        }, [tasks, now, updateTask]);

        const handleConfirmDelete = useCallback(() => {
            if (!taskToDelete) return;
            deleteTask(taskToDelete);
            setTaskToDelete(null); // This is correct
        }, [taskToDelete, deleteTask]);

        const handleConfirmComplete = useCallback(() => {
            if (!taskToComplete) return;
            // This is the same logic as in the TaskCard's completion toggle
            updateTask(taskToComplete.id, { status: TASK_STATUS.DONE, reminderAt: null, reminderFired: false });
            setTaskToComplete(null);
        }, [taskToComplete, updateTask]);

        const handleCreateProject = (projectName) => {
            if (projectName && projectName.trim()) {
                const newTask = addTask('New Task', projectName.trim());
                setSelectedTaskId(newTask.id);
            }
            setShowNewProjectModal(false);
        };

        const [showAddTaskModal, setShowAddTaskModal] = useState(false);
        const handleAddTaskFromModal = ({ title, priority, tags }) => {
            // This will now handle a single project
            const newTask = addTask(title, null, priority); 
            setSelectedTaskId(newTask.id); // Select the newly created task
            setShowAddTaskModal(false); 
        };
        const handleConfirmDeleteAllCompleted = useCallback(() => {
            deleteAllCompletedTasks();
            setShowDeleteAllCompletedModal(false);
        }, [deleteAllCompletedTasks]);
        // The project view has been removed, so we only need the main task view.
        // The 'currentView' state and toggle function are no longer needed for switching to a project page.
        
        const handleTimezoneChange = (newTimezone) => setClockTimezone(newTimezone);
        
        // Effect to automatically hide empty swimlanes if autoCollapse is enabled (and they are empty after filtering)

        const generateCompletedTasksSummary = useCallback(() => {
            const localeOptions = { year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric', minute: '2-digit', timeZone: clockTimezone };
            const formatTime = (dateString) => new Date(dateString).toLocaleString('en-US', localeOptions);

            let summary = `Taiko Task Summary\n`;
            summary += `   Generated: ${formatTime(new Date())} (${TIMEZONES.find(tz => tz.value === clockTimezone)?.label || clockTimezone})\n\n`;

            if (tasks.length === 0) {
                summary += "No tasks to summarize.";
                setSummaryText(summary);
                setShowSummaryModal(true);
                return;
            }

            const groupTasksByProject = (tasksToGroup) => {
                const grouped = tasksToGroup.reduce((acc, task) => {
                    const project = task.project || 'Unassigned';
                    if (!acc[project]) acc[project] = [];
                    acc[project].push(task);
                    return acc;
                }, {});
                return Object.entries(grouped).sort(([a], [b]) => a.localeCompare(b));
            };

            const buildSection = (title, tasksToProcess, isCompletedSection = false) => {
                let sectionText = `${title} (${tasksToProcess.length})\n`;
                if (tasksToProcess.length === 0) {
                    sectionText += `   └─ No tasks in this section.\n`;
                    return sectionText;
                }

                const projects = groupTasksByProject(tasksToProcess);

                projects.forEach(([projectName, projectTasks], projectIndex) => {
                    const isLastProject = projectIndex === projects.length - 1;
                    const projectPrefix = isLastProject ? '└─' : '├─';
                    sectionText += `${projectPrefix} ${projectName} (${projectTasks.length})\n`;

                    projectTasks.forEach((task, taskIndex) => {
                        const isLastTask = taskIndex === projectTasks.length - 1;
                        const projectIndent = isLastProject ? '   ' : '│  ';
                        // Only show upstream dependencies that are not yet completed.
                        const upstreamDependencies = (task.dependsOn || []).map(depId => tasks.find(t => t.id === depId))
                            .filter(t => t && t.status !== TASK_STATUS.DONE);

                        const taskPrefix = isLastTask ? '└─' : '├─';
                        let taskLine = `${projectIndent}${taskPrefix} ${isCompletedSection ? '☑' : '☐'} ${task.title}`;
                        
                        if (upstreamDependencies.length > 0) {
                            const blockedByText = upstreamDependencies.map(t => t.title).join(', ');
                            taskLine += ` [Blocked by: ${blockedByText}]`;
                        }

                        if (isCompletedSection) {
                            taskLine += ` (Completed: ${formatTime(task.timestamp)})`;
                        }
                        sectionText += `${taskLine}\n`;

                        const checklist = task.checklist || [];
                        const taskIndent = `${projectIndent}${isLastTask ? '   ' : '│  '}`;

                        if (task.notes && task.notes.trim()) {
                            const notesPrefix = checklist.length > 0 ? '├─' : '└─';
                            sectionText += `${taskIndent}${notesPrefix} Notes: ${task.notes.trim().replace(/\n/g, `\n${taskIndent}   `)}\n`;
                        }

                        checklist.forEach((item, itemIndex) => {
                            const isLastItem = itemIndex === checklist.length - 1;
                            const itemPrefix = isLastItem ? '└─' : '├─';
                            let itemLine = `${taskIndent}${itemPrefix} ${item.completed ? '☑' : '☐'} ${item.text}`;
                            if (item.completed && item.completedAt) {
                                itemLine += ` (Completed: ${formatTime(item.completedAt)})`;
                            }
                            sectionText += `${itemLine}\n`;
                        });
                    });
                });
                return sectionText;
            };

            const inProgressTasks = tasks.filter(t => t.status !== TASK_STATUS.DONE).sort((a, b) => getPrioritySortValue(a.priority) - getPrioritySortValue(b.priority));
            const completedTasks = tasks.filter(t => t.status === TASK_STATUS.DONE).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

            summary += buildSection('In Progress', inProgressTasks, false);
            summary += '\n';
            summary += buildSection('Completed', completedTasks, true);

            setSummaryText(summary);
            setShowSummaryModal(true);
        }, [tasks, clockTimezone]);

        const handleTagFilterClick = (tag) => {
            setActiveTags(prevActiveTags => {
                // If the clicked tag is already the active one, clear the filter.
                if (prevActiveTags.length === 1 && prevActiveTags[0] === tag) {
                    return [];
                } else {
                    // Otherwise, make the clicked tag the only active filter.
                    return [tag];
                }
            });
};

const handleProjectHeaderClick = (projectName) => {
    // When a project header is clicked, show all its tasks and deselect any single task.
    setSelectedProjectName(projectName);
    setSelectedTaskId(null);
        };

        const clearTagFilter = () => setActiveTags([]);

        const tasksMatchingActiveFilters = useMemo(() => {
            if (activeTags.length === 0) return tasks;
            return tasks.filter(task =>
                activeTags.some(activeTag => {
                    const priorityConstant = PRIORITY_TITLE_TO_CONSTANT_MAP[activeTag]; // This part handles priority filters
                    return priorityConstant ? task.priority === priorityConstant : task.project === activeTag;
                })
            );
        }, [tasks, activeTags]);
        // const handleDropSwimlane = (targetSwimlaneName) => {
        
        const selectedTask = useMemo(() => {
            return tasks.find(t => t.id === selectedTaskId);
        }, [tasks, selectedTaskId]);

        const tasksForProjectView = useMemo(() => {
            if (!selectedProjectName) return [];
            if (selectedProjectName === 'Completed') {
                // Special case for the "Completed" virtual project, sorted by completion time
                return tasks.filter(t => t.status === TASK_STATUS.DONE)
                            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }
            // For all other projects, find tasks by their assigned project name
            // and sort them by priority.
            return tasks.filter(t => (t.project || 'Unassigned') === selectedProjectName && t.status !== TASK_STATUS.DONE)
                        .sort((a, b) => getPrioritySortValue(a.priority) - getPrioritySortValue(b.priority));
        }, [tasks, selectedProjectName]);

        return (
            <div className="h-screen w-screen font-sans flex flex-col overflow-x-hidden" style={{ background: 'transparent' }}>

                {taskToDelete && <DeleteConfirmationModal onConfirm={handleConfirmDelete} onCancel={() => setTaskToDelete(null)} />}
                {taskToComplete && <CompleteConfirmationModal onConfirm={handleConfirmComplete} onCancel={() => setTaskToComplete(null)} taskTitle={taskToComplete.title} />}
                {showDeleteAllCompletedModal && <DeleteAllCompletedModal onConfirm={handleConfirmDeleteAllCompleted} onCancel={() => setShowDeleteAllCompletedModal(false)} count={completedTasksCount} />}
                {showSummaryModal && <SummaryModal summary={summaryText} onClose={() => setShowSummaryModal(false)} />}
                {showReleaseNotesModal && <ReleaseNotesModal version={CURRENT_APP_VERSION} releaseInfo={RELEASE_NOTES[CURRENT_APP_VERSION]} onClose={handleCloseReleaseNotes} />}
                {showNewProjectModal && <NewProjectModal onAdd={handleCreateProject} onCancel={() => setShowNewProjectModal(false)} />}
                {showSettings && <SettingsModal settings={settings} onSettingsChange={setSettings} onClose={() => setShowSettings(false)} />}
                {showAddTaskModal && <AddTaskModal onAdd={handleAddTaskFromModal} onCancel={() => setShowAddTaskModal(false)} allTags={allTags} />}
                
                <header className="sticky top-0 z-20 px-4 py-2 bg-gradient-to-b from-slate-950/95 to-sky-900/40 backdrop-blur-lg shadow-2xl shadow-black/30 border-b border-sky-900/40 flex items-center justify-between flex-wrap gap-x-4 gap-y-2">
                    {/* --- Left Side: Logo, Title, Toolbar --- */}
                    <div className="flex items-center gap-4">
                        {showDetailViewOnMobile ? (
                            <button 
                                onClick={() => { setSelectedTaskId(null); setSelectedProjectName(null); }}
                                className="text-sky-300 hover:bg-sky-500/20 p-2 rounded-md flex items-center gap-2"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M15 19l-7-7 7-7" /></svg>
                                <span className="font-semibold">Back</span>
                            </button>
                        ) : (
                            <>
                                <TaikoLogo />
                                <h1 className="text-3xl font-bold" style={{ color: '#E0E7FF', textTransform: 'uppercase', letterSpacing: '0.2em' }}>Taiko</h1>
                            </>
                        )}
                        <HeaderToolbar isSmallScreen={windowWidth < 768} onShowSettings={() => setShowSettings(true)} onGenerateSummary={generateCompletedTasksSummary} onShowDeleteAllModal={() => setShowDeleteAllCompletedModal(true)} showDeleteAllButton={completedTasksCount > 0} />
                    </div>

                    {/* --- Right Side: Add Task & Clock --- */}
                    <div className={`flex items-center ${showDetailViewOnMobile ? 'hidden' : ''}`}>
                        <LiveClock timezone={clockTimezone} onTimezoneChange={handleTimezoneChange} />
                    </div>
                </header>
                <div className={`px-4 py-2 flex-shrink-0 border-b border-slate-800 flex justify-between items-center flex-wrap gap-4 ${showDetailViewOnMobile ? 'hidden' : ''}`}>
                    <FilterToolbar
                        activeTasksCount={activeTasksCount}
                        completedTasksCount={completedTasksCount}
                        activeTags={activeTags}
                        priorityFilterCounts={priorityFilterCounts}
                        tagsForCurrentView={allTags}
                        customTagFilterCounts={customTagFilterCounts}
                        onShowNewProjectModal={() => setShowNewProjectModal(true)}
                        onClearFilters={clearTagFilter}
                        onTagFilterClick={handleTagFilterClick}
                    />
                </div>
                <main className={`flex-grow p-4 flex flex-col md:flex-row gap-4 overflow-hidden transition-all duration-300`}>
                            {/* Left Pane: Task List */}
                            <div className={`w-full md:w-1/3 flex-shrink-0 overflow-y-auto pr-2 ${showDetailViewOnMobile ? 'hidden' : ''}`}>
                                <TaskList
                                    tasks={tasksMatchingActiveFilters}
                                    selectedTaskId={selectedTaskId}
                                    onSelectTask={(id) => { setSelectedTaskId(id); setSelectedProjectName(null); }} // This is correct
                                    onProjectHeaderClick={handleProjectHeaderClick}
                                    selectedProjectName={selectedProjectName}
                                    onShowDeleteAllModal={() => setShowDeleteAllCompletedModal(true)} // Pass down the modal toggle
                                    onAddTask={(projectName) => { 
                                        // Create the new task and get it back
                                        const newTask = addTask('', projectName); 
                                        // Select the new task to show its detail view
                                        setSelectedTaskId(newTask.id);
                                        // Clear any project-wide view
                                        setSelectedProjectName(null);
                                        // Ensure the project is expanded
                                        if (collapsedProjects[projectName]) toggleProjectCollapse(projectName);
                                    }}
                                    completedTasksCount={completedTasksCount} // This is correct
                                />
                            </div>

                            {/* Right Pane: Task Details */}
                            <div className={`w-full md:w-2/3 flex-grow overflow-y-auto ${showListViewOnMobile ? 'hidden' : ''}`}>
                                {selectedProjectName ? (
                                    <div className="space-y-4">
                                        {tasksForProjectView.length > 0 ? (
                                            tasksForProjectView.map(task => 
                                                <MemoizedTaskCard 
                                                    key={task.id} task={task} clockTimezone={clockTimezone} isDetailedView={false} 
                                                    onSelect={(id) => { setSelectedTaskId(id); setSelectedProjectName(null); }}
                                                />
                                            )
                                        ) : ( 
                                            <p className="text-slate-500 px-2">No tasks in this project.</p>
                                        )}
                                    </div>
                                ) : selectedTask ? (
                                    // When viewing a single selected task, isDetailedView is true
                                    <MemoizedTaskCard 
                                        key={selectedTask.id} 
                                        task={selectedTask} 
                                        clockTimezone={clockTimezone}
                                        startInEditMode={selectedTask.id === selectedTaskId && selectedTask.title === ''}
                                        isDetailedView={true}
                                    />
                                ) : (
                                    <div className="h-full flex items-center justify-center text-slate-500 text-xl">
                                        Select a task or a project to see details
                                    </div>
                                )}
                            </div>
                        </main>
                <Footer onShowReleaseNotes={() => setShowReleaseNotesModal(true)} />
            </div>
        );
    };
    // --- Column & Modal Components ---
    const FilterToolbar = React.memo(({
        activeTasksCount,
        completedTasksCount,
        activeTags,
        priorityFilterCounts,
        tagsForCurrentView,
        customTagFilterCounts,
        onShowNewProjectModal,
        onClearFilters,
        onTagFilterClick
    }) => {
        const [isFilterMenuOpen, setIsFilterMenuOpen] = useState(false);
        const filterMenuRef = useRef(null);

        useEffect(() => {
            const handleClickOutside = (event) => {
                if (filterMenuRef.current && !filterMenuRef.current.contains(event.target)) {
                    setIsFilterMenuOpen(false);
                }
            };
            document.addEventListener("mousedown", handleClickOutside);
            return () => document.removeEventListener("mousedown", handleClickOutside);
        }, [filterMenuRef]);

        const filterButtonText = activeTags.length > 0 ? `Filtered: ${activeTags.join(', ')}` : 'Filter by...';

        return (
            <div className="flex items-center space-x-2 flex-wrap">
                {/* --- New Project Button --- */}
                <button 
                    onClick={onShowNewProjectModal}
                    title="Create a new project" 
                    className="px-3 py-1 text-sm font-medium rounded-md transition-colors text-sky-300 bg-sky-600/30 hover:bg-sky-600/50 border border-sky-600/80 flex items-center gap-1.5"><PlusIcon /> New Project</button>
                {/* --- Unified Filter Dropdown --- */}
                <div className="relative" ref={filterMenuRef}>
                    <button onClick={() => setIsFilterMenuOpen(p => !p)} title="Select a filter" className={`px-3 py-1 text-sm font-medium rounded-md transition-colors flex items-center gap-1 ${activeTags.length > 0 ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>
                        {filterButtonText}
                        <ChevronDownIcon className={`h-4 w-4 transition-transform ${isFilterMenuOpen ? 'rotate-180' : ''}`} />
                    </button>
                    {isFilterMenuOpen && (
                        <div className="absolute left-0 mt-2 w-56 bg-slate-800 border border-slate-700 rounded-md shadow-lg py-1 z-20">
                            <button onClick={() => { onClearFilters(); setIsFilterMenuOpen(false); }} className={`w-full text-left px-4 py-2 text-sm ${activeTags.length === 0 ? 'text-white bg-sky-600' : 'text-slate-200 hover:bg-slate-700'}`}>All Active ({activeTasksCount})</button>
                            <div className="my-1 border-t border-slate-700"></div>
                            <div className="px-4 pt-2 pb-1 text-xs font-semibold text-slate-400">By Priority</div>
                            {DISPLAY_PRIORITY_ORDER.map(pConst => {
                                const pTitle = PRIORITY_CONFIG[pConst].title;
                                return <button key={pTitle} onClick={() => { onTagFilterClick(pTitle); setIsFilterMenuOpen(false); }} className={`w-full text-left px-4 py-2 text-sm ${activeTags.includes(pTitle) ? `text-white ${PRIORITY_CONFIG[pConst].bgColor}` : 'text-slate-200 hover:bg-slate-700'}`}>{pTitle} ({priorityFilterCounts[pTitle] || 0})</button>
                            })}
                            {tagsForCurrentView.length > 0 && (
                                <>
                                    <div className="my-1 border-t border-slate-700"></div>
                                    <div className="px-4 pt-2 pb-1 text-xs font-semibold text-slate-400">By Project</div>
                                    {tagsForCurrentView.map(tag => (
                                        <button key={tag} onClick={() => { onTagFilterClick(tag); setIsFilterMenuOpen(false); }} className={`w-full text-left px-4 py-2 text-sm ${activeTags.includes(tag) ? 'text-white bg-indigo-600' : 'text-slate-200 hover:bg-slate-700'}`}>{tag} ({customTagFilterCounts[tag] || 0})</button>
                                    ))}
                                </>
                            )}
                        </div>
                    )}
                </div>
            </div>
        );
    });
    const HeaderToolbar = React.memo(({ isSmallScreen, onShowSettings, onGenerateSummary, onShowDeleteAllModal, showDeleteAllButton }) => {
        const [isMenuOpen, setIsMenuOpen] = useState(false);
        const menuRef = useRef(null);

        useEffect(() => {
            const handleClickOutside = (event) => {
                if (menuRef.current && !menuRef.current.contains(event.target)) {
                    setIsMenuOpen(false);
                }
            };
            document.addEventListener("mousedown", handleClickOutside);
            return () => document.removeEventListener("mousedown", handleClickOutside);
        }, [menuRef]);

        const menuItems = (
            <>
                <button onClick={onShowSettings} className="w-full text-left px-4 py-2 text-sm text-slate-200 hover:bg-slate-700">Settings</button>
                <a href="https://github.com/closedloopchaos/taiko/issues/new/choose" target="_blank" rel="noopener noreferrer" className="block w-full text-left px-4 py-2 text-sm text-slate-200 hover:bg-slate-700">Report Issue</a>
                <button onClick={onGenerateSummary} className="w-full text-left px-4 py-2 text-sm text-slate-200 hover:bg-slate-700">Generate Summary</button>
                {showDeleteAllButton && <button onClick={onShowDeleteAllModal} className="w-full text-left px-4 py-2 text-sm text-red-400 hover:bg-red-500/20">Delete All Completed</button>}
            </>
        );

        if (isSmallScreen) {
            return (
                <div className="relative" ref={menuRef}>
                    <button onClick={() => setIsMenuOpen(prev => !prev)} title="More options" className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z" /></svg>
                    </button>
                    {isMenuOpen && (
                        <div className="absolute left-0 mt-2 w-48 bg-slate-800 border border-slate-700 rounded-md shadow-lg py-1 z-20">
                            {menuItems}
                        </div>
                    )}
                </div>
            );
        }

        return (
            <div className="flex items-center flex-wrap gap-2">
                <button onClick={onShowSettings} title="Settings" className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><SettingsIcon /></button>
                <a href="https://github.com/closedloopchaos/taiko/issues/new/choose" title="Report Issue or Submit Feedback" target="_blank" rel="noopener noreferrer" className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><BugIcon /></a>
                <button onClick={onGenerateSummary} title="Generate Summary of Completed Tasks" className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><DocumentTextIcon /></button>
            </div>
        );
    });
    const Footer = React.memo(({ onShowReleaseNotes }) => {
        const EarthIcon = () => (
            <svg viewBox="0 0 100 100" className="absolute bottom-0 left-1/2 -translate-x-1/2 h-48 w-48 text-slate-700/50 opacity-30 -z-10" fill="none" stroke="currentColor" strokeWidth="0.5">
                <circle cx="50" cy="50" r="48"/>
                <ellipse cx="50" cy="50" rx="48" ry="20"/>
                <ellipse cx="50" cy="50" rx="48" ry="40" transform="rotate(90 50 50)"/>
                <path d="M 10,60 C 20,75 40,80 50,70 S 70,50 85,55"/>
                <path d="M 5,40 C 25,45 40,30 55,35 S 80,50 95,45"/>
                <path d="M 20,20 C 30,35 50,35 60,25 S 80,20 85,30"/>
            </svg>
        );
        return (
            <footer className="relative bg-slate-900/80 backdrop-blur-sm p-3 text-center text-sm text-slate-400 shadow-t-lg z-40 flex-shrink-0 overflow-hidden">
                <EarthIcon />
                <div className="flex items-center justify-center space-x-4">
                    <div className="flex items-center justify-center space-x-1.5">
                        <span>Courtesy of</span>
                        <a href="https://github.com/closedloopchaos" target="_blank" rel="noopener noreferrer" className="inline-flex items-center text-sky-400 hover:text-sky-300 font-semibold hover:underline">
                            <svg className="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 16 16" aria-hidden="true"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>
                            closedloopchaos
                        </a>
                    </div>
                    <div className="border-l border-slate-600 h-5"></div>
                    <button onClick={onShowReleaseNotes} className="text-sky-400 hover:text-sky-300 font-semibold hover:underline">Release Notes (v{CURRENT_APP_VERSION})</button>
                </div>
            </footer>
        );
    });

    const AddTaskButton = React.memo(({ onAddTask }) => {
        const windowWidth = useWindowWidth();
        const isSmall = windowWidth < 768;

        return (
            <div className="relative">
                <button 
                    onClick={onAddTask}
                    title="Add a new task (A)"
                    className="px-3 py-1.5 bg-sky-500/20 border border-sky-500/80 text-sky-200 text-sm font-semibold rounded-lg shadow-md hover:bg-sky-500/40 hover:text-white focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-opacity-75 transition-all flex items-center gap-2"
                >
                    <PlusIcon /> {!isSmall && 'Add Task'}
                </button>
            </div>
        );
    });

    const AddTaskModal = ({ onAdd, onCancel, allTags }) => {
        const [title, setTitle] = useState('');
        const [priority, setPriority] = useState(null);
        const [tags, setTags] = useState([]);
        const [currentTagInput, setCurrentTagInput] = useState('');
        const inputRef = useRef(null);

        useEffect(() => {
            if (inputRef.current) inputRef.current.focus();
        }, []);

        const handleAdd = () => {
            if (title.trim()) {
                onAdd({ title: title.trim(), priority, tags });
            }
        };

        const handleTitleKeyDown = (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Prevent form submission or newline
                handleAdd();
            }
        };

        const handleAddTag = () => {
            const trimmedTag = currentTagInput.trim();
            if (trimmedTag && !tags.includes(trimmedTag)) {
                setTags([...tags, trimmedTag]);
            }
            setCurrentTagInput('');
        };

        const handleRemoveTag = (tagToRemove) => {
            setTags(tags.filter(tag => tag !== tagToRemove));
        };

        return (
            <Modal onClose={onCancel}>
                <ModalContent title="Add New Task" onClose={onCancel}>
                    <div className="space-y-4">
                        {/* Title Input */}
                        <input
                            ref={inputRef}
                            type="text"
                            value={title}
                            onChange={e => setTitle(e.target.value)}
                            onKeyDown={handleTitleKeyDown}
                            placeholder="Enter task title..."
                            className="w-full bg-slate-900/80 text-slate-200 text-lg p-3 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500"
                        />

                        {/* Priority Selection */}
                        <div className="pt-2 border-t border-slate-700/50">
                            <div className="flex flex-wrap items-center gap-2">
                                <span className="text-sm text-slate-400">Priority:</span>
                                {DISPLAY_PRIORITY_ORDER.map(pConst => (                                    <button 
                                        key={pConst} title={`Set priority to ${PRIORITY_CONFIG[pConst].title}`}
                                        onClick={() => setPriority(pConst === priority ? null : pConst)}
                                        className={`px-3 py-1 text-xs font-semibold rounded-md border transition-colors ${priority === pConst ? `${PRIORITY_CONFIG[pConst].bgColor} ${PRIORITY_CONFIG[pConst].borderColor} ${PRIORITY_CONFIG[pConst].color}` : `bg-slate-600/50 border-slate-500 text-slate-300 hover:${PRIORITY_CONFIG[pConst].bgColor}`}`}
                                    >
                                        {PRIORITY_CONFIG[pConst].title}
                                    </button>
                                ))}
                            </div>
                        </div>

                        {/* Action Buttons */}
                        <div className="flex justify-end space-x-2 pt-3 border-t border-slate-700/50">
                            <button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button>
                            <button onClick={handleAdd} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500">Add Task</button>
                        </div>
                    </div>
                </ModalContent>
            </Modal>
        );
    };

    const NewProjectModal = ({ onAdd, onCancel }) => {
        const [name, setName] = useState('');
        const inputRef = useRef(null);

        useEffect(() => {
            if (inputRef.current) inputRef.current.focus();
        }, []);

        const handleAdd = () => {
            if (name.trim()) {
                onAdd(name.trim());
            }
        };

        const handleKeyDown = (e) => {
            if (e.key === 'Enter') { e.preventDefault(); handleAdd(); }
        };

        return (
            <Modal onClose={onCancel}>
                <ModalContent title="Create New Project" onClose={onCancel}>
                    <div className="space-y-4">
                        <input ref={inputRef} type="text" value={name} onChange={e => setName(e.target.value)} onKeyDown={handleKeyDown} placeholder="Enter project name..." className="w-full bg-slate-900/80 text-slate-200 text-lg p-3 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500" />
                        <div className="flex justify-end space-x-2 pt-3 border-t border-slate-700/50">
                            <button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button>
                            <button onClick={handleAdd} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500">Create Project</button>
                        </div>
                    </div>
                </ModalContent>
            </Modal>
        );
    };
    const Modal = ({ children, onClose }) => <div onClick={onClose} className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4">{children}</div>;
    const ModalContent = ({ title, children, onClose, headerActions }) => (
        <div 
            className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-md text-white flex flex-col max-h-[90vh]"
            onClick={e => e.stopPropagation()}
        >
            <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                <h3 className="text-xl font-bold">{title}</h3>
                {headerActions && <div>{headerActions}</div>}
            </div>
            <div className="p-4 overflow-y-auto">{children}</div>
        </div>
    );
    const DeleteConfirmationModal = ({ onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Delete Task?</h3><p className="text-slate-300 mb-4">Are you sure you want to permanently delete this task?</p><div className="flex justify-center space-x-4"><button onClick={onCancel} title="Cancel deletion" className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button><button onClick={onConfirm} title="Confirm permanent deletion" className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-500">Delete</button></div></div></Modal>;
    const CompleteConfirmationModal = ({ onConfirm, onCancel, taskTitle }) => (
        <Modal onClose={onCancel}>
            <div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}>
                <h3 className="text-lg font-bold text-white mb-2">Complete Task?</h3>
                <p className="text-slate-300 mb-4">Are you sure you want to mark this task as completed? <br/><strong className="text-slate-100 font-semibold">"{taskTitle}"</strong></p>
                <div className="flex justify-center space-x-4">
                    <button onClick={onCancel} title="Cancel" className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button>
                    <button onClick={onConfirm} title="Confirm completion" className="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-500">Complete</button>
                </div>
            </div>
        </Modal>
    );
    const SettingsModal = ({ settings, onSettingsChange, onClose }) => { 
        const handleToggle = (key) => onSettingsChange(p => ({ ...p, [key]: !p[key] })); 
        const handleAnimationSettingChange = (key, value) => onSettingsChange(p => ({ ...p, animationSettings: { ...p.animationSettings, [key]: value } }));
        return ( 
            <Modal onClose={onClose}>
                <ModalContent title="Settings" onClose={onClose}>
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Confirm on Delete</label>
                            <button onClick={() => handleToggle('confirmOnDelete')} title={settings.confirmOnDelete ? "Disable delete confirmation" : "Enable delete confirmation"} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.confirmOnDelete ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.confirmOnDelete ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                        </div>
                        <div className="pt-4 border-t border-slate-700/50 space-y-4">
                            <h4 className="text-lg font-semibold text-slate-200">Background Animation</h4>
                            <div className="flex items-center justify-between">
                                <label className="text-slate-300">Enable Animation</label>
                                <button onClick={() => handleAnimationSettingChange('enabled', !settings.animationSettings.enabled)} title={settings.animationSettings.enabled ? "Disable background animation" : "Enable background animation"} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.animationSettings.enabled ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.animationSettings.enabled ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </div>
                            <div className="flex items-center justify-between">
                                <label className="text-slate-300">Mouse Interaction</label>
                                <button onClick={() => handleAnimationSettingChange('mouseInteraction', !settings.animationSettings.mouseInteraction)} title={settings.animationSettings.mouseInteraction ? "Disable mouse interaction" : "Enable mouse interaction"} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.animationSettings.mouseInteraction ? 'bg-green-500' : 'bg-slate-600'}`} disabled={!settings.animationSettings.enabled}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.animationSettings.mouseInteraction ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </div>
                            <div className="flex items-center justify-between">
                                <label className="text-slate-300">Click Pulse Effect</label>
                                <button onClick={() => handleAnimationSettingChange('clickPulse', !settings.animationSettings.clickPulse)} title={settings.animationSettings.clickPulse ? "Disable click pulse" : "Enable click pulse"} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.animationSettings.clickPulse ? 'bg-green-500' : 'bg-slate-600'}`} disabled={!settings.animationSettings.enabled}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.animationSettings.clickPulse ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </div>

                            <div className="flex flex-col space-y-2">
                                <label htmlFor="particleCount" className="text-slate-300 flex justify-between">
                                    <span>Particle Count</span>
                                    <span className="text-sky-400 font-mono">{settings.animationSettings.particleCount}</span>
                                </label>
                                <input id="particleCount" type="range" min="250" max="500" step="5"
                                    value={settings.animationSettings.particleCount}
                                    onChange={e => handleAnimationSettingChange('particleCount', parseInt(e.target.value, 10))}
                                    disabled={!settings.animationSettings.enabled}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                                />
                            </div>
                            <div className="flex flex-col space-y-2">
                                <label htmlFor="connectionDistance" className="text-slate-300 flex justify-between">
                                    <span>Connection Distance</span>
                                    <span className="text-sky-400 font-mono">{settings.animationSettings.connectionDistance}px</span>
                                </label>
                                <input id="connectionDistance" type="range" min="30" max="250" step="5"
                                    value={settings.animationSettings.connectionDistance}
                                    onChange={e => handleAnimationSettingChange('connectionDistance', parseInt(e.target.value, 10))}
                                    disabled={!settings.animationSettings.enabled}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                                />
                            </div>
                            <div className="flex flex-col space-y-2">
                                <label htmlFor="particleSpeed" className="text-slate-300 flex justify-between">
                                    <span>Particle Speed</span>
                                    <span className="text-sky-400 font-mono">{settings.animationSettings.particleSpeed.toFixed(1)}</span>
                                </label>
                                <input id="particleSpeed" type="range" min="0.1" max="2" step="0.1"
                                    value={settings.animationSettings.particleSpeed}
                                    onChange={e => handleAnimationSettingChange('particleSpeed', parseFloat(e.target.value))}
                                    disabled={!settings.animationSettings.enabled}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                                />
                            </div>
                        </div>
                    </div>
                </ModalContent>
            </Modal> 
        );
    };
    const DeleteAllCompletedModal = ({ onConfirm, onCancel, count }) => (
        <Modal onClose={onCancel}>
            <div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Delete All Completed Tasks?</h3><p className="text-slate-300 mb-4">Are you sure you want to permanently delete all {count} completed tasks? This action cannot be undone.</p><div className="flex justify-center space-x-4"><button onClick={onCancel} title="Cancel deletion" className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button><button onClick={onConfirm} title="Confirm permanent deletion of all completed tasks" className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-500">Delete All</button></div></div>
        </Modal>
    );

    const SummaryModal = ({ summary, onClose }) => {
        const [copyButtonText, setCopyButtonText] = useState('Copy to Clipboard');
        const [downloadButtonText, setDownloadButtonText] = useState('Download .txt');
        const handleCopy = useCallback(() => {
            if (!navigator.clipboard) {
                console.error('Clipboard API not available.');
                setCopyButtonText('Copy failed');
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
                return;
            }
            navigator.clipboard.writeText(summary).then(() => {
                setCopyButtonText('Copied!');
                playTone(880, 0.1, 'sine', 0.2); // Success sound
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                setCopyButtonText('Failed to copy');
                playTone(220, 0.2, 'square', 0.2); // Error sound
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
            });
        }, [summary]);

        return (
            <Modal onClose={onClose}>
                <div className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-3xl text-white flex flex-col overflow-x-hidden max-h-[90vh]" onClick={e => e.stopPropagation()}>
                    <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                        <h3 className="text-xl font-bold">Task Summary</h3>
                        <div className="flex items-center space-x-2">
                            <button onClick={handleCopy} title="Copy summary to your clipboard" className="px-3 py-1 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500 text-sm transition-all duration-150 w-36 text-center">{copyButtonText}</button>
                            <button onClick={onClose} title="Close this summary" className="px-4 py-1 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500 text-sm">Close</button>
                        </div>
                    </div>
                    <div className="p-4 overflow-y-auto"><pre className="text-sm text-slate-300 whitespace-pre-wrap font-mono bg-slate-900/50 p-4 rounded-md border border-slate-700">{summary}</pre></div>
                </div>
            </Modal>
        );
    };

    const ReleaseNotesModal = ({ version, onClose }) => {
        const [expandedVersions, setExpandedVersions] = useState({});
        const currentReleaseInfo = RELEASE_NOTES[version];
        // Get all other versions, sort them descending
        const previousVersionKeys = Object.keys(RELEASE_NOTES)
            .filter(v => v !== version)
            .sort((a, b) => b.localeCompare(a, undefined, { numeric: true }));

        if (!currentReleaseInfo) return null;

        const toggleVersion = (v) => setExpandedVersions(prev => ({ ...prev, [v]: !prev[v] }));

        return (
            <Modal onClose={onClose}>
                <div className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-2xl text-white flex flex-col max-h-[90vh]" onClick={e => e.stopPropagation()}>
                    <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                        <h3 className="text-xl font-bold">{currentReleaseInfo.title}</h3>
                        <button onClick={onClose} title="Close Release Notes" className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500 text-sm">Got it!</button>
                    </div>
                    <div className="p-6 overflow-y-auto space-y-4">
                        {currentReleaseInfo.notes.map((note, index) => (
                            <div key={index} className="bg-slate-900/50 p-4 rounded-lg border border-slate-700">
                                <h4 className="font-bold text-sky-300 mb-1">{note.title}</h4>
                                <p className="text-sm text-slate-300">{note.description}</p>
                            </div>
                        ))}
                        {previousVersionKeys.length > 0 && <div className="pt-4 border-t border-slate-700/50 space-y-2">
                            {previousVersionKeys.map(vKey => {
                                const release = RELEASE_NOTES[vKey];
                                return (
                                    <div key={vKey}>
                                        <button onClick={() => toggleVersion(vKey)} className="w-full flex justify-between items-center p-2 text-left rounded-md hover:bg-slate-700/50">
                                            <h4 className="text-md font-semibold text-slate-400">{release.title}</h4>
                                            <ChevronDownIcon className={`h-5 w-5 text-slate-400 transition-transform ${expandedVersions[vKey] ? 'rotate-180' : ''}`} />
                                        </button>
                                        {expandedVersions[vKey] && <div className="mt-2 space-y-3 pl-4 pr-2">
                                            {release.notes.map((note, index) => <p key={index} className="text-sm text-slate-400"><span className="font-semibold text-slate-300">{note.title}:</span> {note.description}</p>)}
                                        </div>}
                                    </div>
                                );
                            })}
                        </div>}
                    </div>
                </div>
            </Modal>
        );
    };

    // --- App Entry Point ---
    const AppContainer = () => {
        return <App />;
    };

    const TaikoApp = () => {
        return (
            <AppProvider>
                <AppContainer />
            </AppProvider>
        );
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<TaikoApp />);

    </script>

    <!-- Node Garden Background Animation Script -->
    <script>
        const canvas = document.getElementById('node-garden-canvas');
        const ctx = canvas.getContext('2d');

        // --- Default Animation Settings ---
        let animSettings = {
            enabled: true,
            particleCount: 350,
            connectionDistance: 200,
            particleSpeed: 0.3,
            mouseInteraction: true,
            clickPulse: true,
        };

        let particles = [];
        const mouse = { x: null, y: null, radius: 150 };
        let animationFrameId;
        let pulses = []; // Array to store active pulse waves

        // --- Animation Control based on screen size ---
        const isSmallScreen = () => window.innerWidth < 768;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            mouse.radius = isSmallScreen() ? (canvas.width / 15) + 20 : (canvas.width / 12) + 50; // Keep mouse radius update
        }

        let wasSmall = isSmallScreen();
        window.addEventListener('resize', () => {
            resizeCanvas();
            const isNowSmall = isSmallScreen();

            if (isNowSmall !== wasSmall) {
                if (isNowSmall) {
                    stopAnimation();
                } else if (animSettings.enabled) {
                    startAnimation();
                }
                wasSmall = isNowSmall;
            }
        });

        window.addEventListener('mousemove', (event) => {
            mouse.x = event.x;
            mouse.y = event.y;
        });

        window.addEventListener('mouseout', () => {
            mouse.x = null;
            mouse.y = null;
        });

        // Listen for clicks to create a pulse
        window.addEventListener('click', (event) => {
            if (!animSettings.enabled || !animSettings.clickPulse) return;
            pulses.push({
                x: event.clientX,
                y: event.clientY,
                radius: 0,
                maxRadius: Math.sqrt(canvas.width ** 2 + canvas.height ** 2), // Pulse expands to the full diagonal of the screen
                speed: 8,
            });
        });

        // Listen for settings changes from React
        window.addEventListener('animationSettingsChange', (event) => {
            const newSettings = event.detail;
            const oldEnabled = animSettings.enabled;

            // Check if particle speed changed to adjust velocity without a full reset
            if (newSettings.enabled && newSettings.particleSpeed !== animSettings.particleSpeed && animSettings.particleSpeed > 0) {
                const speedRatio = newSettings.particleSpeed / animSettings.particleSpeed;
                particles.forEach(p => {
                    p.vx *= speedRatio;
                    p.vy *= speedRatio;
                });
            }

            // Update the global animation settings object
            animSettings = { ...animSettings, ...newSettings };

            if (animSettings.enabled && !oldEnabled) {
                startAnimation(); // Start if it was just enabled
            } else if (!animSettings.enabled && oldEnabled) {
                stopAnimation(); // Stop if it was just disabled
            } else if (animSettings.enabled && newSettings.particleCount !== particles.length) {
                init(); // Re-initialize if particle count changes while enabled
            }
        });

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.baseSize = Math.random() * 1.5 + 0.5;
                this.size = this.baseSize;
                this.density = (Math.random() * 30) + 1;
                this.defaultColor = 'rgba(100, 116, 139, 0.8)'; // slate-500
                this.vx = (Math.random() - 0.5) * animSettings.particleSpeed; // Velocity X
                this.vy = (Math.random() - 0.5) * animSettings.particleSpeed; // Velocity Y
                // For pulsing effect
                this.pulseAngle = Math.random() * Math.PI * 2;
                this.pulseSpeed = 0.02 + Math.random() * 0.02;
            }

            draw() {
                ctx.fillStyle = this.currentColor || this.defaultColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }

            update() {
                // Autonomous movement and wall bouncing
                this.x += this.vx;
                this.y += this.vy;
                if (this.x <= 0 || this.x >= canvas.width) { this.vx *= -1; }
                if (this.y <= 0 || this.y >= canvas.height) { this.vy *= -1; }

                // Pulsing effect
                this.pulseAngle += this.pulseSpeed;
                this.size = this.baseSize + Math.sin(this.pulseAngle) * (this.baseSize * 0.5);

                // Mouse interaction - determine color
                this.currentColor = null; // Reset color
                if (animSettings.mouseInteraction && mouse.x !== null) {
                    let dx = mouse.x - this.x;
                    let dy = mouse.y - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    this.currentColor = getColorFromDistance(distance, mouse.radius);
                }

                // Pulse interaction - overrides mouse color
                for (let i = 0; i < pulses.length; i++) {
                    const pulse = pulses[i];
                    const dx = pulse.x - this.x;
                    const dy = pulse.y - this.y;
                    const distanceToPulseCenter = Math.sqrt(dx * dx + dy * dy);
                    const pulseWidth = 60; // How thick the ripple wave is

                    if (distanceToPulseCenter > pulse.radius - pulseWidth && distanceToPulseCenter < pulse.radius) {
                        // The particle is inside the ripple band
                        this.currentColor = `rgb(34, 197, 94)`; // A bright green color for the pulse
                    }
                }
            }
        }

        // Helper function to get color based on distance to mouse
        function getColorFromDistance(distance, maxDistance) {
            if (distance < maxDistance) {
                const normalizedDistance = distance / maxDistance; // 0 (closest) to 1 (farthest)
                let r, g, b;
                
                // Gradient: Red -> Yellow -> Green
                if (normalizedDistance < 0.5) {
                    // Interpolate from Red (239, 68, 68) to Yellow (251, 191, 36)
                    const t = normalizedDistance * 2; // Scale to 0-1 range
                    r = 239 + (251 - 239) * t;
                    g = 68 + (191 - 68) * t;
                    b = 68 + (36 - 68) * t;
                } else {
                    // Interpolate from Yellow (251, 191, 36) to Green (34, 197, 94)
                    const t = (normalizedDistance - 0.5) * 2; // Scale to 0-1 range
                    r = 251 + (34 - 251) * t;
                    g = 191 + (197 - 191) * t;
                    b = 36 + (94 - 36) * t;
                }
                return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
            }
            return null;
        }

        function init() {
            if (!animSettings.enabled) return;
            particles = [];
            for (let i = 0; i < animSettings.particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function animate() {
            if (!animSettings.enabled || isSmallScreen()) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update and draw pulses
            for (let i = pulses.length - 1; i >= 0; i--) {
                pulses[i].radius += pulses[i].speed;
                if (pulses[i].radius > pulses[i].maxRadius) {
                    pulses.splice(i, 1); // Remove pulse when it's done
                }
            }

            // Draw connecting lines
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < animSettings.connectionDistance) {
                        ctx.beginPath();
                        
                        let strokeStyle = `rgba(100, 116, 139, ${1 - distance / animSettings.connectionDistance})`;
                        
                        // Check for mouse interaction color
                        if (animSettings.mouseInteraction && mouse.x !== null) {
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            const mouseDx = mouse.x - midX;
                            const mouseDy = mouse.y - midY;
                            const midPointDistanceToMouse = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);
                            const lineColor = getColorFromDistance(midPointDistanceToMouse, mouse.radius);
                            
                            if (lineColor) {
                                // Extract the RGB part and add the alpha from the original style
                                const alpha = 1 - distance / animSettings.connectionDistance;
                                strokeStyle = lineColor.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                            }
                        }

                        // Check for pulse interaction on lines
                        for (let k = 0; k < pulses.length; k++) {
                            const pulse = pulses[k];
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            const dx = pulse.x - midX;
                            const dy = pulse.y - midY;
                            const distanceToPulseCenter = Math.sqrt(dx * dx + dy * dy);
                            if (distanceToPulseCenter > pulse.radius - 60 && distanceToPulseCenter < pulse.radius) {
                                const alpha = 1 - distance / animSettings.connectionDistance;
                                strokeStyle = `rgba(34, 197, 94, ${alpha * 1.5})`; // Make pulse lines slightly brighter
                            }
                        }

                        ctx.strokeStyle = strokeStyle;
                        ctx.lineWidth = 0.4;
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }

            // Update and draw each particle
            particles.forEach(p => { p.update(); p.draw(); });

            animationFrameId = requestAnimationFrame(animate);
        }

        function startAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            init();
            animate();
        }

        function stopAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            animationFrameId = null; // Explicitly clear the animation frame ID
        }

        resizeCanvas();
        startAnimation();
    </script>
</body>
</html> 