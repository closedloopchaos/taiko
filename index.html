<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taiko</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom CSS for animations and theming -->
    <style>
        body {
            font-family: sans-serif;
            background-color: #0f172a; /* Fallback background */
        }
        .transition-all {
            /* Use a smoother easing curve for all transitions */
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        }
        .pulse-border-high { animation: pulse-border-high 1.2s infinite; }
        @keyframes pulse-border-high { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(248, 113, 113, 0.9); } 
            50% { box-shadow: 0 0 0 6px rgba(248, 113, 113, 0); } 
        }
        .pulse-border-medium { animation: pulse-border-medium 1.8s infinite; }
        @keyframes pulse-border-medium { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.8); } 
            50% { box-shadow: 0 0 0 5px rgba(251, 191, 36, 0); } 
        }
        .pulse-border-low { animation: pulse-border-low 2.5s infinite; }
        @keyframes pulse-border-low { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.7); } 
            50% { box-shadow: 0 0 0 4px rgba(56, 189, 248, 0); } 
        }
        .pulse-border-default { animation: pulse-border-default 2s infinite; }
        @keyframes pulse-border-default { 
            0%, 100% { box-shadow: 0 0 0 0 rgba(100, 116, 139, 0.7); } /* slate-500 like for default pulse */
            50% { box-shadow: 0 0 0 5px rgba(100, 116, 139, 0); } 
        }
	:root {
	    --scrollbar-background: #273346;
            --scrollbar-thumb-background: #394b67;
            --scrollbar-thumb-border: #333;
            --scrollbar-track-background: #273346;
        }
        
        /* Style the scrollbar */
	::-webkit-scrollbar {
	    width: 8px;
	    height: 8px;
	}

        ::-webkit-scrollbar-thumb {
	    background-color: var(--scrollbar-thumb-background);
            border: 1px solid var(--scrollbar-thumb-border);
	    border-radius: 4px;
	}

	::-webkit-scrollbar-track {
	    background-color: var(--scrollbar-track-background);
	}

	::-webkit-scrollbar-corner {
	    background-color: var(--scrollbar-background);
	}

        #node-garden-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Places the canvas behind all other content */
        }
    </style>
</head>
<body>
    <canvas id="node-garden-canvas"></canvas>
    <div id="root"></div>

    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel Standalone for JSX Transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Main Application Logic -->
    <script type="text/babel">

    const { useState, useEffect, useRef, useCallback, createContext, useContext, useMemo } = React;


    // -----------------------------------------------------------------------------------------------------------------------------  THIS IS WHERE THE RELEASE NOTES ARE -----------------------------------------------------------------------------------------------------------------------------
    // --- Global Constants & Configurations ---
    const CURRENT_APP_VERSION = '1.3.0';

    const RELEASE_NOTES = {
        '1.0.0': {
            title: "Version 1.0.0",
            notes: [
                {
                    title: "🚀 Initial Launch",
                    description: "The first version of Taiko is here! A simple, clean, and effective task manager designed to help you focus."
                }
            ]
        },
        '1.2.0': {
            title: "Previous Version: 1.2.0",
            notes: [
                {
                    title: "✅ Core Task Management",
                    description: "Create, edit, and delete tasks. Set priorities (High, Medium, Low) and organize them into projects."
                },
                {
                    title: "⚙️ Project & Filter System",
                    description: "Filter tasks by project or priority to focus on what matters most. Manage projects with ease."
                },
                {
                    title: "✨ Interactive Background",
                    description: "Enjoy a dynamic, interactive particle animation in the background, with settings to customize the experience."
                }
            ]
        },
        '1.3.0': {
            title: "What's New in Version 1.3.0",
            notes: [
                {
                    title: "✨ New UI: Master-Detail Layout",
                    description: "The application has been redesigned with a master-detail layout. Browse a compact list of tasks on the left and see the full details of your selected task on the right."
                },
                {
                    title: "📂 New Feature: Project-Based Views",
                    description: "Click on any project header in the task list to view all tasks within that project together in the detail pane, making it easier to focus on specific workstreams."
                },
                {
                    title: "🎨 Redesigned Task Cards & Filters",
                    description: "Task cards have been updated for better clarity within the new layout, and the filtering UI has been streamlined into a single, easy-to-use dropdown menu."
                }
            ]
        }
    }; // Versions should be in ascending order for display logic


    const PRIORITIES = { // These are the internal constant values
        LOW: 'PRIORITY_LOW', // Actual tag string
        MEDIUM: 'PRIORITY_MEDIUM',
        HIGH: 'PRIORITY_HIGH'
    };

    const getPrioritySortValue = (priority) => {
        if (priority === PRIORITIES.HIGH) return 0;
        if (priority === PRIORITIES.MEDIUM) return 1;
        if (priority === PRIORITIES.LOW) return 2;
        return 3; // For null or undefined priority (Unprioritized)
    };

    // PRIORITY_CONFIG must be defined after PRIORITIES and before constants that use it.
    // We will add sound generation parameters here later if needed, or handle in the playSound function.
    const PRIORITY_CONFIG = {
        [PRIORITIES.LOW]: { title: "Low", color: "text-sky-400", bgColor: "bg-sky-500/20", borderColor: "border-sky-500", pulseClass: 'pulse-border-low' },
        [PRIORITIES.MEDIUM]: { title: "Medium", color: "text-yellow-400", bgColor: "bg-yellow-500/20", borderColor: "border-yellow-500", pulseClass: 'pulse-border-medium' },
        [PRIORITIES.HIGH]: { title: "High", color: "text-red-400", bgColor: "bg-red-500/20", borderColor: "border-red-500", pulseClass: 'pulse-border-high' },
        null: { title: "Unprioritized", color: "text-slate-400", bgColor: "bg-slate-500/10", borderColor: "border-slate-600", pulseClass: 'pulse-border-default' } // For null priority
    };

    const PRIORITY_TITLE_TO_CONSTANT_MAP = Object.fromEntries( // e.g., { "Low": "PRIORITY_LOW", ... }
        Object.values(PRIORITIES).map(pConstant => [PRIORITY_CONFIG[pConstant]?.title, pConstant]).filter(([title]) => title)
    ); // e.g., { "Low": "PRIORITY_LOW", ... }

    const TASK_STATUS = { TO_DO: 'To Do', DONE: 'Done' };
    const TIMEZONES = [
        { value: 'America/New_York', label: 'EST' },
        { value: 'America/Chicago', label: 'CST' },
        { value: 'America/Denver', label: 'MST' },
        { value: 'America/Los_Angeles', label: 'PST' },
        { value: 'UTC', label: 'UTC' },
    ];
    const TASK_STATUS_CONFIG = {
        [TASK_STATUS.TO_DO]: { 
            label: 'To Do', 
            selectBgColor: 'bg-sky-900/50', 
            accentClass: 'bg-sky-400',
            glowClass: 'shadow-[0_0_15px_-4px_rgba(56,189,248,0.5)] hover:shadow-[0_0_18px_-3px_rgba(56,189,248,0.7)]'
        },
        [TASK_STATUS.DONE]: { 
            label: 'Done', 
            selectBgColor: 'bg-green-900/50', 
            accentClass: 'bg-green-500',
            glowClass: 'shadow-[0_0_12px_-5px_rgba(34,197,94,0.5)]' // More subtle glow for "Done"
        }
    };

    // --- Web Audio API Sound Generation ---
    let audioContext = null;
    const getAudioContext = () => {
        if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        return audioContext;
    };

    const playTone = (frequency, duration = 0.5, type = 'sine', volume = 0.3) => {
        const actx = getAudioContext();
        if (!actx) {
            console.warn("Web Audio API is not supported in this browser.");
            return;
        }

        const oscillator = actx.createOscillator();
        const gainNode = actx.createGain();

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, actx.currentTime);
        gainNode.gain.setValueAtTime(volume, actx.currentTime);
        // Simple fade out to avoid clicking
        gainNode.gain.linearRampToValueAtTime(0.0001, actx.currentTime + duration - 0.05);

        oscillator.connect(gainNode);
        gainNode.connect(actx.destination);

        oscillator.start();
        oscillator.stop(actx.currentTime + duration);
    };

    // --- Context for State Management ---
    const AppContext = createContext(null);

    // --- Provider Component ---
    const AppProvider = ({ children }) => {
        // --- Core State ---
        const [tasks, setTasks] = useState([]);
        const [projectSettings, setProjectSettings] = useState({});
        const [settings, setSettings] = useState({ 
            confirmOnDelete: true, 
            animationSettings: { enabled: true, particleCount: 350, connectionDistance: 200, particleSpeed: 0.3, mouseInteraction: true, clickPulse: true }
        });

        // --- Modal-related State ---
        const [taskToDelete, setTaskToDelete] = useState(null);
        // --- UI Interaction State (lifted from App) ---
        const [selectedTaskId, setSelectedTaskId] = useState(null);
        const [activeTags, setActiveTags] = useState([]); // For filtering
        const [collapsedProjects, setCollapsedProjects] = useState({ 'Completed': true });

        const appId = 'taiko-app-local';

        // --- Local Storage Persistence ---
        useEffect(() => {
            const savedTasks = localStorage.getItem(`${appId}-tasks`);
            if (savedTasks) try { setTasks(JSON.parse(savedTasks)); } catch { console.error("Could not parse saved tasks."); }
            
            const defaultSettings = {
                confirmOnDelete: true,
                animationSettings: { enabled: true, particleCount: 350, connectionDistance: 200, particleSpeed: 0.3, mouseInteraction: true, clickPulse: true }
            };

            const savedSettings = localStorage.getItem(`${appId}-settings`);
            if (savedSettings) {
                try { 
                    const parsed = JSON.parse(savedSettings);
                    // Deep merge for animationSettings
                    const mergedSettings = {
                        ...defaultSettings, ...parsed,
                        animationSettings: { ...defaultSettings.animationSettings, ...(parsed.animationSettings || {}) }
                    };
                    setSettings(mergedSettings);
                } catch { 
                    console.error("Could not parse saved settings. Using defaults.");
                    setSettings(defaultSettings); // Fallback to defaults on parse error
                }
            } else {
                setSettings(defaultSettings); // No saved settings, use defaults
            }

            const savedActiveTags = localStorage.getItem(`${appId}-activeTags`);
            if (savedActiveTags) try { setActiveTags(JSON.parse(savedActiveTags)); } catch { console.error("Could not parse saved active tags."); setActiveTags([]); }

            const defaultCollapsedProjects = { 'Completed': true };
            const savedCollapsedProjects = localStorage.getItem(`${appId}-collapsedProjects`);
            if (savedCollapsedProjects) {
                try {
                    setCollapsedProjects(JSON.parse(savedCollapsedProjects));
                } catch {
                    setCollapsedProjects(defaultCollapsedProjects);
                }
            } else {
                setCollapsedProjects(defaultCollapsedProjects);
            }

            const savedProjectSettings = localStorage.getItem(`${appId}-projectSettings`);
            if (savedProjectSettings) try { setProjectSettings(JSON.parse(savedProjectSettings)); } catch { console.error("Could not parse saved project settings."); }
        }, [appId]); 
        useEffect(() => {
            const savedSelectedTask = localStorage.getItem(`${appId}-selectedTaskId`);
            if (savedSelectedTask) try { setSelectedTaskId(JSON.parse(savedSelectedTask)); } catch { console.error("Could not parse saved selected task."); setSelectedTaskId(null); }
        }, [appId]);

        // --- Consolidated Local Storage Persistence ---
        useEffect(() => {
            try {
                localStorage.setItem(`${appId}-tasks`, JSON.stringify(tasks));
                localStorage.setItem(`${appId}-settings`, JSON.stringify(settings));
                localStorage.setItem(`${appId}-projectSettings`, JSON.stringify(projectSettings));
                localStorage.setItem(`${appId}-activeTags`, JSON.stringify(activeTags));
                localStorage.setItem(`${appId}-collapsedProjects`, JSON.stringify(collapsedProjects));
                localStorage.setItem(`${appId}-selectedTaskId`, JSON.stringify(selectedTaskId));
            } catch (error) {
                console.error("Failed to save state to localStorage", error);
            }
        }, [tasks, settings, projectSettings, activeTags, collapsedProjects, selectedTaskId, appId]);

        // --- Effect to dispatch animation settings changes to the global scope ---
        useEffect(() => {
            const event = new CustomEvent('animationSettingsChange', { detail: settings.animationSettings });
            window.dispatchEvent(event);
        }, [settings.animationSettings]);

        // --- Effect to auto-collapse 'Completed' project when it becomes empty ---
        useEffect(() => {
            const completedCount = tasks.filter(task => task.status === TASK_STATUS.DONE).length;
            if (completedCount === 0) {
                if (collapsedProjects['Completed'] !== true) {
                    setCollapsedProjects(prev => ({ ...prev, 'Completed': true }));
                }
            }
        }, [tasks, collapsedProjects]); // Reruns when tasks change

        // When filters change, or tasks are deleted, make sure the selected task is still visible.
        useEffect(() => {
            if (selectedTaskId && !tasks.find(t => t.id === selectedTaskId)) {
                setSelectedTaskId(null);
            }
        }, [tasks, selectedTaskId]);


        // --- Core Data Actions ---
        const updateTask = useCallback((id, updatedFields) => {
            setTasks(prevTasks => prevTasks.map(task => 
                task.id === id ? { ...task, ...updatedFields, timestamp: new Date().toISOString() } : task
            ));
        }, []);
        
        const addTask = useCallback((initialTitle = 'New Task', initialProject = null, initialPriority = null) => {
            const newTask = {
                id: crypto.randomUUID(),
                title: initialTitle, 
                checklist: [],
                priority: initialPriority, 
                status: 'To Do',
                rank: tasks.filter(t => t.priority === initialPriority && !t.archived).length, // Rank will be based on the current priority value
                timestamp: new Date().toISOString(), 
                project: initialProject,
                notes: '', 
                reminderAt: null,
                reminderFired: false
            };
            setTasks(prevTasks => [newTask, ...prevTasks]);
            return newTask; // Return the new task so we can select it
        }, [tasks]); // tasks dependency is for rank calculation

        const deleteTask = useCallback((id) => {
            setTasks(prevTasks => prevTasks.filter(task => task.id !== id));
        }, []);

        const deleteAllCompletedTasks = useCallback(() => {
            setTasks(prevTasks => prevTasks.filter(task => task.status !== TASK_STATUS.DONE));
        }, []);

        const renameProject = useCallback((oldName, newName) => {
            if (!newName || oldName === newName) return;
            setTasks(prevTasks => 
                prevTasks.map(task => 
                    task.project === oldName ? { ...task, project: newName } : task
                )
            );
        }, []);

        const deleteProject = useCallback((projectName) => {
            setTasks(prevTasks => 
                prevTasks.map(task => 
                    task.project === projectName ? { ...task, project: null } : task
                )
            );
        }, []);

        const updateProjectSetting = useCallback((projectName, newSettings) => {
            setProjectSettings(prev => ({
                ...prev,
                [projectName]: {
                    ...(prev[projectName] || {}),
                    ...newSettings
                }
            }));
        }, []);
        const allTags = useMemo(() => {
            // This will now be allProjects
            const projectsSet = new Set();
            tasks.forEach(task => {
                if (task.project) {
                    projectsSet.add(task.project);
                }
            });
            return Array.from(projectsSet).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
        }, [tasks]);

        const toggleProjectCollapse = useCallback((projectName) => {
            setCollapsedProjects(prev => ({ ...prev, [projectName]: !prev[projectName] }));
        }, []);


        const contextValue = useMemo(() => ({
            tasks, updateTask, addTask, deleteTask, deleteAllCompletedTasks, renameProject, deleteProject, updateProjectSetting,
            settings, setSettings, allTags, projectSettings,
            taskToDelete, setTaskToDelete,
            activeTags, setActiveTags,
            selectedTaskId, setSelectedTaskId,
            collapsedProjects,
            toggleProjectCollapse
        }), [
            tasks, updateTask, addTask, deleteTask, deleteAllCompletedTasks, renameProject, deleteProject, updateProjectSetting,
            settings, setSettings, allTags, projectSettings,
            taskToDelete, setTaskToDelete,
            activeTags, setActiveTags, selectedTaskId,
            collapsedProjects, toggleProjectCollapse
        ]);
        
        return <AppContext.Provider value={contextValue}>{children}</AppContext.Provider>;
    };

    // --- Custom Hook to consume context ---
    const useAppContext = () => {
        const context = useContext(AppContext);
        if (context === null) throw new Error("useAppContext must be used within an AppProvider");
        return context;
    }

    // --- Helper Hooks ---
    const usePrevious = (value) => { const ref = useRef(); useEffect(() => { ref.current = value; }); return ref.current; };
    const useNow = (updateInterval = 1000) => { const [now, setNow] = useState(new Date()); useEffect(() => { const timerId = setInterval(() => setNow(new Date()), updateInterval); return () => clearInterval(timerId); }, [updateInterval]); return now; };
    const useWindowWidth = () => {
        const [width, setWidth] = useState(window.innerWidth);
        useEffect(() => {
            const handleResize = () => setWidth(window.innerWidth);
            window.addEventListener('resize', handleResize);
            return () => window.removeEventListener('resize', handleResize);
        }, []);
        return width;
    };

    // --- Helper Function for Time Parsing (MM:SS or SS duration) ---
    const parseHHMMSSDuration = (inputStr) => {
        if (!inputStr || typeof inputStr !== 'string') return null;

        const parts = inputStr.split(':').map(p => p.trim());
        
        let h = 0, m = 0, s = 0;
        let parsedSuccessfully = false;

        if (parts.length === 1) {
            const val = parseInt(parts[0], 10);
            if (!isNaN(val) && String(val) === parts[0]) { // Ensure clean integer parse
                s = val;
                parsedSuccessfully = true;
            }
        } else if (parts.length === 2) {
            const valM = parseInt(parts[0], 10);
            const valS = parseInt(parts[1], 10);
            if (!isNaN(valM) && String(valM) === parts[0] &&
                !isNaN(valS) && String(valS) === parts[1]) {
                m = valM;
                s = valS;
                parsedSuccessfully = true;
            }
        }

        if (!parsedSuccessfully) return null;

        // Normalize seconds to minutes, and minutes to hours (though hours are not directly input)
        if (s >= 60) { m += Math.floor(s / 60); s %= 60; }
        // h will remain 0 if not explicitly set, which is fine for MM:SS or SS input.
        if (m >= 60) { h += Math.floor(m / 60); m %= 60; }

        const totalSeconds = h * 3600 + m * 60 + s;
        return totalSeconds > 0 ? totalSeconds : null;
    };
    const DISPLAY_PRIORITY_ORDER = [PRIORITIES.LOW, PRIORITIES.MEDIUM, PRIORITIES.HIGH]; // For UI column display

    // --- Icon Components (Memoized) ---
    const DeleteIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>);
    const BellIcon = React.memo(({ className }) => <svg xmlns="http://www.w3.org/2000/svg" className={`h-4 w-4 ${className || ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6 6 0 10-12 0v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" /></svg>);
    const ChevronDownIcon = React.memo(({ className }) => (
        <svg 
            xmlns="http://www.w3.org/2000/svg" 
            className={`h-5 w-5 ${className || ''}`} 
            viewBox="0 0 20 20" 
            fill="currentColor"
        >
            <path fillRule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clipRule="evenodd" />
        </svg>
    ));
    const SettingsIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.096 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>);
    const BugIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" strokeWidth="2" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" d="M15.362 5.214A8.252 8.252 0 0112 21 8.25 8.25 0 016.038 7.048 8.287 8.287 0 009 9.6a8.983 8.983 0 013.361-6.867 8.21 8.21 0 003 2.48z" />
            <path strokeLinecap="round" strokeLinejoin="round" d="M12 18a3.75 3.75 0 00.495-7.467 5.99 5.99 0 00-1.925 3.546 5.974 5.974 0 01-2.133-1A3.75 3.75 0 0012 18z" />
        </svg>
    ));
    const DocumentTextIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
        </svg>
    ));
    const NoteIcon = React.memo(({ hasNote, className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" className={`h-4 w-4 ${className || ''}`} fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            {hasNote ? <path strokeLinecap="round" strokeLinejoin="round" d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" /> : <path strokeLinecap="round" strokeLinejoin="round" d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z" />}
        </svg>
    ));
    const FolderIcon = React.memo(() => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
        </svg>
    ));
    const CheckIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={3}><path strokeLinecap="round" strokeLinejoin="round" d="M5 13l4 4L19 7" /></svg>);
    const PlusIcon = React.memo(() => <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>);
    const TaikoLogo = React.memo(() => <svg width="52" height="52" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" className="text-white"><g stroke="currentColor" strokeWidth="4" fill="none" strokeLinecap="round" strokeLinejoin="round"><path d="M 25,30 C 25,10 75,10 75,30 V 70 C 75,90 25,90 25,70 Z" fill="rgba(255,255,255,0.1)"/><path d="M 75,30 C 90,30 90,70 75,70" /><path d="M 25,30 C 10,30 10,70 25,70" /><circle cx="50" cy="50" r="28" strokeWidth="3"/><circle cx="50" cy="50" r="8" fill="currentColor"/></g></svg>);

    // --- Time & Countdown Components (Memoized) ---
    const LiveClock = React.memo(({ timezone, onTimezoneChange }) => {
        const time = useNow();
        const formattedTime = time.toLocaleTimeString('en-US', { timeZone: timezone, hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
        const currentLabel = TIMEZONES.find(tz => tz.value === timezone)?.label || timezone;
        
        return (
            <div className="flex flex-row items-baseline space-x-2 text-slate-300">
                <span className="text-2xl md:text-4xl font-mono tracking-wider">{formattedTime}</span>
                <select value={timezone} onChange={e => onTimezoneChange(e.target.value)} title="Change timezone" className="text-lg md:text-2xl font-mono text-slate-500 hover:text-slate-300 transition-colors bg-transparent border-none focus:ring-0 cursor-pointer appearance-none pr-2">
                    {TIMEZONES.map(tz => (
                        <option key={tz.value} value={tz.value} className="bg-slate-800 text-white">{tz.label}</option>
                    ))}
                </select>
            </div>
        );
    });

    const TimeElapsed = React.memo(({ startTime, totalElapsedSeconds }) => {
        const [elapsed, setElapsed] = useState('00:00:00');
        const animationFrameRef = useRef();
        const formatTime = useCallback((s) => new Date(s * 1000).toISOString().substr(11, 8), []);

        useEffect(() => {
            let isMounted = true;
            const animate = () => {
                if (!startTime || !isMounted) return;
                const currentSessionSeconds = (new Date().getTime() - new Date(startTime).getTime()) / 1000;
                setElapsed(formatTime((totalElapsedSeconds || 0) + currentSessionSeconds));
                animationFrameRef.current = requestAnimationFrame(animate);
            };
            if (startTime) animate();
            else setElapsed(formatTime(totalElapsedSeconds || 0));
            return () => { isMounted = false; cancelAnimationFrame(animationFrameRef.current); };
        }, [startTime, totalElapsedSeconds, formatTime]);
        
        return <span className="text-xs font-mono bg-slate-700/50 text-amber-300 px-2 py-1 rounded">{elapsed}</span>;
    });

    // --- Reminder Countdown Component (Memoized) ---
    const ReminderCountdown = React.memo(({ reminderAt }) => {
        const [countdown, setCountdown] = useState('');
        const now = useNow(); // Use the existing useNow hook
    
        const formatCountdown = useCallback((ms) => {
            if (ms <= 0) return 'Due!'; // Or '00:00:00' if you prefer
            const totalSeconds = Math.max(0, Math.floor(ms / 1000));
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }, []);

        useEffect(() => {
            if (!reminderAt) { setCountdown(''); return; }
            const remainingMs = new Date(reminderAt).getTime() - now.getTime();
            setCountdown(formatCountdown(remainingMs));
        }, [reminderAt, now, formatCountdown]);

        if (!reminderAt || countdown === '') return null;
        return <div className="text-xs text-cyan-300 font-mono">Countdown: {countdown}</div>;
    });

    // --- UI Components ---
    const ChecklistItem = React.memo(({ 
        item, 
        onUpdate, // Now also receives completedAt
        onDelete, 
        onAddNewItemAfter, 
        isFocused, 
        onFocusHandled, 
        isLocked, 
        onDropItem, 
        onDragEndItem,
        clockTimezone // Added for displaying subtask completion time
    }) => {
        const inputRef = useRef(null);
        const [isDragOver, setIsDragOver] = useState(false); // Local state for drag over visual feedback
        const [text, setText] = useState(item.text); // Local state for the input text

        const handleDragStart = (e) => {
            e.stopPropagation(); // Prevent parent elements from also being dragged
            e.dataTransfer.setData('text/plain', item.id); // Set the ID of the dragged item
            e.dataTransfer.effectAllowed = 'move';
        };

        const handleDragOver = (e) => {
            e.preventDefault(); // Necessary to allow dropping
            e.dataTransfer.dropEffect = 'move';
        };

        const handleDragEnter = (e) => {
            e.preventDefault();
            setIsDragOver(true);
        };

        useEffect(() => {
            if (isFocused && inputRef.current) {
                inputRef.current.focus();
                onFocusHandled(); // Important to prevent re-focusing on every render
            }
        }, [isFocused, onFocusHandled]);

        // Sync local state if the prop changes from outside
        useEffect(() => {
            setText(item.text);
        }, [item.text]);

        const handleBlur = () => {
            if (text !== item.text) { // Only update if there's a change
                onUpdate(item.id, { text });
            }
        };

        const handleKeyDown = (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleBlur(); // Save changes on Enter
                onAddNewItemAfter(item.id);
            }
        };
        
        const handleDragLeave = () => {
            setIsDragOver(false);
        };

        const handleDrop = (e) => {
            e.preventDefault();
            setIsDragOver(false);
            const draggedId = e.dataTransfer.getData('text/plain');
            if (draggedId && draggedId !== item.id) {
                onDropItem(draggedId, item.id); // Notify parent TaskCard to reorder
            }
        };

        const handleDragEnd = () => {
            setIsDragOver(false);
            onDragEndItem(); // Notify parent TaskCard that drag has ended
        };

        return ( // Only draggable if not locked
            <li 
                draggable={!isLocked} 
                onDragStart={handleDragStart}
                onDragOver={handleDragOver}
                onDragEnter={handleDragEnter}
                onDragLeave={handleDragLeave}
                onDrop={handleDrop}
                onDragEnd={handleDragEnd}
                className={`flex items-center space-x-2 group p-1 rounded-md transition-all ${isDragOver ? 'bg-sky-700/30 border border-sky-500' : ''} ${isLocked ? 'cursor-default' : 'cursor-grab'}`}
            >
                <input 
                    type="checkbox" 
                    checked={item.completed} 
                    onChange={(e) => {
                        const isCompleted = e.target.checked;
                        onUpdate(item.id, { completed: isCompleted, completedAt: isCompleted ? new Date().toISOString() : null });
                    }} disabled={isLocked} className="form-checkbox h-4 w-4 rounded bg-slate-700 border-slate-500 text-sky-500 focus:ring-sky-500 cursor-pointer disabled:cursor-not-allowed disabled:opacity-50" />
                <input 
                    ref={inputRef}
                    type="text" 
                    value={text} 
                    onChange={e => setText(e.target.value)} 
                    onKeyDown={handleKeyDown}
                    onBlur={handleBlur}
                    readOnly={isLocked}
                    className={`flex-grow min-w-0 bg-transparent text-sm p-1 rounded-md transition-colors ${item.completed ? 'text-slate-500 line-through' : 'text-slate-300'} focus:bg-slate-700 read-only:cursor-default`} 
                />
                {item.completed && item.completedAt && (
                    <span className="text-xs text-slate-500 ml-2 whitespace-nowrap">
                        ({new Date(item.completedAt).toLocaleString('en-US', {
                            timeZone: clockTimezone,
                            month: 'numeric', day: 'numeric', year: 'numeric',
                            hour: '2-digit', minute: '2-digit'
                        })})
                    </span>
                )}

                <button onClick={() => onDelete(item.id)} title="Delete item" disabled={isLocked} className="text-slate-500 hover:text-red-400 opacity-0 group-hover:opacity-100 transition-opacity disabled:hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </li>
        );
    });

    // --- Task Card Component ---
    const TaskCard = ({ task, clockTimezone }) => {
        const { updateTask, deleteTask, allTags, settings, setTaskToDelete, activeTags } = useAppContext();
        const now = useNow();
        const isLocked = task.status === TASK_STATUS.DONE;
        const [isEditingTitle, setIsEditingTitle] = useState(false); // To be wrapped
        const [title, setTitle] = useState(task.title);
        const [checklist, setChecklist] = useState(task.checklist || []);
        // State for task notes
        const [notes, setNotes] = useState(task.notes || '');
        // State to manage which checklist item should be focused
        const [focusedItemId, setFocusedItemId] = useState(null);
        const draggedChecklistItemId = useRef(null); // Use ref to avoid re-renders during drag
        const notesTextareaRef = useRef(null); // Ref for the notes textarea
        const [isChecklistExpanded, setIsChecklistExpanded] = useState(false);
        
        useEffect(() => { setChecklist(task.checklist || []); }, [task.checklist]);
        useEffect(() => { setTitle(task.title); }, [task.title]);
        useEffect(() => { setNotes(task.notes || ''); }, [task.notes]); // Sync notes state with prop

        // Effect to auto-resize the notes textarea
        useEffect(() => {
            if (notesTextareaRef.current) {
                const textarea = notesTextareaRef.current;
                textarea.style.height = 'auto'; // Reset height to allow shrinking
                textarea.style.height = `${textarea.scrollHeight}px`; // Set to content height
            }
        }, [notes]); // Rerun on content change

        const handleDeleteRequest = useCallback(() => {
            if (settings.confirmOnDelete) {
                setTaskToDelete(task.id); // Corrected: Should set the task ID
            } else {
                deleteTask(task.id);
            }
        }, [task.id, settings.confirmOnDelete, deleteTask, setTaskToDelete]);
        const handleUpdateChecklist = useCallback((updatedList) => {
            // Checklist updates no longer automatically change task status.
            // Status is now manually set via the dropdown.
            updateTask(task.id, { checklist: updatedList });
        }, [task.id, updateTask]);
        
        const handleItemUpdate = (id, values) => handleUpdateChecklist(checklist.map(i => i.id === id ? { ...i, ...values } : i));
        const handleItemDelete = (id) => handleUpdateChecklist(checklist.filter(i => i.id !== id));
        const handleAddItem = () => {
            const newId = crypto.randomUUID();
            setFocusedItemId(newId); // Set the new item to be focused
            handleUpdateChecklist([...checklist, { id: newId, text: '', completed: false }]);
        };
        const handleAddNewItemAfter = useCallback((currentItemId) => {
            const newId = crypto.randomUUID();
            setFocusedItemId(newId); // Set the ID of the new item to be focused
            const currentIndex = checklist.findIndex(i => i.id === currentItemId);
            const newChecklist = [...checklist];
            // Insert the new item right after the current one
            newChecklist.splice(currentIndex + 1, 0, { id: newId, text: '', completed: false });
            handleUpdateChecklist(newChecklist);
        }, [checklist, handleUpdateChecklist]);
        const handleTitleBlur = () => { setIsEditingTitle(false); if (title !== task.title) updateTask(task.id, { title }); };
        const handleTitleKeyDown = (e) => { if (e.key === 'Enter') { e.preventDefault(); handleTitleBlur(); } };
        
        const handleSetPriority = (priorityToSet) => {
            // If the clicked priority is the same as the current one, clear it. Otherwise, set it.
            const newPriority = task.priority === priorityToSet ? null : priorityToSet;
            updateTask(task.id, { priority: newPriority });
        };

        const handleCompletionToggle = () => {
            const isCurrentlyDone = task.status === TASK_STATUS.DONE;
            if (isCurrentlyDone) {
                updateTask(task.id, { status: TASK_STATUS.TO_DO });
            } else {
                updateTask(task.id, { status: TASK_STATUS.DONE, reminderAt: null, reminderFired: false });
            }
        };
        
        // Drag and Drop Handlers for Checklist Items
        const handleDropChecklistItem = useCallback((draggedId, targetId) => {
            const draggedIndex = checklist.findIndex(item => item.id === draggedId);
            const targetIndex = checklist.findIndex(item => item.id === targetId);

            if (draggedIndex === -1 || targetIndex === -1) return;

            const newChecklist = [...checklist];
            const [draggedItem] = newChecklist.splice(draggedIndex, 1);
            newChecklist.splice(targetIndex, 0, draggedItem);

            handleUpdateChecklist(newChecklist);
        }, [checklist, handleUpdateChecklist]);

        const handleDragEndChecklistItem = useCallback(() => { draggedChecklistItemId.current = null; }, []);

        // Pulse should continue as long as the reminder time has passed,
        // regardless of whether the notification itself has fired.
        const reminderIsDue = task.reminderAt && new Date(task.reminderAt) <= now;
        const pulseClass = reminderIsDue ? (PRIORITY_CONFIG[task.priority]?.pulseClass || '') : '';
        
        const cardPadding = 'p-3';
        const titleFontSize = ''; // Default is text-lg from h3
        const textSize = 'text-sm';
        
        return (
            <div className={`w-full min-w-0 bg-slate-800/80 backdrop-blur-xl border border-slate-700/50 rounded-xl shadow-lg transition-shadow duration-300 ${pulseClass} ${TASK_STATUS_CONFIG[task.status]?.glowClass || ''} ${isLocked ? 'opacity-60' : ''}`}>
                {/* --- Header: Project, Title, Priority --- */}
                <div className="px-4 pt-4 pb-3 border-b border-slate-700/50">
                    <div className="flex justify-between items-center mb-1">
                        {/* Task Title */}
                        <div className="flex-grow min-w-0 mr-4">
                            {isEditingTitle ? (
                                <input type="text" value={title} onChange={e => setTitle(e.target.value)} onBlur={handleTitleBlur} onKeyDown={handleTitleKeyDown} autoFocus className={`w-full bg-slate-900/50 rounded-md py-1 text-slate-50 font-semibold text-lg border border-slate-600 focus:ring-2 focus:ring-sky-500`} />
                            ) : (
                                <h3 onDoubleClick={isLocked ? undefined : () => setIsEditingTitle(true)} title={isLocked ? "Task is completed" : "Double-click to edit title"} className={`font-semibold text-slate-50 break-words text-lg ${isLocked ? 'cursor-default line-through text-slate-500' : 'cursor-pointer'}`}>{task.title}</h3>
                            )}
                        </div>

                        {/* Priority Dots */}
                        <div className="flex items-center space-x-2 flex-shrink-0">
                            <span className="text-xs text-slate-400">Priority:</span>
                            {DISPLAY_PRIORITY_ORDER.map(pConst => {
                                const config = PRIORITY_CONFIG[pConst];
                                const isSelected = task.priority === pConst;
                                return (
                                    <button
                                        key={pConst}
                                        title={`Set priority: ${config.title}`}
                                        onClick={() => handleSetPriority(pConst)}
                                        disabled={isLocked}
                                        className={`w-3 h-3 rounded-full transition-all duration-150 ${isSelected ? `ring-2 ring-offset-2 ring-offset-slate-800 ${config.color.replace('text-', 'ring-')}` : 'opacity-50 hover:opacity-100'} ${config.color.replace('text-', 'bg-')}`}
                                    ></button>
                                );
                            })}
                        </div>
                    </div>
                </div>

                <div className="px-4 pb-3 space-y-3">
                    {/* --- Notes Section --- */}
                    <div className="bg-slate-900/40 p-3 rounded-lg border border-slate-700/50">
                        <h4 className="text-xs font-semibold text-slate-400 mb-1 uppercase tracking-wider">Notes</h4>
                        <textarea
                            ref={notesTextareaRef}
                            value={notes}
                            onChange={e => setNotes(e.target.value)}
                            onBlur={() => updateTask(task.id, { notes })}
                            placeholder="Notes..."
                            disabled={isLocked}
                            className={`w-full bg-transparent text-slate-300 p-1 rounded-md border border-transparent focus:bg-slate-900/80 focus:border-slate-600 focus:ring-0 resize-none overflow-hidden ${textSize} placeholder-slate-500 disabled:cursor-not-allowed`}
                        ></textarea>
                    </div>

                    {/* --- Checklist Section --- */}
                    {(checklist.length > 0 || !isLocked) && (
                        <div className="bg-slate-900/40 rounded-lg border border-slate-700/50">
                            <button onClick={() => setIsChecklistExpanded(p => !p)} className="w-full flex justify-between items-center p-3 text-left">
                                <h4 className="text-xs font-semibold text-slate-400 uppercase tracking-wider">Checklist ({checklist.length})</h4>
                                <ChevronDownIcon className={`h-5 w-5 text-slate-400 transition-transform ${isChecklistExpanded ? 'rotate-180' : ''}`} />
                            </button>
                            {isChecklistExpanded && <div className="p-3 pt-0 space-y-1">
                                <ul className="space-y-1">{checklist.map(item => 
                                    <ChecklistItem 
                                        key={item.id} 
                                        item={item} 
                                        onUpdate={handleItemUpdate} 
                                        onDelete={handleItemDelete} 
                                        onAddNewItemAfter={handleAddNewItemAfter}
                                        isFocused={focusedItemId === item.id}
                                        onFocusHandled={() => setFocusedItemId(null)}
                                        isLocked={isLocked}
                                        clockTimezone={clockTimezone}
                                        onDropItem={handleDropChecklistItem}
                                        onDragEndItem={handleDragEndChecklistItem}
                                    />
                                )}</ul>
                                <button onClick={handleAddItem} title="Add a new checklist item" disabled={isLocked} className={`w-full text-left text-sky-400 hover:text-sky-300 p-1 rounded-md hover:bg-slate-700/50 disabled:text-slate-500 disabled:cursor-not-allowed disabled:hover:bg-transparent ${textSize}`}>+ Add item</button>
                            </div>}
                        </div>
                    )}
                    
                    {task.reminderAt && (
                        <div className="pt-2 text-xs">
                            <div className="text-sky-300 flex justify-between items-center mb-0.5">
                                <span>
                                    Set for: {new Date(task.reminderAt).toLocaleTimeString([], {
                                        timeZone: clockTimezone,
                                        hour: '2-digit', minute:'2-digit', second: '2-digit'
                                    })} {clockTimezone}
                                </span>
                                <button onClick={() => updateTask(task.id, { reminderAt: null, reminderFired: false })} title="Clear reminder" className="text-red-400 hover:text-red-300 text-xs">(clear)</button>
                            </div>
                            <ReminderCountdown reminderAt={task.reminderAt} />
                        </div>
                    )}
                    <div className="pt-3 border-t border-slate-700/50 flex justify-between items-center">
                        <select 
                            value={task.project || ''} 
                            onChange={(e) => updateTask(task.id, { project: e.target.value || null })}
                            disabled={isLocked}
                            className="text-sm bg-slate-800 text-slate-200 px-2 py-1 rounded-md border border-slate-600 hover:bg-slate-700 focus:ring-2 focus:ring-sky-500 focus:border-sky-500 disabled:cursor-not-allowed disabled:opacity-70"
                        >
                            <option value="">Unassigned</option>
                            {allTags.map(project => (
                                <option key={project} value={project}>{project}</option>
                            ))}
                        </select>
                        <div className="flex items-center space-x-2">
                            <button 
                                onClick={handleCompletionToggle} 
                                title={isLocked ? "Mark as 'To Do'" : "Mark as 'Done'"} 
                                className={`p-1 rounded-full transition-colors ${isLocked ? 'bg-green-500 text-white' : 'text-slate-400 hover:text-green-400 hover:bg-green-500/20'}`}
                            >
                                <CheckIcon />
                            </button>
                            <button onClick={handleDeleteRequest} title="Delete Permanently" className="text-red-400 hover:text-white transition-colors p-1 rounded-full hover:bg-red-500"><DeleteIcon /></button>
                        </div>
                    </div>
                </div>
            </div>
        );
    };
    const MemoizedTaskCard = React.memo(TaskCard);

    // --- New Components for Master-Detail Layout ---
    const TaskListItem = React.memo(({ task, isSelected, onSelect }) => {
        const priorityConfig = PRIORITY_CONFIG[task.priority] || PRIORITY_CONFIG.null;
        const isDone = task.status === TASK_STATUS.DONE;

        return (
            <button
                onClick={() => onSelect(task.id)}
                className={`w-full text-left p-3 rounded-lg border transition-all duration-150 ${isSelected ? 'bg-sky-500/30 border-sky-400 shadow-lg' : 'bg-slate-800/50 border-slate-700 hover:bg-slate-700/50 hover:border-slate-500'}`}
            >
                <div className="flex justify-between items-start gap-2">
                    <p className={`flex-grow font-semibold break-words ${isDone ? 'line-through text-slate-500' : 'text-slate-100'}`}>
                        {task.title}
                    </p>
                    <span className={`text-xs font-bold px-2 py-0.5 rounded-full border ${priorityConfig.color} ${priorityConfig.bgColor} ${priorityConfig.borderColor} flex-shrink-0`}>
                        {priorityConfig.title}
                    </span>
                </div>
            </button>
        );
    });

    const TaskList = React.memo(({ tasks, selectedTaskId, onSelectTask, clockTimezone, onProjectHeaderClick, selectedProjectName, onShowDeleteAllModal, completedTasksCount, onAddTask }) => {
        const { projectSettings, collapsedProjects, toggleProjectCollapse } = useAppContext();
        const groupedAndSortedTasks = useMemo(() => { // This logic is correct, no changes needed here.
            // Manual sorting by rank is now the primary method.
            const activeTaskSorter = (a, b) => {
                const priorityA = getPrioritySortValue(a.priority);
                const priorityB = getPrioritySortValue(b.priority);
                if (priorityA !== priorityB) return priorityA - priorityB;
                return a.title.localeCompare(b.title);
            };
            const completedTaskSorter = (a, b) => new Date(b.timestamp) - new Date(a.timestamp);

            const grouped = tasks.reduce((acc, task) => {
                // Ensure 'Completed' group always exists
                if (!acc['Completed']) {
                    acc['Completed'] = [];
                }
                const key = task.status === TASK_STATUS.DONE ? 'Completed' : (task.project || 'Unassigned');
                if (!acc[key]) acc[key] = [];
                acc[key].push(task);
                return acc;
            }, {});

            // Sort tasks within each group
            for (const projectName in grouped) {
                if (projectName === 'Completed') {
                    grouped[projectName].sort(completedTaskSorter);
                } else {
                    grouped[projectName].sort(activeTaskSorter);
                }
            }

            // Sort the project groups themselves, keeping 'Completed' at the bottom
            return Object.entries(grouped).sort(([a], [b]) => {
                if (a === 'Completed') return 1;
                if (b === 'Completed') return -1;
                return a.localeCompare(b);
            });
        }, [tasks]);

        return (
            <div className="space-y-4">
                {groupedAndSortedTasks.map(([projectName, tasksInGroup]) => {
                    const isCollapsed = collapsedProjects[projectName];
                    const settings = projectSettings[projectName] || {};
                    const fallbackColors = ['bg-red-900/20', 'bg-yellow-900/20', 'bg-green-900/20', 'bg-blue-900/20', 'bg-indigo-900/20', 'bg-purple-900/20', 'bg-pink-900/20', 'bg-slate-900/20'];
                    const projectHash = projectName.split('').reduce((acc, char) => char.charCodeAt(0) + ((acc << 5) - acc), 0);
                    const fallbackColor = fallbackColors[Math.abs(projectHash % fallbackColors.length)];
                    const style = settings.color ? { backgroundColor: settings.color } : {};
                    const bgColorClass = settings.color ? '' : fallbackColor;

                    return (
                        <div key={projectName} className={`${bgColorClass} border rounded-lg backdrop-blur-sm transition-all duration-300 ${selectedProjectName === projectName ? 'border-sky-400' : 'border-slate-700/40'} ${projectName === 'Completed' ? 'border-green-700/60' : ''}`} style={style}>
                            <div className={`flex items-center justify-between w-full text-left text-sm font-bold uppercase tracking-wider pl-2 pr-4 pt-3 pb-2 border-b border-indigo-800/50 transition-colors`}>
                                <button onClick={() => toggleProjectCollapse(projectName)} title={isCollapsed ? 'Expand project' : 'Collapse project'} className="p-2 rounded-full hover:bg-slate-700/50 text-indigo-300 flex-shrink-0">
                                    <ChevronDownIcon className={`h-4 w-4 transition-transform duration-200 ${isCollapsed ? '-rotate-90' : ''}`} />
                                </button>
                                <div onClick={() => onProjectHeaderClick(projectName)} className="flex-grow cursor-pointer hover:bg-white/5 p-2 rounded-md">
                                    <span className="text-indigo-300 hover:underline">{projectName} ({tasksInGroup.length})</span>
                                </div>
                                {projectName !== 'Completed' && <button onClick={() => onAddTask(projectName)} title={`Add task to ${projectName}`} className="p-1 text-sky-300 hover:text-white rounded-full hover:bg-sky-500/30 transition-colors flex-shrink-0 mx-2"><PlusIcon /></button>}
                                {projectName === 'Completed' && (
                                    <button onClick={onShowDeleteAllModal} title="Delete All Completed Tasks" className="p-1 text-red-400 hover:text-white rounded-full hover:bg-red-500/30 transition-colors flex-shrink-0 disabled:opacity-50 disabled:cursor-not-allowed" disabled={completedTasksCount === 0}>
                                        <DeleteIcon />
                                    </button>
                                )}
                            </div>
                            {!isCollapsed && (
                                <div className="space-y-2 p-3">
                                    {tasksInGroup.map(task => <TaskListItem key={task.id} task={task} isSelected={selectedTaskId === task.id} onSelect={onSelectTask} />)}
                                </div>
                            )}
                        </div>
                    );
                })}
            </div>
        );
    });

    // --- Main Presentation Component ---
    const App = () => {
        const { 
            tasks, addTask,
            settings, setSettings,
            taskToDelete, setTaskToDelete, deleteAllCompletedTasks,
            allTags, deleteTask, updateTask, // Core data functions
            activeTags, setActiveTags,                     // Filter state (now just for projects/priorities)
            selectedTaskId, setSelectedTaskId,             // Detail view state,
            collapsedProjects, toggleProjectCollapse
        } = useAppContext();

        const now = useNow(); // Get current time, updates every second

        const [showSettings, setShowSettings] = useState(false);
        const [clockTimezone, setClockTimezone] = useState('America/New_York');

        // State for the summary modal
        const [showSummaryModal, setShowSummaryModal] = useState(false);
        const [summaryText, setSummaryText] = useState('');
        const [showDeleteAllCompletedModal, setShowDeleteAllCompletedModal] = useState(false);
        const [showNewProjectModal, setShowNewProjectModal] = useState(false);
        const [showReleaseNotesModal, setShowReleaseNotesModal] = useState(false);
        const [selectedProjectName, setSelectedProjectName] = useState(null);
        const windowWidth = useWindowWidth();
        // --- Effect for showing release notes once per version ---

        useEffect(() => {
            const lastSeenVersion = localStorage.getItem('taiko-app-local-lastSeenVersion');
            if (lastSeenVersion !== CURRENT_APP_VERSION) {
                setShowReleaseNotesModal(true);
            }
        }, []); // Run only once on mount

        // --- Responsive State ---
        const isSmallScreen = windowWidth < 768; // Tailwind's `md` breakpoint
        const showDetailViewOnMobile = isSmallScreen && (selectedTaskId || selectedProjectName);
        const showListViewOnMobile = isSmallScreen && !showDetailViewOnMobile;


        const handleCloseReleaseNotes = () => {
            setShowReleaseNotesModal(false);
            localStorage.setItem('taiko-app-local-lastSeenVersion', CURRENT_APP_VERSION);
        };

        // --- Effect for Global Keyboard Shortcuts ---
        useEffect(() => {
            const handleKeyDown = (e) => {
                // Use 'a' key to open Add Task modal. Avoid when typing in an input.
                if (e.key.toLowerCase() === 'a' && !['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                    e.preventDefault();
                    setShowAddTaskModal(true);
                }
            };

            window.addEventListener('keydown', handleKeyDown);
            return () => {
                window.removeEventListener('keydown', handleKeyDown);
            };
        }, []); // Empty dependency array ensures this runs only once

        const activeTasksCount = useMemo(() => tasks.filter(t => t.status !== TASK_STATUS.DONE).length, [tasks]);

        const completedTasksCount = useMemo(() => tasks.filter(t => t.status === TASK_STATUS.DONE).length, [tasks]);

        const priorityFilterCounts = useMemo(() => {
            const counts = {};
            DISPLAY_PRIORITY_ORDER.forEach(priorityConstant => {
                const displayTitle = PRIORITY_CONFIG[priorityConstant].title;
                counts[displayTitle] = tasks.filter(task => task.status !== TASK_STATUS.DONE && task.priority === priorityConstant).length;
            });
            return counts;
        }, [tasks]); // DISPLAY_PRIORITY_ORDER and PRIORITY_CONFIG are stable constants

        const customTagFilterCounts = useMemo(() => {
            const counts = {};
            const activeTasks = tasks.filter(t => t.status !== TASK_STATUS.DONE);
            allTags.forEach(project => {
                counts[project] = activeTasks.filter(task => task.project === project).length;
            });
            return counts;
        }, [tasks, allTags]);

        // --- Effect for Reminder Notifications & Sounds ---
        useEffect(() => {
            tasks.forEach(task => {
                if (task.reminderAt && !task.reminderFired && task.status !== TASK_STATUS.DONE && new Date(task.reminderAt) <= now) {
                    updateTask(task.id, { reminderFired: true });

                    // Play sound based on priority
                    switch (task.priority) {
                        case PRIORITIES.HIGH:
                            playTone(880, 0.6, 'sawtooth', 0.4); // Higher pitch, slightly harsher, louder
                            setTimeout(() => playTone(880, 0.3, 'sawtooth', 0.4), 150); // Quick second beep
                            break;
                        case PRIORITIES.MEDIUM:
                            playTone(660, 0.8, 'square', 0.35); // Medium pitch
                            break;
                        case PRIORITIES.LOW:
                            playTone(440, 1.0, 'sine', 0.3); // Lower pitch, softer
                            break;
                        default: // Unprioritized or null
                            playTone(523, 0.7, 'sine', 0.25); // A general C5 note
                    }
                }
            });
        }, [tasks, now, updateTask]);

        const handleConfirmDelete = useCallback(() => {
            if (!taskToDelete) return;
            deleteTask(taskToDelete);
            setTaskToDelete(null); // This is correct
        }, [taskToDelete, deleteTask]);

        const handleCreateProject = (projectName) => {
            if (projectName && projectName.trim()) {
                const newTask = addTask('New Task', projectName.trim());
                setSelectedTaskId(newTask.id);
            }
            setShowNewProjectModal(false);
        };

        const [showAddTaskModal, setShowAddTaskModal] = useState(false);
        const handleAddTaskFromModal = ({ title, priority, tags }) => {
            // This will now handle a single project
            const newTask = addTask(title, null, priority); 
            setSelectedTaskId(newTask.id); // Select the newly created task
            setShowAddTaskModal(false); 
        };
        const handleConfirmDeleteAllCompleted = useCallback(() => {
            deleteAllCompletedTasks();
            setShowDeleteAllCompletedModal(false);
        }, [deleteAllCompletedTasks]);
        // The project view has been removed, so we only need the main task view.
        // The 'currentView' state and toggle function are no longer needed for switching to a project page.
        
        const handleTimezoneChange = (newTimezone) => setClockTimezone(newTimezone);
        
        // Effect to automatically hide empty swimlanes if autoCollapse is enabled (and they are empty after filtering)

        const generateCompletedTasksSummary = useCallback(() => {
            const localeOptions = {
                year: 'numeric', month: 'numeric', day: 'numeric',
                hour: 'numeric', minute: 'numeric', second: 'numeric',
                hour12: true,
                timeZone: clockTimezone
            };

            let summary;

            if (tasks.length === 0) {
                summary = "No tasks to summarize.";
            } else {
                summary = `--- Handover Report ---\n`;
                summary += `Generated on: ${new Date().toLocaleString('en-US', localeOptions)} (${TIMEZONES.find(tz => tz.value === clockTimezone)?.label || clockTimezone})\n\n`;

                const inProgressTasks = tasks.filter(t => t.status !== TASK_STATUS.DONE).sort((a, b) => getPrioritySortValue(a.priority) - getPrioritySortValue(b.priority));
                const completedTasks = tasks.filter(t => t.status === TASK_STATUS.DONE).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

                const groupTasksByProject = (tasksToGroup) => {
                    const grouped = tasksToGroup.reduce((acc, task) => {
                        const project = task.project || 'Unassigned';
                        if (!acc[project]) {
                            acc[project] = [];
                        }
                        acc[project].push(task);
                        return acc;
                    }, {});
                    // Sort projects alphabetically, keeping 'Unassigned' first if it exists
                    return Object.entries(grouped).sort(([a], [b]) => {
                        if (a === 'Unassigned') return -1;
                        if (b === 'Unassigned') return 1;
                        return a.localeCompare(b);
                    });
                };

                if (inProgressTasks.length > 0) {
                    summary += `========================================\n`;
                    summary += `IN PROGRESS TASKS (${inProgressTasks.length})\n`;
                    const inProgressByProject = groupTasksByProject(inProgressTasks);

                    inProgressByProject.forEach(([projectName, projectTasks]) => {
                        summary += `\n--- Project: ${projectName} (${projectTasks.length}) ---\n`;
                        projectTasks.forEach(task => {
                            summary += `\n  - ${task.title}\n`;
                            if (task.notes && task.notes.trim()) {
                                summary += `    Notes: ${task.notes.trim().replace(/\n/g, '\n           ')}\n`;
                            }
                            const allSubtasks = (task.checklist || []).filter(item => item.text.trim());
                            if (allSubtasks.length > 0) {
                                allSubtasks.forEach(subtask => {
                                    let subtaskLine = `    ${subtask.completed ? '[x]' : '[ ]'} ${subtask.text}`;
                                    if (subtask.completed && subtask.completedAt) {
                                        subtaskLine += ` (on: ${new Date(subtask.completedAt).toLocaleString('en-US', localeOptions)})`;
                                    }
                                    summary += `${subtaskLine}\n`;
                                });
                            }
                        });
                    });
                }

                if (completedTasks.length > 0) {
                    summary += `\n========================================\n`;
                    summary += `COMPLETED TASKS (${completedTasks.length})\n`;
                    const completedByProject = groupTasksByProject(completedTasks);

                    completedByProject.forEach(([projectName, projectTasks]) => {
                        summary += `\n--- Project: ${projectName} (${projectTasks.length}) ---\n`;
                        projectTasks.forEach(task => {
                            summary += `\n  - ${task.title} - Completed at ${new Date(task.timestamp).toLocaleString('en-US', localeOptions)}\n`;
                            if (task.notes && task.notes.trim()) {
                                summary += `    Notes: ${task.notes.trim().replace(/\n/g, '\n           ')}\n`;
                            }
                            const completedSubtasks = (task.checklist || []).filter(item => item.completed && item.text.trim());
                            if (completedSubtasks.length > 0) {
                                completedSubtasks.forEach(subtask => {
                                    summary += `      - ${subtask.text}\n`;
                                });
                            }
                        });
                    });
                }
            }
            setSummaryText(summary);
            setShowSummaryModal(true);
        }, [tasks, clockTimezone]);

        const handleTagFilterClick = (tag) => {
            setActiveTags(prevActiveTags => {
                // If the clicked tag is already the active one, clear the filter.
                if (prevActiveTags.length === 1 && prevActiveTags[0] === tag) {
                    return [];
                } else {
                    // Otherwise, make the clicked tag the only active filter.
                    return [tag];
                }
            });
};

const handleProjectHeaderClick = (projectName) => {
    // When a project header is clicked, show all its tasks and deselect any single task.
    setSelectedProjectName(projectName);
    setSelectedTaskId(null);
        };

        const clearTagFilter = () => setActiveTags([]);

        const tasksMatchingActiveFilters = useMemo(() => {
            if (activeTags.length === 0) return tasks;
            return tasks.filter(task =>
                activeTags.some(activeTag => {
                    const priorityConstant = PRIORITY_TITLE_TO_CONSTANT_MAP[activeTag]; // This part handles priority filters
                    return priorityConstant ? task.priority === priorityConstant : task.project === activeTag;
                })
            );
        }, [tasks, activeTags]);
        // const handleDropSwimlane = (targetSwimlaneName) => {
        
        const selectedTask = useMemo(() => {
            return tasks.find(t => t.id === selectedTaskId);
        }, [tasks, selectedTaskId]);

        const tasksForProjectView = useMemo(() => {
            if (!selectedProjectName) return [];
            if (selectedProjectName === 'Completed') {
                // Special case for the "Completed" virtual project, sorted by completion time
                return tasks.filter(t => t.status === TASK_STATUS.DONE)
                            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }
            // For all other projects, find tasks by their assigned project name
            // and sort them by priority.
            return tasks.filter(t => (t.project || 'Unassigned') === selectedProjectName && t.status !== TASK_STATUS.DONE)
                        .sort((a, b) => getPrioritySortValue(a.priority) - getPrioritySortValue(b.priority));
        }, [tasks, selectedProjectName]);

        return (
            <div className="h-screen w-screen font-sans flex flex-col overflow-x-hidden" style={{ background: 'transparent' }}>

                {taskToDelete && <DeleteConfirmationModal onConfirm={handleConfirmDelete} onCancel={() => setTaskToDelete(null)} />}
                {showDeleteAllCompletedModal && <DeleteAllCompletedModal onConfirm={handleConfirmDeleteAllCompleted} onCancel={() => setShowDeleteAllCompletedModal(false)} count={completedTasksCount} />}
                {showSummaryModal && <SummaryModal summary={summaryText} onClose={() => setShowSummaryModal(false)} />}
                {showReleaseNotesModal && <ReleaseNotesModal version={CURRENT_APP_VERSION} releaseInfo={RELEASE_NOTES[CURRENT_APP_VERSION]} onClose={handleCloseReleaseNotes} />}
                {showNewProjectModal && <NewProjectModal onAdd={handleCreateProject} onCancel={() => setShowNewProjectModal(false)} />}
                {showSettings && <SettingsModal settings={settings} onSettingsChange={setSettings} onClose={() => setShowSettings(false)} />}
                {showAddTaskModal && <AddTaskModal onAdd={handleAddTaskFromModal} onCancel={() => setShowAddTaskModal(false)} allTags={allTags} />}
                
                <header className="sticky top-0 z-20 px-4 py-2 bg-gradient-to-b from-slate-950/95 to-sky-900/40 backdrop-blur-lg shadow-2xl shadow-black/30 border-b border-sky-900/40 flex items-center justify-between flex-wrap gap-x-4 gap-y-2">
                    {/* --- Left Side: Logo, Title, Toolbar --- */}
                    <div className="flex items-center gap-4">
                        {showDetailViewOnMobile ? (
                            <button 
                                onClick={() => { setSelectedTaskId(null); setSelectedProjectName(null); }}
                                className="text-sky-300 hover:bg-sky-500/20 p-2 rounded-md flex items-center gap-2"
                            >
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}><path strokeLinecap="round" strokeLinejoin="round" d="M15 19l-7-7 7-7" /></svg>
                                <span className="font-semibold">Back</span>
                            </button>
                        ) : (
                            <>
                                <TaikoLogo />
                                <h1 className="text-3xl font-bold" style={{ color: '#E0E7FF', textTransform: 'uppercase', letterSpacing: '0.2em' }}>Taiko</h1>
                            </>
                        )}
                        <HeaderToolbar isSmallScreen={windowWidth < 768} onShowSettings={() => setShowSettings(true)} onGenerateSummary={generateCompletedTasksSummary} onShowDeleteAllModal={() => setShowDeleteAllCompletedModal(true)} showDeleteAllButton={completedTasksCount > 0} />
                    </div>

                    {/* --- Right Side: Add Task & Clock --- */}
                    <div className={`flex items-center ${showDetailViewOnMobile ? 'hidden' : ''}`}>
                        <LiveClock timezone={clockTimezone} onTimezoneChange={handleTimezoneChange} />
                    </div>
                </header>
                <div className={`px-4 py-2 flex-shrink-0 border-b border-slate-800 flex justify-between items-center flex-wrap gap-4 ${showDetailViewOnMobile ? 'hidden' : ''}`}>
                    <FilterToolbar
                        activeTasksCount={activeTasksCount}
                        completedTasksCount={completedTasksCount}
                        activeTags={activeTags}
                        priorityFilterCounts={priorityFilterCounts}
                        tagsForCurrentView={allTags}
                        customTagFilterCounts={customTagFilterCounts}
                        onShowNewProjectModal={() => setShowNewProjectModal(true)}
                        onClearFilters={clearTagFilter}
                        onTagFilterClick={handleTagFilterClick}
                    />
                </div>
                <main className={`flex-grow p-4 flex flex-col md:flex-row gap-4 overflow-hidden transition-all duration-300`}>
                            {/* Left Pane: Task List */}
                            <div className={`w-full md:w-1/3 flex-shrink-0 overflow-y-auto pr-2 ${showDetailViewOnMobile ? 'hidden' : ''}`}>
                                <TaskList
                                    tasks={tasksMatchingActiveFilters}
                                    selectedTaskId={selectedTaskId}
                                    onSelectTask={(id) => { setSelectedTaskId(id); setSelectedProjectName(null); }} // This is correct
                                    clockTimezone={clockTimezone}
                                    onProjectHeaderClick={handleProjectHeaderClick}
                                    selectedProjectName={selectedProjectName}
                                    onShowDeleteAllModal={() => setShowDeleteAllCompletedModal(true)} // Pass down the modal toggle
                                    onAddTask={(projectName) => { 
                                        addTask('New Task', projectName); 
                                        // Switch view to the project
                                        setSelectedProjectName(projectName);
                                        setSelectedTaskId(null);
                                        // Ensure the project is expanded
                                        if (collapsedProjects[projectName]) toggleProjectCollapse(projectName);
                                    }}
                                    completedTasksCount={completedTasksCount}
                                />
                            </div>

                            {/* Right Pane: Task Details */}
                            <div className={`w-full md:w-2/3 flex-grow overflow-y-auto ${showListViewOnMobile ? 'hidden' : ''}`}>
                                {selectedProjectName ? (
                                    <div className="space-y-4">
                                        {tasksForProjectView.length > 0 ? (
                                            tasksForProjectView.map(task => <MemoizedTaskCard key={task.id} task={task} clockTimezone={clockTimezone} />)
                                        ) : (
                                            <p className="text-slate-500 px-2">No tasks in this project.</p>
                                        )}
                                    </div>
                                ) : selectedTask ? (
                                    <MemoizedTaskCard key={selectedTask.id} task={selectedTask} clockTimezone={clockTimezone} />
                                ) : (
                                    <div className="h-full flex items-center justify-center text-slate-500 text-xl">
                                        Select a task or a project to see details
                                    </div>
                                )}
                            </div>
                        </main>
                <Footer onShowReleaseNotes={() => setShowReleaseNotesModal(true)} />
            </div>
        );
    };
    // --- Column & Modal Components ---
    const FilterToolbar = React.memo(({
        activeTasksCount,
        completedTasksCount,
        activeTags,
        priorityFilterCounts,
        tagsForCurrentView,
        customTagFilterCounts,
        onShowNewProjectModal,
        onClearFilters,
        onTagFilterClick
    }) => {
        const [isFilterMenuOpen, setIsFilterMenuOpen] = useState(false);
        const filterMenuRef = useRef(null);

        useEffect(() => {
            const handleClickOutside = (event) => {
                if (filterMenuRef.current && !filterMenuRef.current.contains(event.target)) {
                    setIsFilterMenuOpen(false);
                }
            };
            document.addEventListener("mousedown", handleClickOutside);
            return () => document.removeEventListener("mousedown", handleClickOutside);
        }, [filterMenuRef]);

        const filterButtonText = activeTags.length > 0 ? `Filtered: ${activeTags.join(', ')}` : 'Filter by...';

        return (
            <div className="flex items-center space-x-2 flex-wrap">
                {/* --- New Project Button --- */}
                <button 
                    onClick={onShowNewProjectModal}
                    title="Create a new project" 
                    className="px-3 py-1 text-sm font-medium rounded-md transition-colors text-sky-300 bg-sky-600/30 hover:bg-sky-600/50 border border-sky-600/80 flex items-center gap-1.5"><PlusIcon /> New Project</button>
                {/* --- Unified Filter Dropdown --- */}
                <div className="relative" ref={filterMenuRef}>
                    <button onClick={() => setIsFilterMenuOpen(p => !p)} title="Select a filter" className={`px-3 py-1 text-sm font-medium rounded-md transition-colors flex items-center gap-1 ${activeTags.length > 0 ? 'bg-indigo-600 text-white' : 'text-slate-400 hover:bg-slate-700/50'}`}>
                        {filterButtonText}
                        <ChevronDownIcon className={`h-4 w-4 transition-transform ${isFilterMenuOpen ? 'rotate-180' : ''}`} />
                    </button>
                    {isFilterMenuOpen && (
                        <div className="absolute left-0 mt-2 w-56 bg-slate-800 border border-slate-700 rounded-md shadow-lg py-1 z-20">
                            <button onClick={() => { onClearFilters(); setIsFilterMenuOpen(false); }} className={`w-full text-left px-4 py-2 text-sm ${activeTags.length === 0 ? 'text-white bg-sky-600' : 'text-slate-200 hover:bg-slate-700'}`}>All Active ({activeTasksCount})</button>
                            <div className="my-1 border-t border-slate-700"></div>
                            <div className="px-4 pt-2 pb-1 text-xs font-semibold text-slate-400">By Priority</div>
                            {DISPLAY_PRIORITY_ORDER.map(pConst => {
                                const pTitle = PRIORITY_CONFIG[pConst].title;
                                return <button key={pTitle} onClick={() => { onTagFilterClick(pTitle); setIsFilterMenuOpen(false); }} className={`w-full text-left px-4 py-2 text-sm ${activeTags.includes(pTitle) ? `text-white ${PRIORITY_CONFIG[pConst].bgColor}` : 'text-slate-200 hover:bg-slate-700'}`}>{pTitle} ({priorityFilterCounts[pTitle] || 0})</button>
                            })}
                            {tagsForCurrentView.length > 0 && (
                                <>
                                    <div className="my-1 border-t border-slate-700"></div>
                                    <div className="px-4 pt-2 pb-1 text-xs font-semibold text-slate-400">By Project</div>
                                    {tagsForCurrentView.map(tag => (
                                        <button key={tag} onClick={() => { onTagFilterClick(tag); setIsFilterMenuOpen(false); }} className={`w-full text-left px-4 py-2 text-sm ${activeTags.includes(tag) ? 'text-white bg-indigo-600' : 'text-slate-200 hover:bg-slate-700'}`}>{tag} ({customTagFilterCounts[tag] || 0})</button>
                                    ))}
                                </>
                            )}
                        </div>
                    )}
                </div>
            </div>
        );
    });
    const HeaderToolbar = React.memo(({ isSmallScreen, onShowSettings, onGenerateSummary, onShowDeleteAllModal, showDeleteAllButton }) => {
        const [isMenuOpen, setIsMenuOpen] = useState(false);
        const menuRef = useRef(null);

        useEffect(() => {
            const handleClickOutside = (event) => {
                if (menuRef.current && !menuRef.current.contains(event.target)) {
                    setIsMenuOpen(false);
                }
            };
            document.addEventListener("mousedown", handleClickOutside);
            return () => document.removeEventListener("mousedown", handleClickOutside);
        }, [menuRef]);

        const menuItems = (
            <>
                <button onClick={onShowSettings} className="w-full text-left px-4 py-2 text-sm text-slate-200 hover:bg-slate-700">Settings</button>
                <a href="https://github.com/closedloopchaos/taiko/issues/new/choose" target="_blank" rel="noopener noreferrer" className="block w-full text-left px-4 py-2 text-sm text-slate-200 hover:bg-slate-700">Report Issue</a>
                <button onClick={onGenerateSummary} className="w-full text-left px-4 py-2 text-sm text-slate-200 hover:bg-slate-700">Generate Summary</button>
                {showDeleteAllButton && <button onClick={onShowDeleteAllModal} className="w-full text-left px-4 py-2 text-sm text-red-400 hover:bg-red-500/20">Delete All Completed</button>}
            </>
        );

        if (isSmallScreen) {
            return (
                <div className="relative" ref={menuRef}>
                    <button onClick={() => setIsMenuOpen(prev => !prev)} title="More options" className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z" /></svg>
                    </button>
                    {isMenuOpen && (
                        <div className="absolute left-0 mt-2 w-48 bg-slate-800 border border-slate-700 rounded-md shadow-lg py-1 z-20">
                            {menuItems}
                        </div>
                    )}
                </div>
            );
        }

        return (
            <div className="flex items-center flex-wrap gap-2">
                <button onClick={onShowSettings} title="Settings" className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><SettingsIcon /></button>
                <a href="https://github.com/closedloopchaos/taiko/issues/new/choose" title="Report Issue or Submit Feedback" target="_blank" rel="noopener noreferrer" className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><BugIcon /></a>
                <button onClick={onGenerateSummary} title="Generate Summary of Completed Tasks" className="p-2 text-slate-300 hover:text-white rounded-full hover:bg-slate-700 transition-colors"><DocumentTextIcon /></button>
            </div>
        );
    });
    const Footer = React.memo(({ onShowReleaseNotes }) => {
        const EarthIcon = () => (
            <svg viewBox="0 0 100 100" className="absolute bottom-0 left-1/2 -translate-x-1/2 h-48 w-48 text-slate-700/50 opacity-30 -z-10" fill="none" stroke="currentColor" strokeWidth="0.5">
                <circle cx="50" cy="50" r="48"/>
                <ellipse cx="50" cy="50" rx="48" ry="20"/>
                <ellipse cx="50" cy="50" rx="48" ry="40" transform="rotate(90 50 50)"/>
                <path d="M 10,60 C 20,75 40,80 50,70 S 70,50 85,55"/>
                <path d="M 5,40 C 25,45 40,30 55,35 S 80,50 95,45"/>
                <path d="M 20,20 C 30,35 50,35 60,25 S 80,20 85,30"/>
            </svg>
        );
        return (
            <footer className="relative bg-slate-900/80 backdrop-blur-sm p-3 text-center text-sm text-slate-400 shadow-t-lg z-40 flex-shrink-0 overflow-hidden">
                <EarthIcon />
                <div className="flex items-center justify-center space-x-4">
                    <div className="flex items-center justify-center space-x-1.5">
                        <span>Courtesy of</span>
                        <a href="https://github.com/closedloopchaos" target="_blank" rel="noopener noreferrer" className="inline-flex items-center text-sky-400 hover:text-sky-300 font-semibold hover:underline">
                            <svg className="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 16 16" aria-hidden="true"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>
                            closedloopchaos
                        </a>
                    </div>
                    <div className="border-l border-slate-600 h-5"></div>
                    <button onClick={onShowReleaseNotes} className="text-sky-400 hover:text-sky-300 font-semibold hover:underline">Release Notes (v{CURRENT_APP_VERSION})</button>
                </div>
            </footer>
        );
    });

    const AddTaskButton = React.memo(({ onAddTask }) => {
        const windowWidth = useWindowWidth();
        const isSmall = windowWidth < 768;

        return (
            <div className="relative">
                <button 
                    onClick={onAddTask}
                    title="Add a new task (A)"
                    className="px-3 py-1.5 bg-sky-500/20 border border-sky-500/80 text-sky-200 text-sm font-semibold rounded-lg shadow-md hover:bg-sky-500/40 hover:text-white focus:outline-none focus:ring-2 focus:ring-sky-400 focus:ring-opacity-75 transition-all flex items-center gap-2"
                >
                    <PlusIcon /> {!isSmall && 'Add Task'}
                </button>
            </div>
        );
    });

    const AddTaskModal = ({ onAdd, onCancel, allTags }) => {
        const [title, setTitle] = useState('');
        const [priority, setPriority] = useState(null);
        const [tags, setTags] = useState([]);
        const [currentTagInput, setCurrentTagInput] = useState('');
        const inputRef = useRef(null);

        useEffect(() => {
            if (inputRef.current) inputRef.current.focus();
        }, []);

        const handleAdd = () => {
            if (title.trim()) {
                onAdd({ title: title.trim(), priority, tags });
            }
        };

        const handleTitleKeyDown = (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Prevent form submission or newline
                handleAdd();
            }
        };

        const handleAddTag = () => {
            const trimmedTag = currentTagInput.trim();
            if (trimmedTag && !tags.includes(trimmedTag)) {
                setTags([...tags, trimmedTag]);
            }
            setCurrentTagInput('');
        };

        const handleRemoveTag = (tagToRemove) => {
            setTags(tags.filter(tag => tag !== tagToRemove));
        };

        return (
            <Modal onClose={onCancel}>
                <ModalContent title="Add New Task" onClose={onCancel}>
                    <div className="space-y-4">
                        {/* Title Input */}
                        <input
                            ref={inputRef}
                            type="text"
                            value={title}
                            onChange={e => setTitle(e.target.value)}
                            onKeyDown={handleTitleKeyDown}
                            placeholder="Enter task title..."
                            className="w-full bg-slate-900/80 text-slate-200 text-lg p-3 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500"
                        />

                        {/* Priority Selection */}
                        <div className="pt-2 border-t border-slate-700/50">
                            <div className="flex flex-wrap items-center gap-2">
                                <span className="text-sm text-slate-400">Priority:</span>
                                {DISPLAY_PRIORITY_ORDER.map(pConst => (                                    <button 
                                        key={pConst} title={`Set priority to ${PRIORITY_CONFIG[pConst].title}`}
                                        onClick={() => setPriority(pConst === priority ? null : pConst)}
                                        className={`px-3 py-1 text-xs font-semibold rounded-md border transition-colors ${priority === pConst ? `${PRIORITY_CONFIG[pConst].bgColor} ${PRIORITY_CONFIG[pConst].borderColor} ${PRIORITY_CONFIG[pConst].color}` : `bg-slate-600/50 border-slate-500 text-slate-300 hover:${PRIORITY_CONFIG[pConst].bgColor}`}`}
                                    >
                                        {PRIORITY_CONFIG[pConst].title}
                                    </button>
                                ))}
                            </div>
                        </div>

                        {/* Action Buttons */}
                        <div className="flex justify-end space-x-2 pt-3 border-t border-slate-700/50">
                            <button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button>
                            <button onClick={handleAdd} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500">Add Task</button>
                        </div>
                    </div>
                </ModalContent>
            </Modal>
        );
    };

    const NewProjectModal = ({ onAdd, onCancel }) => {
        const [name, setName] = useState('');
        const inputRef = useRef(null);

        useEffect(() => {
            if (inputRef.current) inputRef.current.focus();
        }, []);

        const handleAdd = () => {
            if (name.trim()) {
                onAdd(name.trim());
            }
        };

        const handleKeyDown = (e) => {
            if (e.key === 'Enter') { e.preventDefault(); handleAdd(); }
        };

        return (
            <Modal onClose={onCancel}>
                <ModalContent title="Create New Project" onClose={onCancel}>
                    <div className="space-y-4">
                        <input ref={inputRef} type="text" value={name} onChange={e => setName(e.target.value)} onKeyDown={handleKeyDown} placeholder="Enter project name..." className="w-full bg-slate-900/80 text-slate-200 text-lg p-3 rounded-md border border-slate-600 focus:ring-2 focus:ring-sky-500" />
                        <div className="flex justify-end space-x-2 pt-3 border-t border-slate-700/50">
                            <button onClick={onCancel} className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button>
                            <button onClick={handleAdd} className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500">Create Project</button>
                        </div>
                    </div>
                </ModalContent>
            </Modal>
        );
    };
    const Modal = ({ children, onClose }) => <div onClick={onClose} className="fixed inset-0 bg-black/60 z-50 flex items-center justify-center p-4">{children}</div>;
    const ModalContent = ({ title, children, onClose, headerActions }) => (
        <div 
            className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-md text-white flex flex-col max-h-[90vh]"
            onClick={e => e.stopPropagation()}
        >
            <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                <h3 className="text-xl font-bold">{title}</h3>
                {headerActions && <div>{headerActions}</div>}
            </div>
            <div className="p-4 overflow-y-auto">{children}</div>
        </div>
    );
    const DeleteConfirmationModal = ({ onConfirm, onCancel }) => <Modal onClose={onCancel}><div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Delete Task?</h3><p className="text-slate-300 mb-4">Are you sure you want to permanently delete this task?</p><div className="flex justify-center space-x-4"><button onClick={onCancel} title="Cancel deletion" className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button><button onClick={onConfirm} title="Confirm permanent deletion" className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-500">Delete</button></div></div></Modal>;
    const SettingsModal = ({ settings, onSettingsChange, onClose }) => { 
        const handleToggle = (key) => onSettingsChange(p => ({ ...p, [key]: !p[key] })); 
        const handleAnimationSettingChange = (key, value) => onSettingsChange(p => ({ ...p, animationSettings: { ...p.animationSettings, [key]: value } }));
        return ( 
            <Modal onClose={onClose}>
                <ModalContent title="Settings" onClose={onClose}>
                    <div className="space-y-4">
                        <div className="flex items-center justify-between">
                            <label className="text-slate-300">Confirm on Delete</label>
                            <button onClick={() => handleToggle('confirmOnDelete')} title={settings.confirmOnDelete ? "Disable delete confirmation" : "Enable delete confirmation"} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.confirmOnDelete ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.confirmOnDelete ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                        </div>
                        <div className="pt-4 border-t border-slate-700/50 space-y-4">
                            <h4 className="text-lg font-semibold text-slate-200">Background Animation</h4>
                            <div className="flex items-center justify-between">
                                <label className="text-slate-300">Enable Animation</label>
                                <button onClick={() => handleAnimationSettingChange('enabled', !settings.animationSettings.enabled)} title={settings.animationSettings.enabled ? "Disable background animation" : "Enable background animation"} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.animationSettings.enabled ? 'bg-green-500' : 'bg-slate-600'}`}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.animationSettings.enabled ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </div>
                            <div className="flex items-center justify-between">
                                <label className="text-slate-300">Mouse Interaction</label>
                                <button onClick={() => handleAnimationSettingChange('mouseInteraction', !settings.animationSettings.mouseInteraction)} title={settings.animationSettings.mouseInteraction ? "Disable mouse interaction" : "Enable mouse interaction"} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.animationSettings.mouseInteraction ? 'bg-green-500' : 'bg-slate-600'}`} disabled={!settings.animationSettings.enabled}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.animationSettings.mouseInteraction ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </div>
                            <div className="flex items-center justify-between">
                                <label className="text-slate-300">Click Pulse Effect</label>
                                <button onClick={() => handleAnimationSettingChange('clickPulse', !settings.animationSettings.clickPulse)} title={settings.animationSettings.clickPulse ? "Disable click pulse" : "Enable click pulse"} className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${settings.animationSettings.clickPulse ? 'bg-green-500' : 'bg-slate-600'}`} disabled={!settings.animationSettings.enabled}><span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${settings.animationSettings.clickPulse ? 'translate-x-6' : 'translate-x-1'}`} /></button>
                            </div>

                            <div className="flex flex-col space-y-2">
                                <label htmlFor="particleCount" className="text-slate-300 flex justify-between">
                                    <span>Particle Count</span>
                                    <span className="text-sky-400 font-mono">{settings.animationSettings.particleCount}</span>
                                </label>
                                <input id="particleCount" type="range" min="250" max="500" step="5"
                                    value={settings.animationSettings.particleCount}
                                    onChange={e => handleAnimationSettingChange('particleCount', parseInt(e.target.value, 10))}
                                    disabled={!settings.animationSettings.enabled}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                                />
                            </div>
                            <div className="flex flex-col space-y-2">
                                <label htmlFor="connectionDistance" className="text-slate-300 flex justify-between">
                                    <span>Connection Distance</span>
                                    <span className="text-sky-400 font-mono">{settings.animationSettings.connectionDistance}px</span>
                                </label>
                                <input id="connectionDistance" type="range" min="30" max="250" step="5"
                                    value={settings.animationSettings.connectionDistance}
                                    onChange={e => handleAnimationSettingChange('connectionDistance', parseInt(e.target.value, 10))}
                                    disabled={!settings.animationSettings.enabled}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                                />
                            </div>
                            <div className="flex flex-col space-y-2">
                                <label htmlFor="particleSpeed" className="text-slate-300 flex justify-between">
                                    <span>Particle Speed</span>
                                    <span className="text-sky-400 font-mono">{settings.animationSettings.particleSpeed.toFixed(1)}</span>
                                </label>
                                <input id="particleSpeed" type="range" min="0.1" max="2" step="0.1"
                                    value={settings.animationSettings.particleSpeed}
                                    onChange={e => handleAnimationSettingChange('particleSpeed', parseFloat(e.target.value))}
                                    disabled={!settings.animationSettings.enabled}
                                    className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer disabled:opacity-50"
                                />
                            </div>
                        </div>
                    </div>
                </ModalContent>
            </Modal> 
        );
    };
    const DeleteAllCompletedModal = ({ onConfirm, onCancel, count }) => (
        <Modal onClose={onCancel}>
            <div className="bg-slate-800 rounded-lg shadow-2xl p-6 w-full max-w-sm text-center" onClick={e => e.stopPropagation()}><h3 className="text-lg font-bold text-white mb-2">Delete All Completed Tasks?</h3><p className="text-slate-300 mb-4">Are you sure you want to permanently delete all {count} completed tasks? This action cannot be undone.</p><div className="flex justify-center space-x-4"><button onClick={onCancel} title="Cancel deletion" className="px-4 py-2 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500">Cancel</button><button onClick={onConfirm} title="Confirm permanent deletion of all completed tasks" className="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-500">Delete All</button></div></div>
        </Modal>
    );

    const SummaryModal = ({ summary, onClose }) => {
        const [copyButtonText, setCopyButtonText] = useState('Copy to Clipboard');

        const handleCopy = useCallback(() => {
            if (!navigator.clipboard) {
                console.error('Clipboard API not available.');
                setCopyButtonText('Copy failed');
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
                return;
            }
            navigator.clipboard.writeText(summary).then(() => {
                setCopyButtonText('Copied!');
                playTone(880, 0.1, 'sine', 0.2); // Success sound
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                setCopyButtonText('Failed to copy');
                playTone(220, 0.2, 'square', 0.2); // Error sound
                setTimeout(() => setCopyButtonText('Copy to Clipboard'), 2000);
            });
        }, [summary]);

        return (
            <Modal onClose={onClose}>
                <div className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-3xl text-white flex flex-col overflow-x-hidden max-h-[90vh]" onClick={e => e.stopPropagation()}>
                    <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                        <h3 className="text-xl font-bold">Completed Tasks Summary</h3>
                        <div className="flex items-center space-x-2">
                            <button onClick={handleCopy} title="Copy summary to your clipboard" className="px-3 py-1 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500 text-sm transition-all duration-150 w-36 text-center">{copyButtonText}</button>
                            <button onClick={onClose} title="Close this summary" className="px-4 py-1 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-500 text-sm">Done</button>
                        </div>
                    </div>
                    <div className="p-4 overflow-y-auto"><pre className="text-sm text-slate-300 whitespace-pre-wrap font-mono bg-slate-900/50 p-4 rounded-md border border-slate-700">{summary}</pre></div>
                </div>
            </Modal>
        );
    };

    const ReleaseNotesModal = ({ version, onClose }) => {
        const [expandedVersions, setExpandedVersions] = useState({});
        const currentReleaseInfo = RELEASE_NOTES[version];
        // Get all other versions, sort them descending
        const previousVersionKeys = Object.keys(RELEASE_NOTES)
            .filter(v => v !== version)
            .sort((a, b) => b.localeCompare(a, undefined, { numeric: true }));

        if (!currentReleaseInfo) return null;

        const toggleVersion = (v) => setExpandedVersions(prev => ({ ...prev, [v]: !prev[v] }));

        return (
            <Modal onClose={onClose}>
                <div className="bg-slate-800 rounded-lg shadow-2xl w-full max-w-2xl text-white flex flex-col max-h-[90vh]" onClick={e => e.stopPropagation()}>
                    <div className="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0">
                        <h3 className="text-xl font-bold">{currentReleaseInfo.title}</h3>
                        <button onClick={onClose} title="Close Release Notes" className="px-4 py-2 bg-sky-600 text-white font-semibold rounded-lg hover:bg-sky-500 text-sm">Got it!</button>
                    </div>
                    <div className="p-6 overflow-y-auto space-y-4">
                        {currentReleaseInfo.notes.map((note, index) => (
                            <div key={index} className="bg-slate-900/50 p-4 rounded-lg border border-slate-700">
                                <h4 className="font-bold text-sky-300 mb-1">{note.title}</h4>
                                <p className="text-sm text-slate-300">{note.description}</p>
                            </div>
                        ))}
                        {previousVersionKeys.length > 0 && <div className="pt-4 border-t border-slate-700/50 space-y-2">
                            {previousVersionKeys.map(vKey => {
                                const release = RELEASE_NOTES[vKey];
                                return (
                                    <div key={vKey}>
                                        <button onClick={() => toggleVersion(vKey)} className="w-full flex justify-between items-center p-2 text-left rounded-md hover:bg-slate-700/50">
                                            <h4 className="text-md font-semibold text-slate-400">{release.title}</h4>
                                            <ChevronDownIcon className={`h-5 w-5 text-slate-400 transition-transform ${expandedVersions[vKey] ? 'rotate-180' : ''}`} />
                                        </button>
                                        {expandedVersions[vKey] && <div className="mt-2 space-y-3 pl-4 pr-2">
                                            {release.notes.map((note, index) => <p key={index} className="text-sm text-slate-400"><span className="font-semibold text-slate-300">{note.title}:</span> {note.description}</p>)}
                                        </div>}
                                    </div>
                                );
                            })}
                        </div>}
                    </div>
                </div>
            </Modal>
        );
    };

    // --- App Entry Point ---
    const AppContainer = () => {
        return <App />;
    };

    const TaikoApp = () => {
        return (
            <AppProvider>
                <AppContainer />
            </AppProvider>
        );
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<TaikoApp />);

    </script>

    <!-- Node Garden Background Animation Script -->
    <script>
        const canvas = document.getElementById('node-garden-canvas');
        const ctx = canvas.getContext('2d');

        // --- Default Animation Settings ---
        let animSettings = {
            enabled: true,
            particleCount: 350,
            connectionDistance: 200,
            particleSpeed: 0.3,
            mouseInteraction: true,
            clickPulse: true,
        };

        let particles = [];
        const mouse = { x: null, y: null, radius: 150 };
        let animationFrameId;
        let pulses = []; // Array to store active pulse waves

        // --- Animation Control based on screen size ---
        const isSmallScreen = () => window.innerWidth < 768;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            mouse.radius = isSmallScreen() ? (canvas.width / 15) + 20 : (canvas.width / 12) + 50; // Keep mouse radius update
        }

        let wasSmall = isSmallScreen();
        window.addEventListener('resize', () => {
            resizeCanvas();
            const isNowSmall = isSmallScreen();

            if (isNowSmall !== wasSmall) {
                if (isNowSmall) {
                    stopAnimation();
                } else if (animSettings.enabled) {
                    startAnimation();
                }
                wasSmall = isNowSmall;
            }
        });

        window.addEventListener('mousemove', (event) => {
            mouse.x = event.x;
            mouse.y = event.y;
        });

        window.addEventListener('mouseout', () => {
            mouse.x = null;
            mouse.y = null;
        });

        // Listen for clicks to create a pulse
        window.addEventListener('click', (event) => {
            if (!animSettings.enabled || !animSettings.clickPulse) return;
            pulses.push({
                x: event.clientX,
                y: event.clientY,
                radius: 0,
                maxRadius: Math.sqrt(canvas.width ** 2 + canvas.height ** 2), // Pulse expands to the full diagonal of the screen
                speed: 8,
            });
        });

        // Listen for settings changes from React
        window.addEventListener('animationSettingsChange', (event) => {
            const newSettings = event.detail;
            const oldEnabled = animSettings.enabled;

            // Check if particle speed changed to adjust velocity without a full reset
            if (newSettings.enabled && newSettings.particleSpeed !== animSettings.particleSpeed && animSettings.particleSpeed > 0) {
                const speedRatio = newSettings.particleSpeed / animSettings.particleSpeed;
                particles.forEach(p => {
                    p.vx *= speedRatio;
                    p.vy *= speedRatio;
                });
            }

            // Update the global animation settings object
            animSettings = { ...animSettings, ...newSettings };

            if (animSettings.enabled && !oldEnabled) {
                startAnimation(); // Start if it was just enabled
            } else if (!animSettings.enabled && oldEnabled) {
                stopAnimation(); // Stop if it was just disabled
            } else if (animSettings.enabled && newSettings.particleCount !== particles.length) {
                init(); // Re-initialize if particle count changes while enabled
            }
        });

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.baseSize = Math.random() * 1.5 + 0.5;
                this.size = this.baseSize;
                this.density = (Math.random() * 30) + 1;
                this.defaultColor = 'rgba(100, 116, 139, 0.8)'; // slate-500
                this.vx = (Math.random() - 0.5) * animSettings.particleSpeed; // Velocity X
                this.vy = (Math.random() - 0.5) * animSettings.particleSpeed; // Velocity Y
                // For pulsing effect
                this.pulseAngle = Math.random() * Math.PI * 2;
                this.pulseSpeed = 0.02 + Math.random() * 0.02;
            }

            draw() {
                ctx.fillStyle = this.currentColor || this.defaultColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }

            update() {
                // Autonomous movement and wall bouncing
                this.x += this.vx;
                this.y += this.vy;
                if (this.x <= 0 || this.x >= canvas.width) { this.vx *= -1; }
                if (this.y <= 0 || this.y >= canvas.height) { this.vy *= -1; }

                // Pulsing effect
                this.pulseAngle += this.pulseSpeed;
                this.size = this.baseSize + Math.sin(this.pulseAngle) * (this.baseSize * 0.5);

                // Mouse interaction - determine color
                this.currentColor = null; // Reset color
                if (animSettings.mouseInteraction && mouse.x !== null) {
                    let dx = mouse.x - this.x;
                    let dy = mouse.y - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    this.currentColor = getColorFromDistance(distance, mouse.radius);
                }

                // Pulse interaction - overrides mouse color
                for (let i = 0; i < pulses.length; i++) {
                    const pulse = pulses[i];
                    const dx = pulse.x - this.x;
                    const dy = pulse.y - this.y;
                    const distanceToPulseCenter = Math.sqrt(dx * dx + dy * dy);
                    const pulseWidth = 60; // How thick the ripple wave is

                    if (distanceToPulseCenter > pulse.radius - pulseWidth && distanceToPulseCenter < pulse.radius) {
                        // The particle is inside the ripple band
                        this.currentColor = `rgb(34, 197, 94)`; // A bright green color for the pulse
                    }
                }
            }
        }

        // Helper function to get color based on distance to mouse
        function getColorFromDistance(distance, maxDistance) {
            if (distance < maxDistance) {
                const normalizedDistance = distance / maxDistance; // 0 (closest) to 1 (farthest)
                let r, g, b;
                
                // Gradient: Red -> Yellow -> Green
                if (normalizedDistance < 0.5) {
                    // Interpolate from Red (239, 68, 68) to Yellow (251, 191, 36)
                    const t = normalizedDistance * 2; // Scale to 0-1 range
                    r = 239 + (251 - 239) * t;
                    g = 68 + (191 - 68) * t;
                    b = 68 + (36 - 68) * t;
                } else {
                    // Interpolate from Yellow (251, 191, 36) to Green (34, 197, 94)
                    const t = (normalizedDistance - 0.5) * 2; // Scale to 0-1 range
                    r = 251 + (34 - 251) * t;
                    g = 191 + (197 - 191) * t;
                    b = 36 + (94 - 36) * t;
                }
                return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
            }
            return null;
        }

        function init() {
            if (!animSettings.enabled) return;
            particles = [];
            for (let i = 0; i < animSettings.particleCount; i++) {
                particles.push(new Particle());
            }
        }

        function animate() {
            if (!animSettings.enabled || isSmallScreen()) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update and draw pulses
            for (let i = pulses.length - 1; i >= 0; i--) {
                pulses[i].radius += pulses[i].speed;
                if (pulses[i].radius > pulses[i].maxRadius) {
                    pulses.splice(i, 1); // Remove pulse when it's done
                }
            }

            // Draw connecting lines
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < animSettings.connectionDistance) {
                        ctx.beginPath();
                        
                        let strokeStyle = `rgba(100, 116, 139, ${1 - distance / animSettings.connectionDistance})`;
                        
                        // Check for mouse interaction color
                        if (animSettings.mouseInteraction && mouse.x !== null) {
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            const mouseDx = mouse.x - midX;
                            const mouseDy = mouse.y - midY;
                            const midPointDistanceToMouse = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);
                            const lineColor = getColorFromDistance(midPointDistanceToMouse, mouse.radius);
                            
                            if (lineColor) {
                                // Extract the RGB part and add the alpha from the original style
                                const alpha = 1 - distance / animSettings.connectionDistance;
                                strokeStyle = lineColor.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                            }
                        }

                        // Check for pulse interaction on lines
                        for (let k = 0; k < pulses.length; k++) {
                            const pulse = pulses[k];
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            const dx = pulse.x - midX;
                            const dy = pulse.y - midY;
                            const distanceToPulseCenter = Math.sqrt(dx * dx + dy * dy);
                            if (distanceToPulseCenter > pulse.radius - 60 && distanceToPulseCenter < pulse.radius) {
                                const alpha = 1 - distance / animSettings.connectionDistance;
                                strokeStyle = `rgba(34, 197, 94, ${alpha * 1.5})`; // Make pulse lines slightly brighter
                            }
                        }

                        ctx.strokeStyle = strokeStyle;
                        ctx.lineWidth = 0.4;
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                        ctx.closePath();
                    }
                }
            }

            // Update and draw each particle
            particles.forEach(p => { p.update(); p.draw(); });

            animationFrameId = requestAnimationFrame(animate);
        }

        function startAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            init();
            animate();
        }

        function stopAnimation() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            animationFrameId = null; // Explicitly clear the animation frame ID
        }

        resizeCanvas();
        startAnimation();
    </script>
</body>
</html>

 